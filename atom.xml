<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Bill Ma&#39;s Blog</title>
  
  <subtitle>Welcome!</subtitle>
  <link href="https://billma.top/atom.xml" rel="self"/>
  
  <link href="https://billma.top/"/>
  <updated>2021-09-13T12:53:08.000Z</updated>
  <id>https://billma.top/</id>
  
  <author>
    <name>Bill Ma</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>cxynb</title>
    <link href="https://billma.top/2021/09/13/cxynb/"/>
    <id>https://billma.top/2021/09/13/cxynb/</id>
    <published>2021-09-13T12:51:27.000Z</published>
    <updated>2021-09-13T12:53:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="陈星宇牛逼"><a href="#陈星宇牛逼" class="headerlink" title="陈星宇牛逼"></a>陈星宇牛逼</h1><h2 id="陈星宇牛逼-1"><a href="#陈星宇牛逼-1" class="headerlink" title="陈星宇牛逼"></a>陈星宇牛逼</h2><h3 id="陈星宇牛逼-2"><a href="#陈星宇牛逼-2" class="headerlink" title="陈星宇牛逼"></a>陈星宇牛逼</h3><p><strong>陈星宇牛逼</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;陈星宇牛逼&quot;&gt;&lt;a href=&quot;#陈星宇牛逼&quot; class=&quot;headerlink&quot; title=&quot;陈星宇牛逼&quot;&gt;&lt;/a&gt;陈星宇牛逼&lt;/h1&gt;&lt;h2 id=&quot;陈星宇牛逼-1&quot;&gt;&lt;a href=&quot;#陈星宇牛逼-1&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="陈星宇牛逼" scheme="https://billma.top/categories/%E9%99%88%E6%98%9F%E5%AE%87%E7%89%9B%E9%80%BC/"/>
    
    
  </entry>
  
  <entry>
    <title>如何科学上网？</title>
    <link href="https://billma.top/2021/09/04/vpn-how-to-open/"/>
    <id>https://billma.top/2021/09/04/vpn-how-to-open/</id>
    <published>2021-09-04T12:32:35.000Z</published>
    <updated>2021-09-04T13:42:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>相信很多同学都想科学上网，但是由于工 信 部的限制，很少有人能真正科学上网。我今天就介绍几个我长期摸索出来的科学上网工具。</p><h2 id="1-Windows"><a href="#1-Windows" class="headerlink" title="1.Windows"></a>1.Windows</h2><h4 id="1-安装-Microsoft-edge"><a href="#1-安装-Microsoft-edge" class="headerlink" title="1.安装 Microsoft edge"></a>1.安装 Microsoft edge</h4><p>其实理论上Google Chrome更加适合，但是你想接下来的操作本身需要科学上网才能访问Google play，所以在这里使用Microsoft edge。</p><p><a href="https://dl.softmgr.qq.com/original/Browser/MicrosoftEdgeSetup-win7-92.0.902.84.exe">Windows7点这里下载</a></p><p><a href="https://dl.softmgr.qq.com/original/Browser/MicrosoftEdgeSetup-win10-92.0.902.84.exe">Windows10点这里下载</a></p><h4 id="2-安装扩展"><a href="#2-安装扩展" class="headerlink" title="2.安装扩展"></a>2.安装扩展</h4><p>打开edge，<a href="https://microsoftedge.microsoft.com/addons/detail/setupvpn-lifetime-free-/okhjkpgblgdjappgfgakbcecdblgffcl?hl=zh-CN">打开这个网页</a>,点击安装即可。</p><h4 id="3-配置"><a href="#3-配置" class="headerlink" title="3.配置"></a>3.配置</h4><p>点开这个科学上网工具，选择汉语，会跳出一个输入邀请码的东西，不要管他，下面有一个create new account，点击，然后三个协议全选择，跳出一个页面，选择美国即可。</p><h2 id="2-iOS-iphone-or-ipad"><a href="#2-iOS-iphone-or-ipad" class="headerlink" title="2.iOS(iphone or ipad)"></a>2.iOS(iphone or ipad)</h2><h4 id="1-获取Apple-ID"><a href="#1-获取Apple-ID" class="headerlink" title="1.获取Apple ID"></a>1.获取Apple ID</h4><p>由于上述国家部门的要求，Apple Inc中国区下架了所有科学上网工具。所以，现在手机上<a href="apple.com">点击这里</a>注册<strong>一个新的</strong>Apple ID。</p><p>注意，在注册时会让你选择国家与地区，选择美国即可。</p><h4 id="2-登录"><a href="#2-登录" class="headerlink" title="2.登录"></a>2.登录</h4><p>随后，点开App Store，登出后登陆你新注册的Apple ID，随后自动跳转到美国区，搜索V P N 3 6 0即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;相信很多同学都想科学上网，但是由于工 信 部的限制，很少有人能真正科学上网。我今天就介绍几个我长期摸索出来的科学上网工具。&lt;/p&gt;
&lt;h2 id=&quot;1-Windows&quot;&gt;&lt;a href=&quot;#1-Windows&quot; class=&quot;headerlink&quot; title=&quot;1.Win</summary>
      
    
    
    
    <category term="日常经验" scheme="https://billma.top/categories/%E6%97%A5%E5%B8%B8%E7%BB%8F%E9%AA%8C/"/>
    
    
  </entry>
  
  <entry>
    <title>今日编程发现--缩进问题</title>
    <link href="https://billma.top/2021/08/29/cpp-if-else-question-1/"/>
    <id>https://billma.top/2021/08/29/cpp-if-else-question-1/</id>
    <published>2021-08-29T08:11:52.000Z</published>
    <updated>2021-08-29T08:17:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天偶然看到一段代码是这么写的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(...)</span><br><span class="line">    <span class="keyword">if</span>(...)</span><br><span class="line">        ...</span><br><span class="line">  <span class="keyword">else</span> ...</span><br></pre></td></tr></table></figure><p>那么问题来了，这么缩进这个else跟的是谁呢？</p><p>其实根据C++原则，else跟的是离他更近的那个if。但是，如果别欣赏这段代码的时候，那可真的难为人家了。</p><p>所以，严格按照语法编代码，保持KISS(Keep it simple,stupid)是最基本的原则。不要写容易混淆的代码。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天偶然看到一段代码是这么写的：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>GitHub下载速度太慢怎么办？</title>
    <link href="https://billma.top/2021/08/29/github-speed-up-download/"/>
    <id>https://billma.top/2021/08/29/github-speed-up-download/</id>
    <published>2021-08-29T07:17:38.000Z</published>
    <updated>2021-09-04T13:42:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>在本站中，有一些下载项目是我通过GitHub仓库上传的（下载地址：<a href="billmarepo.github.io">billmarepo.github.io</a>）,但是GitHub在中国大陆地区访问较慢，下载速度更是令人感慨（但是亲测速度比百度网盘快）。那么，在下载本站资源时遇到GitHub下载太慢该如何处置？</p><h2 id="1-复制"><a href="#1-复制" class="headerlink" title="1.复制"></a>1.复制</h2><p>找到下载的资源，右击选择：复制目标链接（反正就这个意思，不同浏览器显示不同）。</p><h2 id="2-GitHub文件加速"><a href="#2-GitHub文件加速" class="headerlink" title="2.GitHub文件加速"></a>2.GitHub文件加速</h2><p>利用 Cloudflare Workers 对 github release 、archive 以及项目文件进行加速，部署无需服务器且自带CDN.<br><a href="https://gh.api.99988866.xyz/">https://gh.api.99988866.xyz</a><br><a href="https://ghproxy.com/">https://ghproxy.com/</a><br>以上网站为演示站点，如无法打开可以查看开源项目：gh-proxy-GitHub 文件加速自行部署。</p><h2 id="3-Github-加速下载"><a href="#3-Github-加速下载" class="headerlink" title="3.Github 加速下载"></a>3.Github 加速下载</h2><p>将你复制的链接到以下网址就可以加速下载了！</p><p>地址：<a href="http://toolwa.com/github/">http://toolwa.com/github/</a></p><h2 id="4-其他友情链接"><a href="#4-其他友情链接" class="headerlink" title="4.其他友情链接"></a>4.其他友情链接</h2><h3 id="官网镜像（可以用来clone-push等-但是不能登录）"><a href="#官网镜像（可以用来clone-push等-但是不能登录）" class="headerlink" title="官网镜像（可以用来clone push等,但是不能登录）"></a>官网镜像（可以用来clone push等,但是不能登录）</h3><p><a href="https://github.com.cnpmjs.org/">https://github.com.cnpmjs.org/</a></p><p><a href="https://hub.fastgit.org/">https://hub.fastgit.org/</a> <strong>（速度最快）</strong></p><p><a href="https://github.wuyanzheshui.workers.dev/">https://github.wuyanzheshui.workers.dev/</a></p><h3 id="API镜像（用来api操作）"><a href="#API镜像（用来api操作）" class="headerlink" title="API镜像（用来api操作）"></a>API镜像（用来api操作）</h3><p><a href="https://api.git.sdut.me/">https://api.git.sdut.me/</a></p><p><a href="https://v2.kkpp.cc/">https://v2.kkpp.cc/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在本站中，有一些下载项目是我通过GitHub仓库上传的（下载地址：&lt;a href=&quot;billmarepo.github.io&quot;&gt;billmarepo.github.io&lt;/a&gt;）,但是GitHub在中国大陆地区访问较慢，下载速度更是令人感慨（但是亲测速度比百度网盘快）。那么</summary>
      
    
    
    
    <category term="日常经验" scheme="https://billma.top/categories/%E6%97%A5%E5%B8%B8%E7%BB%8F%E9%AA%8C/"/>
    
    
    <category term="github" scheme="https://billma.top/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>python之matplotlib详细教程</title>
    <link href="https://billma.top/2021/08/26/python-matplotlib/"/>
    <id>https://billma.top/2021/08/26/python-matplotlib/</id>
    <published>2021-08-26T11:44:55.000Z</published>
    <updated>2021-08-29T07:46:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><strong>前提：你已经安装了python并且在安装时勾选了Add Python to PATH</strong></p><p>打开cmd，输入如下指令：（不要复制粘贴）</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install matplotlib</span><br><span class="line">pip install numpy</span><br></pre></td></tr></table></figure><p>安装完后打开python，就可以开始了！</p><h1 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><h1 id="1请求一个新的figure对象"><a href="#1请求一个新的figure对象" class="headerlink" title="1请求一个新的figure对象"></a>1请求一个新的figure对象</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.figure()</span><br></pre></td></tr></table></figure><h2 id="1-2Axes"><a href="#1-2Axes" class="headerlink" title="1.2Axes"></a>1.2Axes</h2><p>在拥有Figure对象之后，在作画前我们还需要轴，没有轴的话就没有绘图基准，所以需要添加Axes。也可以理解成为真正可以作画的纸。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fig = plt.figure()</span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line">ax.<span class="built_in">set</span>(xlim=[<span class="number">0.5</span>, <span class="number">4.5</span>], ylim=[-<span class="number">2</span>, <span class="number">8</span>], title=<span class="string">&#x27;An Example Axes&#x27;</span>,</span><br><span class="line">       ylabel=<span class="string">&#x27;Y-Axis&#x27;</span>, xlabel=<span class="string">&#x27;X-Axis&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>上的代码，在一幅图上添加了一个Axes，然后设置了这个Axes的X轴以及Y轴的取值范围（这些设置并不是强制的，后面会再谈到关于这些设置）</p><p>对于上面的fig.add_subplot(111)就是添加Axes的，参数的解释的在画板的第1行第1列的第一个位置生成一个Axes对象来准备作画。也可以通过fig.add_subplot(2, 2, 1)的方式生成Axes，前面两个参数确定了面板的划分，例如 2， 2会将整个面板划分成 2 * 2 的方格，第三个参数取值范围是 [1, 2*2] 表示第几个Axes。如下面的例子：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fig = plt.figure()</span><br><span class="line">ax1 = fig.add_subplot(<span class="number">221</span>)</span><br><span class="line">ax2 = fig.add_subplot(<span class="number">222</span>)</span><br><span class="line">ax3 = fig.add_subplot(<span class="number">224</span>)</span><br></pre></td></tr></table></figure><h2 id="1-3-Multiple-Axes"><a href="#1-3-Multiple-Axes" class="headerlink" title="1.3 Multiple Axes"></a>1.3 Multiple Axes</h2><p>可以发现我们上面添加 Axes 似乎有点弱鸡，所以提供了下面的方式一次性生成所有 Axes：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fig, axes = plt.subplots(nrows=<span class="number">2</span>, ncols=<span class="number">2</span>)</span><br><span class="line">axes[<span class="number">0</span>,<span class="number">0</span>].<span class="built_in">set</span>(title=<span class="string">&#x27;Upper Left&#x27;</span>)</span><br><span class="line">axes[<span class="number">0</span>,<span class="number">1</span>].<span class="built_in">set</span>(title=<span class="string">&#x27;Upper Right&#x27;</span>)</span><br><span class="line">axes[<span class="number">1</span>,<span class="number">0</span>].<span class="built_in">set</span>(title=<span class="string">&#x27;Lower Left&#x27;</span>)</span><br><span class="line">axes[<span class="number">1</span>,<span class="number">1</span>].<span class="built_in">set</span>(title=<span class="string">&#x27;Lower Right&#x27;</span>)</span><br></pre></td></tr></table></figure><p>fig 还是我们熟悉的画板， axes 成了我们常用二维数组的形式访问，这在循环绘图时，额外好用。</p><h2 id="1-4-Axes-Vs-pyplot"><a href="#1-4-Axes-Vs-pyplot" class="headerlink" title="1.4 Axes Vs .pyplot"></a>1.4 Axes Vs .pyplot</h2><p>相信不少人看过下面的代码，很简单并易懂，但是下面的作画方式只适合简单的绘图，快速的将图绘出。在处理复杂的绘图工作时，我们还是需要使用 Axes 来完成作画的。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plt.plot([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">10</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">30</span>], color=<span class="string">&#x27;lightblue&#x27;</span>, linewidth=<span class="number">3</span>)</span><br><span class="line">plt.xlim(<span class="number">0.5</span>, <span class="number">4.5</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h1 id="2-基本绘图2D"><a href="#2-基本绘图2D" class="headerlink" title="2. 基本绘图2D"></a>2. 基本绘图2D</h1><h2 id="2-1-线"><a href="#2-1-线" class="headerlink" title="2.1 线"></a>2.1 线</h2><p>plot()函数画出一系列的点，并且用线将它们连接起来。看下例子：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = np.linspace(<span class="number">0</span>, np.pi)</span><br><span class="line">y_sin = np.sin(x)</span><br><span class="line">y_cos = np.cos(x)</span><br><span class="line"></span><br><span class="line">ax1.plot(x, y_sin)</span><br><span class="line">ax2.plot(x, y_sin, <span class="string">&#x27;go--&#x27;</span>, linewidth=<span class="number">2</span>, markersize=<span class="number">12</span>)</span><br><span class="line">ax3.plot(x, y_cos, color=<span class="string">&#x27;red&#x27;</span>, marker=<span class="string">&#x27;+&#x27;</span>, linestyle=<span class="string">&#x27;dashed&#x27;</span>)</span><br></pre></td></tr></table></figure><p>在上面的三个Axes上作画。plot，前面两个参数为x轴、y轴数据。ax2的第三个参数是 MATLAB风格的绘图，对应ax3上的颜色，marker，线型。</p><p>另外，我们可以通过关键字参数的方式绘图，如下例：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">10</span>, <span class="number">200</span>)</span><br><span class="line">data_obj = &#123;<span class="string">&#x27;x&#x27;</span>: x,</span><br><span class="line">            <span class="string">&#x27;y1&#x27;</span>: <span class="number">2</span> * x + <span class="number">1</span>,</span><br><span class="line">            <span class="string">&#x27;y2&#x27;</span>: <span class="number">3</span> * x + <span class="number">1.2</span>,</span><br><span class="line">            <span class="string">&#x27;mean&#x27;</span>: <span class="number">0.5</span> * x * np.cos(<span class="number">2</span>*x) + <span class="number">2.5</span> * x + <span class="number">1.1</span>&#125;</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line"></span><br><span class="line"><span class="comment">#填充两条线之间的颜色</span></span><br><span class="line">ax.fill_between(<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y1&#x27;</span>, <span class="string">&#x27;y2&#x27;</span>, color=<span class="string">&#x27;yellow&#x27;</span>, data=data_obj)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot the &quot;centerline&quot; with `plot`</span></span><br><span class="line">ax.plot(<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;mean&#x27;</span>, color=<span class="string">&#x27;black&#x27;</span>, data=data_obj)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>发现上面的作图，在数据部分只传入了字符串，这些字符串对一个这 data_obj 中的关键字，当以这种方式作画时，将会在传入给 data 中寻找对应关键字的数据来绘图。</p><h2 id="2-2-散点图"><a href="#2-2-散点图" class="headerlink" title="2.2 散点图"></a>2.2 散点图</h2><p>只画点，但是不用线连接起来。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = np.arange(<span class="number">10</span>)</span><br><span class="line">y = np.random.randn(<span class="number">10</span>)</span><br><span class="line">plt.scatter(x, y, color=<span class="string">&#x27;red&#x27;</span>, marker=<span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="2-3-条形图"><a href="#2-3-条形图" class="headerlink" title="2.3 条形图"></a>2.3 条形图</h2><p>条形图分两种，一种是水平的，一种是垂直的，见下例子：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">1</span>)</span><br><span class="line">x = np.arange(<span class="number">5</span>)</span><br><span class="line">y = np.random.randn(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">fig, axes = plt.subplots(ncols=<span class="number">2</span>, figsize=plt.figaspect(<span class="number">1.</span>/<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">vert_bars = axes[<span class="number">0</span>].bar(x, y, color=<span class="string">&#x27;lightblue&#x27;</span>, align=<span class="string">&#x27;center&#x27;</span>)</span><br><span class="line">horiz_bars = axes[<span class="number">1</span>].barh(x, y, color=<span class="string">&#x27;lightblue&#x27;</span>, align=<span class="string">&#x27;center&#x27;</span>)</span><br><span class="line"><span class="comment">#在水平或者垂直方向上画线</span></span><br><span class="line">axes[<span class="number">0</span>].axhline(<span class="number">0</span>, color=<span class="string">&#x27;gray&#x27;</span>, linewidth=<span class="number">2</span>)</span><br><span class="line">axes[<span class="number">1</span>].axvline(<span class="number">0</span>, color=<span class="string">&#x27;gray&#x27;</span>, linewidth=<span class="number">2</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>条形图还返回了一个Artists 数组，对应着每个条形，例如上图 Artists 数组的大小为5，我们可以通过这些 Artists 对条形图的样式进行更改，如下例：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots()</span><br><span class="line">vert_bars = ax.bar(x, y, color=<span class="string">&#x27;lightblue&#x27;</span>, align=<span class="string">&#x27;center&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># We could have also done this with two separate calls to `ax.bar` and numpy boolean indexing.</span></span><br><span class="line"><span class="keyword">for</span> bar, height <span class="keyword">in</span> <span class="built_in">zip</span>(vert_bars, y):</span><br><span class="line">    <span class="keyword">if</span> height &lt; <span class="number">0</span>:</span><br><span class="line">        bar.<span class="built_in">set</span>(edgecolor=<span class="string">&#x27;darkred&#x27;</span>, color=<span class="string">&#x27;salmon&#x27;</span>, linewidth=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="2-4-直方图"><a href="#2-4-直方图" class="headerlink" title="2.4 直方图"></a>2.4 直方图</h2><p>直方图用于统计数据出现的次数或者频率，有多种参数可以调整，见下例：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">19680801</span>)</span><br><span class="line"></span><br><span class="line">n_bins = <span class="number">10</span></span><br><span class="line">x = np.random.randn(<span class="number">1000</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">fig, axes = plt.subplots(nrows=<span class="number">2</span>, ncols=<span class="number">2</span>)</span><br><span class="line">ax0, ax1, ax2, ax3 = axes.flatten()</span><br><span class="line"></span><br><span class="line">colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;tan&#x27;</span>, <span class="string">&#x27;lime&#x27;</span>]</span><br><span class="line">ax0.hist(x, n_bins, density=<span class="literal">True</span>, histtype=<span class="string">&#x27;bar&#x27;</span>, color=colors, label=colors)</span><br><span class="line">ax0.legend(prop=&#123;<span class="string">&#x27;size&#x27;</span>: <span class="number">10</span>&#125;)</span><br><span class="line">ax0.set_title(<span class="string">&#x27;bars with legend&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ax1.hist(x, n_bins, density=<span class="literal">True</span>, histtype=<span class="string">&#x27;barstacked&#x27;</span>)</span><br><span class="line">ax1.set_title(<span class="string">&#x27;stacked bar&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ax2.hist(x,  histtype=<span class="string">&#x27;barstacked&#x27;</span>, rwidth=<span class="number">0.9</span>)</span><br><span class="line"></span><br><span class="line">ax3.hist(x[:, <span class="number">0</span>], rwidth=<span class="number">0.9</span>)</span><br><span class="line">ax3.set_title(<span class="string">&#x27;different sample sizes&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fig.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>参数中density控制Y轴是概率还是数量，与返回的第一个的变量对应。histtype控制着直方图的样式，默认是 ‘bar’，对于多个条形时就相邻的方式呈现如子图1， ‘barstacked’ 就是叠在一起，如子图2、3。 rwidth 控制着宽度，这样可以空出一些间隙，比较图2、3. 图4是只有一条数据时。</p><h2 id="2-5-饼图"><a href="#2-5-饼图" class="headerlink" title="2.5 饼图"></a>2.5 饼图</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">labels = <span class="string">&#x27;Frogs&#x27;</span>, <span class="string">&#x27;Hogs&#x27;</span>, <span class="string">&#x27;Dogs&#x27;</span>, <span class="string">&#x27;Logs&#x27;</span></span><br><span class="line">sizes = [<span class="number">15</span>, <span class="number">30</span>, <span class="number">45</span>, <span class="number">10</span>]</span><br><span class="line">explode = (<span class="number">0</span>, <span class="number">0.1</span>, <span class="number">0</span>, <span class="number">0</span>)  <span class="comment"># only &quot;explode&quot; the 2nd slice (i.e. &#x27;Hogs&#x27;)</span></span><br><span class="line"></span><br><span class="line">fig1, (ax1, ax2) = plt.subplots(<span class="number">2</span>)</span><br><span class="line">ax1.pie(sizes, labels=labels, autopct=<span class="string">&#x27;%1.1f%%&#x27;</span>, shadow=<span class="literal">True</span>)</span><br><span class="line">ax1.axis(<span class="string">&#x27;equal&#x27;</span>)</span><br><span class="line">ax2.pie(sizes, autopct=<span class="string">&#x27;%1.2f%%&#x27;</span>, shadow=<span class="literal">True</span>, startangle=<span class="number">90</span>, explode=explode,</span><br><span class="line">    pctdistance=<span class="number">1.12</span>)</span><br><span class="line">ax2.axis(<span class="string">&#x27;equal&#x27;</span>)</span><br><span class="line">ax2.legend(labels=labels, loc=<span class="string">&#x27;upper right&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>饼图自动根据数据的百分比画饼.。labels是各个块的标签，如子图一。autopct=%1.1f%%表示格式化百分比精确输出，explode，突出某些块，不同的值突出的效果不一样。pctdistance=1.12百分比距离圆心的距离，默认是0.6.</p><h2 id="2-6-箱形图"><a href="#2-6-箱形图" class="headerlink" title="2.6 箱形图"></a>2.6 箱形图</h2><p>为了专注于如何画图，省去数据的处理部分。 data 的 shape 为 (n, )， data2 的 shape 为 (n, 3)。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fig, (ax1, ax2) = plt.subplots(<span class="number">2</span>)</span><br><span class="line">ax1.boxplot(data)</span><br><span class="line">ax2.boxplot(data2, vert=<span class="literal">False</span>) <span class="comment">#控制方向</span></span><br></pre></td></tr></table></figure><p>2.7 泡泡图<br>散点图的一种，加入了第三个值 s 可以理解成普通散点，画的是二维，泡泡图体现了Z的大小，如下例：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">19680801</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">N = <span class="number">50</span></span><br><span class="line">x = np.random.rand(N)</span><br><span class="line">y = np.random.rand(N)</span><br><span class="line">colors = np.random.rand(N)</span><br><span class="line">area = (<span class="number">30</span> * np.random.rand(N))**<span class="number">2</span>  <span class="comment"># 0 to 15 point radii</span></span><br><span class="line"></span><br><span class="line">plt.scatter(x, y, s=area, c=colors, alpha=<span class="number">0.5</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="2-8-等高线（轮廓图）"><a href="#2-8-等高线（轮廓图）" class="headerlink" title="2.8 等高线（轮廓图）"></a>2.8 等高线（轮廓图）</h2><p>有时候需要描绘边界的时候，就会用到轮廓图，机器学习用的决策边界也常用轮廓图来绘画，见下例：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fig, (ax1, ax2) = plt.subplots(<span class="number">2</span>)</span><br><span class="line">x = np.arange(-<span class="number">5</span>, <span class="number">5</span>, <span class="number">0.1</span>)</span><br><span class="line">y = np.arange(-<span class="number">5</span>, <span class="number">5</span>, <span class="number">0.1</span>)</span><br><span class="line">xx, yy = np.meshgrid(x, y, sparse=<span class="literal">True</span>)</span><br><span class="line">z = np.sin(xx**<span class="number">2</span> + yy**<span class="number">2</span>) / (xx**<span class="number">2</span> + yy**<span class="number">2</span>)</span><br><span class="line">ax1.contourf(x, y, z)</span><br><span class="line">ax2.contour(x, y, z)</span><br></pre></td></tr></table></figure><p>上面画了两个一样的轮廓图，contourf会填充轮廓线之间的颜色。数据x, y, z通常是具有相同 shape 的二维矩阵。x, y 可以为一维向量，但是必需有 z.shape = (y.n, x.n) ，这里 y.n 和 x.n 分别表示x、y的长度。Z通常表示的是距离X-Y平面的距离，传入X、Y则是控制了绘制等高线的范围。</p><h1 id="3-布局、图例说明、边界等"><a href="#3-布局、图例说明、边界等" class="headerlink" title="3 布局、图例说明、边界等"></a>3 布局、图例说明、边界等</h1><h2 id="3-1区间上下限"><a href="#3-1区间上下限" class="headerlink" title="3.1区间上下限"></a>3.1区间上下限</h2><p>当绘画完成后，会发现X、Y轴的区间是会自动调整的，并不是跟我们传入的X、Y轴数据中的最值相同。为了调整区间我们使用下面的方式：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ax.set_xlim([xmin, xmax])   <span class="comment">#设置X轴的区间</span></span><br><span class="line">ax.set_ylim([ymin, ymax])   <span class="comment">#Y轴区间</span></span><br><span class="line">ax.axis([xmin, xmax, ymin, ymax])   <span class="comment">#X、Y轴区间</span></span><br><span class="line">ax.set_ylim(bottom=-<span class="number">10</span>)     <span class="comment">#Y轴下限</span></span><br><span class="line">ax.set_xlim(right=<span class="number">25</span>)       <span class="comment">#X轴上限</span></span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">2</span>*np.pi)</span><br><span class="line">y = np.sin(x)</span><br><span class="line">fig, (ax1, ax2) = plt.subplots(<span class="number">2</span>)</span><br><span class="line">ax1.plot(x, y)</span><br><span class="line">ax2.plot(x, y)</span><br><span class="line">ax2.set_xlim([-<span class="number">1</span>, <span class="number">6</span>])</span><br><span class="line">ax2.set_ylim([-<span class="number">1</span>, <span class="number">3</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>可以看出修改了区间之后影响了图片显示的效果。</p><h2 id="3-2-图例说明"><a href="#3-2-图例说明" class="headerlink" title="3.2 图例说明"></a>3.2 图例说明</h2><p>我们如果我们在一个Axes上做多次绘画，那么可能出现分不清哪条线或点所代表的意思。这个时间添加图例说明，就可以解决这个问题了，见下例：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots()</span><br><span class="line">ax.plot([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">10</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">30</span>], label=<span class="string">&#x27;Philadelphia&#x27;</span>)</span><br><span class="line">ax.plot([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">30</span>, <span class="number">23</span>, <span class="number">13</span>, <span class="number">4</span>], label=<span class="string">&#x27;Boston&#x27;</span>)</span><br><span class="line">ax.scatter([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">20</span>, <span class="number">10</span>, <span class="number">30</span>, <span class="number">15</span>], label=<span class="string">&#x27;Point&#x27;</span>)</span><br><span class="line">ax.<span class="built_in">set</span>(ylabel=<span class="string">&#x27;Temperature (deg C)&#x27;</span>, xlabel=<span class="string">&#x27;Time&#x27;</span>, title=<span class="string">&#x27;A tale of two cities&#x27;</span>)</span><br><span class="line">ax.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>在绘图时传入 label 参数，并最后调用ax.legend()显示体力说明，对于 legend 还是传入参数，控制图例说明显示的位置：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Location StringLocation Code</span><br><span class="line">‘best’<span class="number">0</span></span><br><span class="line">‘upper right’<span class="number">1</span></span><br><span class="line">‘upper left’<span class="number">2</span></span><br><span class="line">‘lower left’<span class="number">3</span></span><br><span class="line">‘lower right’<span class="number">4</span></span><br><span class="line">‘right’<span class="number">5</span></span><br><span class="line">‘center left’<span class="number">6</span></span><br><span class="line">‘center right’<span class="number">7</span></span><br><span class="line">‘lower center’<span class="number">8</span></span><br><span class="line">‘upper center’<span class="number">9</span></span><br><span class="line">‘center’<span class="number">10</span></span><br></pre></td></tr></table></figure><h2 id="3-3-区间分段"><a href="#3-3-区间分段" class="headerlink" title="3.3 区间分段"></a>3.3 区间分段</h2><p>默认情况下，绘图结束之后，Axes 会自动的控制区间的分段。见下例：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">data = [(<span class="string">&#x27;apples&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;oranges&#x27;</span>, <span class="number">3</span>), (<span class="string">&#x27;peaches&#x27;</span>, <span class="number">1</span>)]</span><br><span class="line">fruit, value = <span class="built_in">zip</span>(*data)</span><br><span class="line"></span><br><span class="line">fig, (ax1, ax2) = plt.subplots(<span class="number">2</span>)</span><br><span class="line">x = np.arange(<span class="built_in">len</span>(fruit))</span><br><span class="line">ax1.bar(x, value, align=<span class="string">&#x27;center&#x27;</span>, color=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">ax2.bar(x, value, align=<span class="string">&#x27;center&#x27;</span>, color=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ax2.<span class="built_in">set</span>(xticks=x, xticklabels=fruit)</span><br><span class="line"></span><br><span class="line"><span class="comment">#ax.tick_params(axis=&#x27;y&#x27;, direction=&#x27;inout&#x27;, length=10) #修改 ticks 的方向以及长度</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>上面不仅修改了X轴的区间段，并且修改了显示的信息为文本。</p><h2 id="3-4-布局"><a href="#3-4-布局" class="headerlink" title="3.4 布局"></a>3.4 布局</h2><p>当我们绘画多个子图时，就会有一些美观的问题存在，例如子图之间的间隔，子图与画板的外边间距以及子图的内边距，下面说明这个问题：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fig, axes = plt.subplots(<span class="number">2</span>, <span class="number">2</span>, figsize=(<span class="number">9</span>, <span class="number">9</span>))</span><br><span class="line">fig.subplots_adjust(wspace=<span class="number">0.5</span>, hspace=<span class="number">0.3</span>,</span><br><span class="line">                    left=<span class="number">0.125</span>, right=<span class="number">0.9</span>,</span><br><span class="line">                    top=<span class="number">0.9</span>,    bottom=<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#fig.tight_layout() #自动调整布局，使标题之间不重叠</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>通过fig.subplots_adjust()我们修改了子图水平之间的间隔wspace=0.5，垂直方向上的间距hspace=0.3，左边距left=0.125 等等，这里数值都是百分比的。以 [0, 1] 为区间，选择left、right、bottom、top 注意 top 和 right 是 0.9 表示上、右边距为百分之10。不确定如果调整的时候，fig.tight_layout()是一个很好的选择。之前说到了内边距，内边距是子图的，也就是 Axes 对象，所以这样使用 ax.margins(x=0.1, y=0.1)，当值传入一个值时，表示同时修改水平和垂直方向的内边距。</p><p>调整使他们使用一样的X、Y轴：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fig, (ax1, ax2) = plt.subplots(<span class="number">1</span>, <span class="number">2</span>, sharex=<span class="literal">True</span>, sharey=<span class="literal">True</span>)</span><br><span class="line">ax1.plot([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">ax2.plot([<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="3-5-轴相关"><a href="#3-5-轴相关" class="headerlink" title="3.5 轴相关"></a>3.5 轴相关</h2><p>改变边界的位置，去掉四周的边框：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots()</span><br><span class="line">ax.plot([-<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [-<span class="number">10</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">5</span>])</span><br><span class="line">ax.spines[<span class="string">&#x27;top&#x27;</span>].set_visible(<span class="literal">False</span>)     <span class="comment">#顶边界不可见</span></span><br><span class="line">ax.xaxis.set_ticks_position(<span class="string">&#x27;bottom&#x27;</span>)  <span class="comment"># ticks 的位置为下方，分上下的。</span></span><br><span class="line">ax.spines[<span class="string">&#x27;right&#x27;</span>].set_visible(<span class="literal">False</span>)   <span class="comment">#右边界不可见</span></span><br><span class="line">ax.yaxis.set_ticks_position(<span class="string">&#x27;left&#x27;</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># &quot;outward&quot;</span></span><br><span class="line"><span class="comment"># 移动左、下边界离 Axes 10 个距离</span></span><br><span class="line"><span class="comment">#ax.spines[&#x27;bottom&#x27;].set_position((&#x27;outward&#x27;, 10))</span></span><br><span class="line"><span class="comment">#ax.spines[&#x27;left&#x27;].set_position((&#x27;outward&#x27;, 10))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># &quot;data&quot;</span></span><br><span class="line"><span class="comment"># 移动左、下边界到 (0, 0) 处相交</span></span><br><span class="line">ax.spines[<span class="string">&#x27;bottom&#x27;</span>].set_position((<span class="string">&#x27;data&#x27;</span>, <span class="number">0</span>))</span><br><span class="line">ax.spines[<span class="string">&#x27;left&#x27;</span>].set_position((<span class="string">&#x27;data&#x27;</span>, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># &quot;axes&quot;</span></span><br><span class="line"><span class="comment"># 移动边界，按 Axes 的百分比位置</span></span><br><span class="line"><span class="comment">#ax.spines[&#x27;bottom&#x27;].set_position((&#x27;axes&#x27;, 0.75))</span></span><br><span class="line"><span class="comment">#ax.spines[&#x27;left&#x27;].set_position((&#x27;axes&#x27;, 0.3))</span></span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;前提：你已经安装了python并且在安装时勾选了Add Python to PATH&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;打开c</summary>
      
    
    
    
    
    <category term="python" scheme="https://billma.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>从零开始C++——1</title>
    <link href="https://billma.top/2021/08/26/cpp-begin-1/"/>
    <id>https://billma.top/2021/08/26/cpp-begin-1/</id>
    <published>2021-08-26T08:23:43.000Z</published>
    <updated>2021-08-29T02:55:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文为原创文章，请转载时一定要注明作者：Bill Ma，网址<a href="https://billma.top/">https://billma.top</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This blog is licensed under CC BY-NC-SA 4.0 unless stating additionally.</span><br></pre></td></tr></table></figure><h1 id="一-准备工作"><a href="#一-准备工作" class="headerlink" title="一.准备工作"></a>一.准备工作</h1><p>看到这篇文章，说明你已经有了这个想法。那么，想要编程，总得要一个软件吧。如果你已经有一定的其他的语言基础，知道了编程软件的基本架构，建议你使用Microsoft的Visual Studio Code。如果你对编程一无所知，你可以使用小白软件Dev C++。</p><p><a href="https://sm.myapp.com/original/Development/Dev-Cpp_5.11_TDM-GCC_4.9.2_Setup.exe">点此下载DevC++</a></p><p><a href="https://dl.softmgr.qq.com/original/Development/VSCodeUserSetup-x64-1.58.2.exe">点此下载MicrosoftVisualStudioCode</a></p><p>本教程就以Dev C++为实例。</p><h2 id="1-启动界面"><a href="#1-启动界面" class="headerlink" title="1.启动界面"></a>1.启动界面</h2><p>启动界面，发现该界面分为四部分。上面是菜单栏和一堆按钮，右侧是一块大空白，左侧是“项目管理，查看类和调试”，下面是调试。</p><p><img src="https://billmarepo.github.io/cpp-begin-1-image/1.JPG" alt="启动界面"></p><p>接下来，按Ctrl+N，新建一个源代码。</p><p><img src="https://billmarepo.github.io/cpp-begin-1-image/2.JPG"></p><h2 id="2-了解C-基本构造"><a href="#2-了解C-基本构造" class="headerlink" title="2.了解C++基本构造"></a>2.了解C++基本构造</h2><h3 id="a-头文件"><a href="#a-头文件" class="headerlink" title="a.头文件"></a>a.头文件</h3><p>头文件以 <code>#include</code> 开头。你在C++中所用到的所有函数都包含在各种各样的头文件中。比如说，最常见的输出函数printf()就在cstdio头文件中。再比如说，输入输出流cin和cout就在iostream中。如果你懒得记哪个函数在哪个函数库头文件里，你可以偷懒，只写一个：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>这个头文件包含了C++大多数常用头文件。你写了这个就不用再写其它头文件了。但是注意，bits/stdc++.h不包含所有头文件。比如说，比较常用的<code>#include&lt;conio.h&gt;</code>和<code>#include &lt;windows.h&gt;</code>就不在其中。</p><h3 id="b-函数"><a href="#b-函数" class="headerlink" title="b.函数"></a>b.函数</h3><p>函数有很多种，现在讲为时过早，日后再议。现在要知道的是主函数。主函数是C++代码的核心部分。C++所有代码都包含在主函数内。在主函数的最后，需要以<code>return 0;</code>为结尾。</p><h3 id="c-变量"><a href="#c-变量" class="headerlink" title="c.变量"></a>c.变量</h3><p>C++提供了许多变量。其中包含</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//整形变量(存放整数)</span></span><br><span class="line"><span class="keyword">int</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">//浮点型函数</span></span><br><span class="line"><span class="keyword">float</span><span class="comment">//单精度</span></span><br><span class="line"><span class="keyword">double</span><span class="comment">//双精度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符/字符串</span></span><br><span class="line"><span class="keyword">char</span><span class="comment">//单个字符</span></span><br><span class="line">string<span class="comment">//字符串</span></span><br><span class="line"><span class="keyword">wchar_t</span><span class="comment">//单个宽字符，即非英文或数字</span></span><br><span class="line">wstring<span class="comment">//宽字符串</span></span><br></pre></td></tr></table></figure><p>注意，上图的//代表注释，不参与主要运算。</p><p>变量声明方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">char</span> b;</span><br><span class="line">string c;</span><br></pre></td></tr></table></figure><p>哦，差点忘了，你想要运行你的程序，只需要按F11或者选择编译即可。</p><h1 id="2-你的第一个程序"><a href="#2-你的第一个程序" class="headerlink" title="2.你的第一个程序"></a>2.你的第一个程序</h1><p>先从一个例子开始：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Hello World!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-标准输入输出"><a href="#1-标准输入输出" class="headerlink" title="1.标准输入输出"></a>1.标准输入输出</h2><figure class="highlight plaintext"><figcaption><span><iostream>```包含了cout,cin,endl等。cout表示输出，cin表示输入，endl是换行符。C++将键盘作为输入设备，屏幕等为输出设备。而且，C++将你输入的和输出的当作一个流，比如说以下两句话是等价的：</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```C++</span><br><span class="line">cout&lt;&lt;&quot;helloworld!&quot;&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&quot;hello&quot;&lt;&lt;&quot;world!&quot;&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>因为C++是输出流，所以先把hello流出来再把world流出来，和流出来helloworld是一样的。<br>下面是cout和cin的具体用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a,b,c,d</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;<span class="comment">//这里没有endl</span></span><br><span class="line">cout&lt;&lt;a&lt;&lt;b&lt;&lt;c&lt;&lt;endl&lt;&lt;d&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>输入： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">32 44 23 23</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">324423</span><br><span class="line">23</span><br></pre></td></tr></table></figure><p>为什么a和b和c中间没有空格呢？很简单，因为你没有加空格啊。a和b都是数字，没有空格。</p><p>那么，下面代码会输出什么呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;<span class="number">12</span>&lt;&lt;<span class="number">34</span>&lt;&lt;<span class="number">56</span>&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;  <span class="number">12</span>  &lt;&lt;  <span class="number">34</span>  &lt;&lt;  <span class="number">56</span>  &lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;12&quot;</span>&lt;&lt;<span class="string">&quot;34&quot;</span>&lt;&lt;<span class="string">&quot;56&quot;</span>&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;  12  &quot;</span>&lt;&lt;<span class="string">&quot;  34  &quot;</span>&lt;&lt;<span class="string">&quot;  56  &quot;</span>&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123456</span></span><br><span class="line"><span class="number">123456</span></span><br><span class="line"><span class="number">123456</span></span><br><span class="line"><span class="number">12</span>    <span class="number">34</span>    <span class="number">56</span>  </span><br></pre></td></tr></table></figure><p>有人会问，为什么2也是123456？因为在每两个 &lt;&lt; 中，只能有一个量（变量和常量），你用双引号引起来的叫字符串，只有在变量或者字符串里的才能被输出。</p><h1 id="3-你的第二个程序"><a href="#3-你的第二个程序" class="headerlink" title="3.你的第二个程序"></a>3.你的第二个程序</h1><p>这个程序要稍微复杂一点了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    cin&gt;&gt;a;</span><br><span class="line">    a=a+<span class="number">1</span>;</span><br><span class="line">    cout&lt;&lt;a;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入：1，输出：2</p><p>这个a=a+1不是非法语句，而是正确的。这句话翻译成中文就是：a在你原来a的基础上再+1</p><h1 id="4-你的第三个程序"><a href="#4-你的第三个程序" class="headerlink" title="4.你的第三个程序"></a>4.你的第三个程序</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> a=<span class="number">1</span>;a&lt;=<span class="number">7</span>;a++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a==<span class="number">1</span>||a&gt;=<span class="number">6</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;1&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a&lt;=<span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;2&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a&lt;<span class="number">5</span>&amp;&amp;a&gt;<span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;3&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;4&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">3</span><br><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h1 id="未完待续……"><a href="#未完待续……" class="headerlink" title="未完待续……"></a>未完待续……</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文为原创文章，请转载时一定要注明作者：Bill Ma，网址&lt;a href=&quot;https://billma.top/&quot;&gt;https://billma.top&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td</summary>
      
    
    
    
    
    <category term="teach，computer，cpp" scheme="https://billma.top/tags/teach%EF%BC%8Ccomputer%EF%BC%8Ccpp/"/>
    
  </entry>
  
  <entry>
    <title>C++ 中如何处理错误和异常？</title>
    <link href="https://billma.top/2021/08/26/cpp-constructor-exception/"/>
    <id>https://billma.top/2021/08/26/cpp-constructor-exception/</id>
    <published>2021-08-26T08:13:08.000Z</published>
    <updated>2021-09-04T13:03:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>用C++写代码的时候总是避免不了处理错误，一般来说有两种方式，通过函数的返回值或者抛出异常。C语言的错误处理一律是通过函数的返回值来判断的，一般是返回0、NULL或者-1表示错误，或者直接返回错误代码，具体是哪种方式没有统一的规定，各种API也各有各的偏好。譬如fopen函数，当成功时返回文件指针，失败时返回NULL，而POSIX标准的open函数则在成功时返回0或者正数，失败时返回-1，然后需要再通过全局变量errno来判断具体错误是什么，配套的还有一系列perror、strerror这样的函数。</p><h2 id="2-C-的错误处理方式"><a href="#2-C-的错误处理方式" class="headerlink" title="2.C++的错误处理方式"></a>2.C++的错误处理方式</h2><p>C++号称向下兼容C语言，于是就将C语言通过返回值的错误处理方式也搬了进来。但C++最大的不同是引入了异常机制，可以用throw产生一个异常，并通过try和catch来捕获。于是就混乱了，到底是什么时候使用返回值表示错误，什么时候使用异常呢？首先简单谈论一下异常和返回值的特点。</p><h3 id="异常的优点"><a href="#异常的优点" class="headerlink" title="异常的优点"></a>异常的优点</h3><p>错误信息丰富，便于获得错误现场</p><p>代码相对简短，不需要判断每个函数的返回值</p><h3 id="异常的缺点"><a href="#异常的缺点" class="headerlink" title="异常的缺点"></a>异常的缺点</h3><p>使控制流变得复杂，难以追踪</p><p>开销相对较大</p><h3 id="返回值的优点"><a href="#返回值的优点" class="headerlink" title="返回值的优点"></a>返回值的优点</h3><p>性能开销相对小</p><p>避免定义异常类</p><h3 id="返回值的缺点"><a href="#返回值的缺点" class="headerlink" title="返回值的缺点"></a>返回值的缺点</h3><p>程序员经常「忘记」处理错误返回值</p><p>每个可能产生错误的函数在调用后都需要判断是否有错误</p><p>与「真正的」返回值混用，需要规定一个错误代码（通常是0、-1或NULL）<br>使用异常还是返回值</p><p>我的观点是，用异常来表示真正的、而且不太可能发生的错误。所谓不太可能发生的错误，指的是真正难以预料，但发生了却又不得不单独处理的，譬如内存耗尽、读文件发生故障。而在一个字符串中查找一个子串，如果没有找到显然应该是用一个特殊的返回值（如-1），而不应该抛出一个异常。</p><p>一句话来概况就是不要用异常代替正常的控制流，只有当程序真的「不正常」的时候，才使用异常。反过来说，当程序真正发生错误了，一定要使用异常而不是返回一个错误代码，因为错误代码总是倾向于被忽略。如果要保证一个以返回值来表示错误代码的函数的错误正确地向上传递，需要在每个调用了可能产生错误的函数后面都判断一下是否发生了错误，一旦发生了不可解决的错误，就要终止当前函数（并释放当前函数申请的资源），然后向上传递错误。这样一来错误处理代码会被重复地写好几遍，十分冗杂，譬如下面代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;path/to/file&quot;</span>, O_RDONLY);</span><br><span class="line">  <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> ERROR_OPEN;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span>* array = <span class="keyword">new</span>[n];</span><br><span class="line">  <span class="keyword">int</span> err;</span><br><span class="line">  err = <span class="built_in">do_something</span>(fd, array);</span><br><span class="line">  <span class="keyword">if</span> (err != SUCCESS) &#123;</span><br><span class="line">     <span class="keyword">delete</span>[] array;</span><br><span class="line">     <span class="keyword">return</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">  err = <span class="built_in">do_other_thing</span>();</span><br><span class="line">  <span class="keyword">if</span> (err != SUCCESS) &#123;</span><br><span class="line">     <span class="keyword">delete</span>[] array;</span><br><span class="line">     <span class="keyword">return</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">  err = <span class="built_in">do_more_thing</span>();</span><br><span class="line">  <span class="keyword">if</span> (err != SUCCESS) &#123;</span><br><span class="line">     <span class="keyword">delete</span>[] array;</span><br><span class="line">     <span class="keyword">return</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span>[] array;</span><br><span class="line">  <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对使用异常容易增加函数出口的指控其实是不成立的，因为即使使用返回值，这些出口也是免不了的，除非程序员有意或无意忽略掉，但异常是不可忽略的。如果你认为可以把判断错误的if语句缩写到一行使代码变得「更清晰」，那么我只能说是自欺欺人。</p><p>有些错误几乎总是可以被立即恢复（譬如前面所说的查找一个字符串不存在的子串，甚至都不能说这是一个「错误」），而且返回值本身就传递一定信息，就不需要使用异常了。</p><p>鉴于C++没有统一的ABI，并不建议在模块的接口上使用异常。如果要使用，就要把可能曝露给用户的异常全部声明出来，不要把其他类型的异常丢给用户去处理，尤其是内部状态——模块的使用者通常也不会关心模块内部具体是哪条语句发生错误了。</p><h2 id="3-构造函数中的错误"><a href="#3-构造函数中的错误" class="headerlink" title="3.构造函数中的错误"></a>3.构造函数中的错误</h2><p>有一个相当实际的问题是，如何处理构造函数的错误？我们都知道构造函数是没有返回值的，怎么办呢？通常有三种常见的处理方法，标记错误状态、使用一个额外的initialize函数来初始化，或者直接抛出异常。</p><p>合格的C++程序员都知道C++的析构函数中不应该抛出异常，一旦析构函数中的异常没有被捕获，整个程序都要被中止掉。于是许多人就对在构造函数中抛出异常也产生了对等的恐惧，宁可使用一个额外的初始化函数在里面初始化对象的状态并抛出异常（或者返回错误代码）。这样做违背了对象产生和初始化要在一起的原则，强迫用户记住调用一个额外的初始化函数，一旦没有调用直接使用了其他函数，其行为很可能是未定义的。</p><p>使用初始化函数的惟一好处可能是避免了手动释放资源（释放资源的操作交给析构函数来做），因为C++的一个特点是构造函数抛出异常以后析构函数是不会被调用的，所以如果你在构造函数里面申请了内存或者打开了资源，需要在异常产生时关闭。但想想看其实并不能完全避免，因为有些资源可能是要在可能产生错误的函数调用过后才被申请的，还是无法完全避免手工的释放。</p><p>标记错误状态也是一种常见的形式，譬如STL中的ifstream类，当构造时传入一个无法访问的文件作为参数，它不会返回任何错误，而是标记的内部状态为不可用，用户需要手工通过is_open()函数来判断是否打开成功了。同时它还有good()、fail()两个函数，同时也重载了bool类型转换运算符用于在if语句中判断。标记状态的方法在实践中相当丑陋，因为在使用前总是需要判断它是否「真的创建成功了」。</p><p>最直接的方法还是在构造函数中抛出异常，它并不会向析构函数中抛出异常那样有严重的后果，只是需要注意的是抛出异常以后对象没有被创建成功，析构函数也不会被调用，所以应该自行把申请的资源全部都释放掉。</p><h2 id="4-如何在构造函数中捕获异常"><a href="#4-如何在构造函数中捕获异常" class="headerlink" title="4.如何在构造函数中捕获异常"></a>4.如何在构造函数中捕获异常</h2><p>构造函数与普通函数有一个很不一样特性，就是构造函数可以有初始化列表，例如下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">B</span>(<span class="keyword">int</span> val) : <span class="built_in">val_</span>(val * val) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> val_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>(<span class="keyword">int</span> val) : <span class="built_in">b_</span>(val) &#123;</span><br><span class="line">    a_ = val;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> a_;</span><br><span class="line">  B b_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上的代码中A的构造函数的函数体的语句在执行之前会先调用B的构造函数，这时候问题在于，如果B的构造函数抛出了异常，A该如何捕获呢？一个迂回的做法是在A中把B的实例声明为指针，在构造函数和析构函数中分别创建和删除，这样就能捕获到异常了。不过，实际上是有更简单的做法的。下面我要介绍一个C++的很不常见的语法：函数作用域级别的异常捕获。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">B</span>(<span class="keyword">int</span> val) : <span class="built_in">val_</span>(val * val) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;wtf from B&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> val_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>(<span class="keyword">int</span> val) <span class="keyword">try</span> : <span class="built_in">b_</span>(val) &#123;</span><br><span class="line">    a_ = val;</span><br><span class="line">  &#125; <span class="built_in"><span class="keyword">catch</span></span> (runtime_error&amp; e) &#123;</span><br><span class="line">    cerr &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;wtf from A&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> a_;</span><br><span class="line">  B b_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意上面A的构造函数，在参数列表后和初始化列表前增加了try关键字，然后构造函数就被分割为了两部分，前面是初始化，后面是初始化时的错误处理。需要指出的是，catch块里面捕获到的异常不能被忽略，即catch块中必须有一个throw语句重新抛出异常，如果没有，则默认会将原来捕获到的异常重新抛出，这和一般的行为是不同的。例如下面代码运行可以发现A会将捕获到的异常原封不动抛出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>(<span class="keyword">int</span> val) <span class="keyword">try</span> : <span class="built_in">b_</span>(val) &#123;</span><br><span class="line">    a_ = val;</span><br><span class="line">  &#125; <span class="built_in"><span class="keyword">catch</span></span> (runtime_error&amp; e) &#123;</span><br><span class="line">    cerr &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> a_;</span><br><span class="line">  B b_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种语法是C++的标准，而且目前已经被所有的主流C++编译器支持（VS2010、g++ 4.2、clang 3.1），所以几乎不存在兼容性问题，大可放心使用。</p><h2 id="5-其他语言中的错误处理"><a href="#5-其他语言中的错误处理" class="headerlink" title="5.其他语言中的错误处理"></a>5.其他语言中的错误处理</h2><p>Java倾向于大量使用异常，而且还把异常分为了两类分别是检查型异常(Checked Exception)和非检查型异常(Unchecked Exception)，检查型异常就是java.lang.Exception的子类，用于报告需要检查的错误，也就是正常的业务逻辑，错误主要是由用户产生的，方便恢复或给出提示，譬如打开不存在的文件。而非检查型异常则是真正的系统异常，通常由软件缺陷导致，如数组下标越界、错误的类型转换等，这类异常继承于java.lang.RuntimeException或java.lang.Error。</p><p>Python和Java一样也倾向于使用异常，并不一定真的发生故障才抛出异常，譬如字符串转换为整数，如果字符串不合法，Python会抛出一个ValueError异常。甚至Python的迭代器在调用next()时没有更多的结果时会抛出StopIteration 异常。这是典型的用异常来处理正常控制流的方法，在Python中被广泛使用。按照优秀C++代码的标准来看，这是典型的对异常的滥用，既复杂又有额外开销，不推荐使用，但在Python中这是一个广泛遵循的约定。</p><p>相较于Java和Python，Go的错误处理是另一个极端，Go语言则根本没有异常的概念，而是普遍采用返回值的方式来表示错误，同时还提供了panic和recover语法。由于Go有多返回值的特性，避免了错误代码占用返回结果的弊端，所以你可以经常看到函数的最后一个返回值是error类型。由于总是用返回值传递错误，你可以看到Go代码中耦合了大量的错误处理，几乎再每条函数调用语句之后都有一个判断错误是否发生的语句。panic和recover机制十分类似于异常，程序在遇到panic时会一层一层退出调用栈，直到遇到recover。不过recover只在defer中定义，相当于一个函数只有一个recover，而且被recover恢复后会回到错误发生处继续向下执行代码。Go语言倾向于把一般错误都作为返回值传递，除非是非常可怕的、除了重置状态几乎无法恢复错误才会被panic语句抛出。</p><p>Go语言的recover机制和异常比起来，反倒更像Visual Basic语言中的On Error GoTo label及Resume语法。这是一种非结构化的错误处理方式，具体是当声明有On Error GoTo label的函数发生错误以后，会调转到对应的行号，如果再遇到了Resume语句就会返回发生错误的语句后面的一条继续执行，例如下面这段代码：</p><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Sub</span> ErrorDemo</span><br><span class="line">    <span class="keyword">On</span> <span class="keyword">Error</span> <span class="keyword">GoTo</span> ErrorHandler</span><br><span class="line">    <span class="keyword">Dim</span> a <span class="keyword">as</span> <span class="type">Integer</span></span><br><span class="line">    a = <span class="number">1</span>/<span class="number">0</span> <span class="comment">&#x27; An error occurs.</span></span><br><span class="line">    Print a <span class="comment">&#x27; Go back here</span></span><br><span class="line">    <span class="keyword">Exit</span> <span class="keyword">Sub</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">ErrorHandler:</span></span><br><span class="line">    <span class="comment">&#x27; Code that handles errors.</span></span><br><span class="line">    <span class="keyword">Resume</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br></pre></td></tr></table></figure><p>Visual Basic中还有On Error Resume Next这样的万能错误处理语句，即遇到错误以后直接忽略并继续执行，这是一种非常危险而且不负责任的做法，但却可以在早期的Visual Basic代码中到处看到。事实上用返回值传递错误代码的时候许多人也并不处理而是直接忽略，这跟On Error Resume Next本质上没有什么区别，却比On Error Resume Next危害更大——因为On Error Resume Next至少还有个标记说明「老子就是这么不负责任」，但忽略错误返回值就难以被一眼发现了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1.前言&quot;&gt;&lt;/a&gt;1.前言&lt;/h2&gt;&lt;p&gt;用C++写代码的时候总是避免不了处理错误，一般来说有两种方式，通过函数的返回值或者抛出异常。C语言的错误处理一律是通过函数的</summary>
      
    
    
    
    <category term="编程算法" scheme="https://billma.top/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>最长公共子串问题的后缀数组</title>
    <link href="https://billma.top/2021/08/26/lcs-suffix-array/"/>
    <id>https://billma.top/2021/08/26/lcs-suffix-array/</id>
    <published>2021-08-26T07:57:30.000Z</published>
    <updated>2021-09-04T13:04:14.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="最长公共子串"><a href="#最长公共子串" class="headerlink" title="最长公共子串"></a>最长公共子串</h3><p>最长公共子串(Longest Common Substring ,简称LCS)问题，是指求给定的一组字符串长度最大的共有的子串的问题。例如字符串”abcb”,“bca”,“acbc”的LCS就是”bc”。</p><p>求多串的LCS，显然穷举法是极端低效的算法。改进一些的算法是用一个串的每个后缀对其他所有串进行部分匹配，用KMP算法，时间复杂度为O(NL^2)，其中N为字符串个数，L为每个串的长度。更优秀的有广义后缀树的方法，时间可以达到 O(NL)。本文介绍一种基于后缀数组的LCS解法，利用二分查找技术，时间复杂度可以达到O(NLlogL)。</p><h3 id="最长公共子串问题的后缀数组解法"><a href="#最长公共子串问题的后缀数组解法" class="headerlink" title="最长公共子串问题的后缀数组解法"></a>最长公共子串问题的后缀数组解法</h3><p>关于后缀数组的构建方法以及Height数组的性质，本文不再具体介绍，可以参阅IOI国家集训队2004年论文《后缀数组》(许智磊)和IOI国家集训队2009年论文《后缀数组——处理字符串的有力工具》(罗穗骞)。</p><p>回顾一下后缀数组，SA[i]表示排名第i的后缀的位置，Height[i]表示后缀SA[i]和SA[i-1]的最长公共前缀(Longest Common Prefix,LCP)，简记为Height[i]=LCP(SA[i],SA[i-1])。连续的一段后缀SA[i..j]的最长公共前缀，就是H[i-1..j]的最小值，即LCP(SA[i..j])=Min(H[i-1..j])。</p><p>求N个串的最长公共子串，可以转化为求一些后缀的最长公共前缀的最大值，这些后缀应分属于N个串。具体方法如下：</p><p>设N个串分别为S1,S2,S3,…,SN，首先建立一个串S，把这N个串用不同的分隔符连接起来。S=S1[P1]S2[P2]S3…SN-1[PN-1]SN，P1,P2,…PN-1应为不同的N-1个不在字符集中的字符，作为分隔符(后面会解释为什么)。</p><p>接下来，求出字符串S的后缀数组和Height数组，可以用倍增算法，或DC3算法。</p><p>然后二分枚举答案A，假设N个串可以有长度为A的公共字串，并对A的可行性进行验证。如果验证A可行，A’(A’&lt; A)也一定可行，尝试增大A，反之尝试缩小A。最终可以取得A的最大可行值，就是这N个串的最长公共子串的长度。可以证明，尝试次数是O(logL)的。</p><p>于是问题就集中到了，如何验证给定的长度A是否为可行解。方法是，找出在Height数组中找出连续的一段Height[i..j]，使得i&lt;=k&lt;=j均满足Height[k]&gt;=A，并且i-1&lt;=k&lt;=j中，SA[k]分属于原有N个串S1..SN。如果能找到这样的一段，那么A就是可行解，否则A不是可行解。</p><p>具体查找i..j时，可以先从前到后枚举i的位置，如果发现Height[i]&gt;=A，则开始从i向后枚举j的位置，直到找到了Height[j+1] &lt; A，判断[i..j]这个区间内SA是否分属于S1..SN。如果满足，则A为可行解，然后直接返回，否则令i=j+1继续向后枚举。S中每个字符被访问了O(1)次，S的长度为NL+N-1，所以验证的时间复杂度为O(NL)。</p><p>到这里，我们就可以理解为什么分隔符P1..PN-1必须是不同的N-1个不在字符集中的字符了，因为这样才能保证S的后缀的公共前缀不会跨出一个原有串的范围。</p><p>后缀数组是一种处理字符串的强大的数据结构，配合LCP函数与Height数组的性质，后缀数组更是如虎添翼。利用后缀数组，容易地求出了多个串的LCS，而且时空复杂度也相当优秀了。虽然比起后缀树的解法有所不如，但其简明的思路和容易编程的特点却在实际的应用中并不输于后缀树。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;最长公共子串&quot;&gt;&lt;a href=&quot;#最长公共子串&quot; class=&quot;headerlink&quot; title=&quot;最长公共子串&quot;&gt;&lt;/a&gt;最长公共子串&lt;/h3&gt;&lt;p&gt;最长公共子串(Longest Common Substring ,简称LCS)问题，是指求给定的一组字符串长</summary>
      
    
    
    
    <category term="编程算法" scheme="https://billma.top/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>C语言中跨文件的全局变量</title>
    <link href="https://billma.top/2021/08/19/c-global-variables-in-multiple-files/"/>
    <id>https://billma.top/2021/08/19/c-global-variables-in-multiple-files/</id>
    <published>2021-08-19T08:07:04.000Z</published>
    <updated>2021-09-04T13:03:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>首先看一段代码</p><p><strong>func.c</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> buf = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  buf = <span class="number">2</span>;</span><br><span class="line">  <span class="comment">/*Do something else*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>main.c</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> buf;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  buf = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">func</span>();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, buf);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译两个文件，输出的结果是怎样的呢？一眼看上去，可能会输出1，因为两个全局变量buf在不同文件中，又没有extern声明，显然是两个嘛。然而实际上它的运行结果却是2，这说明了这两个文件中引用到的其实是一个变量！</p><p>这是为什么呢？原因是在编译时，C语言编译器将全局符号标记为strong和weak两类：</p><p>函数和初始化的全局符号被标记为strong<br>未初始化的全局符号被标记为weak<br>连接时，连接器对多重定义的全局符号的解析原则如下：</p><p>同一个符号不允许有多个strong定义；<br>假如一个符号有一个strong定义和多个weak定义，那么采用该符号的strong定义；<br>假如一个符号有多个weak定义，那么选取任意一个weak定义<br>由于两个变量一个初始化了，一个没有初始化，所以一个是strong，一个是weak，所以连接器在符号解析时会把他们当成一个。</p><p>如果我们把main.c中的buf也初始化了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> buf = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  buf = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">func</span>();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, buf);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次编译就会发现</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">duplicate symbol _buf in:</span><br><span class="line">    /var/folders/44/_cc501qx1jd1p5bfrjbk6b100000gn/T//ccZ87C6g.o</span><br><span class="line">    /var/folders/44/_cc501qx1jd1p5bfrjbk6b100000gn/T//ccZlES8n.o</span><br><span class="line">ld: 1 duplicate symbol for architecture x86_64</span><br><span class="line">collect2: ld returned 1 exit status</span><br></pre></td></tr></table></figure><p>这是因为两个全局变量都是strong的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;首先看一段代码&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;func.c&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;b</summary>
      
    
    
    
    <category term="编程算法" scheme="https://billma.top/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="computer,cpp" scheme="https://billma.top/tags/computer-cpp/"/>
    
  </entry>
  
  <entry>
    <title>世界最大同性交友网站七夕再搞事————remote  ：Support for password authentication was removed on August 13, 2021.</title>
    <link href="https://billma.top/2021/08/15/github-tokenerror/"/>
    <id>https://billma.top/2021/08/15/github-tokenerror/</id>
    <published>2021-08-15T07:39:00.000Z</published>
    <updated>2021-09-04T13:42:14.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>原创文章，转载注明出处！</strong></p><h3 id="1-问题背景-background"><a href="#1-问题背景-background" class="headerlink" title="1.问题背景-background"></a>1.问题背景-background</h3><p>如果你在七夕（没错就是2021年8月14日）<strong>的这一天去访问了全球最大的同性交友网站</strong>，<strong>又刚好去更新提交代码</strong>，<strong>或者你创建了一个新的仓库送给自己</strong>，<strong>又刚好想把这个仓库送给github</strong>，你就刚好会遇到这个问题：remote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead.<br>大概意思就是你原先的密码凭证从2021年8月13日开始就不能用了，必须使用个人访问令牌（personal access token），就是把你的密码替换成token！</p><p><strong>滚！我tm懒得弄！</strong></p><p><img src="https://i.postimg.cc/zG2L02b1/Q-R9-VOLZG-DIN2-V0-HF-S8.png"> </p><p> <strong>Github <a href="https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/">官方解释</a></strong></p><blockquote><p>We described our motivation as we announced similar changes to authenticating with the API as follows:</p></blockquote><blockquote><p>In recent years, GitHub customers have benefited from a number of security enhancements to GitHub.com, such as two-factor authentication, sign-in alerts, verified devices, preventing the use of compromised passwords, and WebAuthn support. These features make it more difficult for an attacker to take a password that’s been reused across multiple websites and use it to try to gain access to your GitHub account. Despite these improvements, for historical reasons customers without two-factor authentication enabled have been able to continue to authenticate Git and API operations using only their GitHub username and password.</p></blockquote><blockquote><p>Beginning August 13, 2021, we will no longer accept account passwords when authenticating Git operations and will require the use of token-based authentication, such as a personal access token (for developers) or an OAuth or GitHub App installation token (for integrators) for all authenticated Git operations on GitHub.com. You may also continue using SSH keys where you prefer.</p></blockquote><blockquote><p>Tokens offer a number of security benefits over password-based authentication:</p></blockquote><blockquote><p>1.Unique – tokens are specific to GitHub and can be generated per use or per device</p></blockquote><blockquote><p>2.Revocable – tokens can can be individually revoked at any time without needing to update unaffected credentials</p></blockquote><blockquote><p>3.Limited – tokens can be narrowly scoped to allow only the access necessary for the use case</p></blockquote><blockquote><p>4.Random – tokens are not subject to the types of dictionary or brute force attempts that simpler passwords that you need to remember or enter regularly might be</p></blockquote><p>大概意思就是：<strong>为了保证各位程序员的账户安全，我们已于2021年7月14日禁止大家在git及第三方应用上通过密码授权GitHub。以后将使用token令牌代替密码。</strong><br>（话说能活跃在全球最大同性交友网站的程序猿能有什么秘密值得如此加密。。。）</p><h3 id="2-什么是token令牌？"><a href="#2-什么是token令牌？" class="headerlink" title="2.什么是token令牌？"></a>2.什么是token令牌？</h3><p>token令牌相当于在第三方接口代替你密码的一个玩意，有点像强密码。但是，token令牌并不是只能有唯一一个的。你可以拥有多个令牌，给不同的第三方接口不同的令牌，而每个令牌都被赋予了不同的权限和使用期限。也就是说，在令牌没赋予的权利将不会给第三方接口和git。当然，token令牌在你设定的期限之后，对应的第三方接口和git就需要你重新给一个令牌，否则也无法使用。令牌也可以随时更改权限和删除。</p><h3 id="3-如何申请token令牌？"><a href="#3-如何申请token令牌？" class="headerlink" title="3.如何申请token令牌？"></a>3.如何申请token令牌？</h3><p>登陆你的GitHub（<strong>注意，在github.com登录你的账户时还是用你的密码，不是令牌</strong>) 点击头像。随后点击settings。</p><p><img src="https://i.postimg.cc/VLBLHGhV/2.png!/scale/50"></p><p>往下拉，你会在左侧看到一个Developer settings。点击它。</p><p><img src="https://i.postimg.cc/1tqy0J6M/31.png"></p><p>左侧有Personal access tokens。点击它。</p><p><img src="https://i.postimg.cc/RZgCv341/4.png"></p><p>点击右侧generate new token。</p><p><img src="https://i.postimg.cc/sD20t1HC/5.png"></p><p>Note是你令牌的名称（不是令牌密码），随便填一个。</p><p>expiration是令牌有效期限。No expiration代表永久令牌。</p><p>下面是选择相应的权限。一般就选择repo 和delete_repo，其他按需勾选。</p><p>拉到最下面，点击generate token，随后跳出来一个界面，有一串绿底字符串即为你的token令牌。</p><p><img src="https://i.postimg.cc/NQk5NFqj/6.png"></p><p><strong>警告！！在这里你一定要将其复制并保存好！建议新建一个txt文件将令牌放入其中！因为这个令牌只会出现一次，你关闭了这个网页，以后GitHub就再也不会告诉你这个令牌了！妥善保管！</strong>（妥善保管！两情若是久长时，又岂在朝朝暮暮？）</p><p>返回刚才的界面，你可以查看已经创建的token和给予的权限与有效期。你可以随时更改，管理，删除它们（<strong>但是不会显示该令牌</strong>）。</p><p><img src="https://i.postimg.cc/XvhVyTZp/7.png"></p><p>随后回到你的git或第三方接口，账号还是输入你的username(用户名)，password就输入你复制的令牌。随后登陆就成功了。</p><h3 id="果然，全球最大的同性交流网站不是吹的，大七夕节非得找个伴侣，它要过七夕谁也拦不住呀！"><a href="#果然，全球最大的同性交流网站不是吹的，大七夕节非得找个伴侣，它要过七夕谁也拦不住呀！" class="headerlink" title="果然，全球最大的同性交流网站不是吹的，大七夕节非得找个伴侣，它要过七夕谁也拦不住呀！"></a>果然，全球最大的同性交流网站不是吹的，大七夕节非得找个伴侣，它要过七夕谁也拦不住呀！</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;原创文章，转载注明出处！&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;1-问题背景-background&quot;&gt;&lt;a href=&quot;#1-问题背景-background&quot; class=&quot;headerlink&quot; title=&quot;1.问题背景-background&quot;&gt;&lt;/</summary>
      
    
    
    
    <category term="日常经验" scheme="https://billma.top/categories/%E6%97%A5%E5%B8%B8%E7%BB%8F%E9%AA%8C/"/>
    
    
  </entry>
  
  <entry>
    <title>不同的C++中求解A+B的方法</title>
    <link href="https://billma.top/2021/08/12/a-b-problem/"/>
    <id>https://billma.top/2021/08/12/a-b-problem/</id>
    <published>2021-08-12T11:59:56.000Z</published>
    <updated>2021-09-04T13:03:02.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-基础算法"><a href="#1-基础算法" class="headerlink" title="1.基础算法"></a>1.基础算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> a,b;</span><br><span class="line"> cin&gt;&gt;a;</span><br><span class="line"> cin&gt;&gt;b;</span><br><span class="line"> cout&lt;&lt;a+b&lt;&lt;endl;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a+b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-Link-Cut-Tree"><a href="#2-Link-Cut-Tree" class="headerlink" title="2.Link-Cut Tree"></a>2.Link-Cut Tree</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data,rev,sum;</span><br><span class="line">    node *son[<span class="number">2</span>],*pre;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isroot</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setson</span><span class="params">(node *child,<span class="keyword">int</span> lr)</span></span>;</span><br><span class="line">&#125;lct[<span class="number">233</span>];</span><br><span class="line"><span class="keyword">int</span> top,a,b;</span><br><span class="line"><span class="function">node *<span class="title">getnew</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node *now=lct+ ++top;</span><br><span class="line">    now-&gt;data=x;</span><br><span class="line">    now-&gt;pre=now-&gt;son[<span class="number">1</span>]=now-&gt;son[<span class="number">0</span>]=lct;</span><br><span class="line">    now-&gt;sum=<span class="number">0</span>;</span><br><span class="line">    now-&gt;rev=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">node::judge</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> pre-&gt;son[<span class="number">1</span>]==<span class="keyword">this</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">node::isroot</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pre==lct)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> !(pre-&gt;son[<span class="number">1</span>]==<span class="keyword">this</span>||pre-&gt;son[<span class="number">0</span>]==<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">node::pushdown</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>==lct||!rev)<span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">swap</span>(son[<span class="number">0</span>],son[<span class="number">1</span>]);</span><br><span class="line">    son[<span class="number">0</span>]-&gt;rev^=<span class="number">1</span>;</span><br><span class="line">    son[<span class="number">1</span>]-&gt;rev^=<span class="number">1</span>;</span><br><span class="line">    rev=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">node::update</span><span class="params">()</span></span>&#123;sum=son[<span class="number">1</span>]-&gt;sum+son[<span class="number">0</span>]-&gt;sum+data;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">node::setson</span><span class="params">(node *child,<span class="keyword">int</span> lr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">pushdown</span>();</span><br><span class="line">    child-&gt;pre=<span class="keyword">this</span>;</span><br><span class="line">    son[lr]=child;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">update</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(node *now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node *father=now-&gt;pre,*grandfa=father-&gt;pre;</span><br><span class="line">    <span class="keyword">if</span>(!father-&gt;<span class="built_in">isroot</span>()) grandfa-&gt;<span class="built_in">pushdown</span>();</span><br><span class="line">    father-&gt;<span class="built_in">pushdown</span>();now-&gt;<span class="built_in">pushdown</span>();</span><br><span class="line">    <span class="keyword">int</span> lr=now-&gt;<span class="built_in">judge</span>();</span><br><span class="line">    father-&gt;<span class="built_in">setson</span>(now-&gt;son[lr^<span class="number">1</span>],lr);</span><br><span class="line">    <span class="keyword">if</span>(father-&gt;<span class="built_in">isroot</span>()) now-&gt;pre=grandfa;</span><br><span class="line">    <span class="keyword">else</span> grandfa-&gt;<span class="built_in">setson</span>(now,father-&gt;<span class="built_in">judge</span>());</span><br><span class="line">    now-&gt;<span class="built_in">setson</span>(father,lr^<span class="number">1</span>);</span><br><span class="line">    father-&gt;<span class="built_in">update</span>();now-&gt;<span class="built_in">update</span>();</span><br><span class="line">    <span class="keyword">if</span>(grandfa!=lct) grandfa-&gt;<span class="built_in">update</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(node *now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(now-&gt;<span class="built_in">isroot</span>())<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(;!now-&gt;<span class="built_in">isroot</span>();<span class="built_in">rotate</span>(now))</span><br><span class="line">    <span class="keyword">if</span>(!now-&gt;pre-&gt;<span class="built_in">isroot</span>())</span><br><span class="line">    now-&gt;<span class="built_in">judge</span>()==now-&gt;pre-&gt;<span class="built_in">judge</span>()?<span class="built_in">rotate</span>(now-&gt;pre):<span class="built_in">rotate</span>(now);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node *<span class="title">access</span><span class="params">(node *now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node *last=lct;</span><br><span class="line">    <span class="keyword">for</span>(;now!=lct;last=now,now=now-&gt;pre)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">splay</span>(now);</span><br><span class="line">        now-&gt;<span class="built_in">setson</span>(last,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">changeroot</span><span class="params">(node *now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">access</span>(now)-&gt;rev^=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">splay</span>(now);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(node *x,node *y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">changeroot</span>(x);</span><br><span class="line">    x-&gt;pre=y;</span><br><span class="line">    <span class="built_in">access</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cut</span><span class="params">(node *x,node *y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">changeroot</span>(x);</span><br><span class="line">    <span class="built_in">access</span>(y);</span><br><span class="line">    <span class="built_in">splay</span>(x);</span><br><span class="line">    x-&gt;<span class="built_in">pushdown</span>();</span><br><span class="line">    x-&gt;son[<span class="number">1</span>]=y-&gt;pre=lct;</span><br><span class="line">    x-&gt;<span class="built_in">update</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(node *x,node *y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">changeroot</span>(x);</span><br><span class="line">    node *now=<span class="built_in">access</span>(y);</span><br><span class="line">    <span class="keyword">return</span> now-&gt;sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">    node *A=<span class="built_in">getnew</span>(a);</span><br><span class="line">    node *B=<span class="built_in">getnew</span>(b);</span><br><span class="line">        <span class="built_in">connect</span>(A,B);</span><br><span class="line">        <span class="built_in">cut</span>(A,B);</span><br><span class="line">        <span class="built_in">connect</span>(A,B);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">query</span>(A,B)); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-SFPA"><a href="#3-SFPA" class="headerlink" title="3.SFPA"></a>3.SFPA</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m,a,b,op,head[<span class="number">200009</span>],next[<span class="number">200009</span>],dis[<span class="number">200009</span>],len[<span class="number">200009</span>],v[<span class="number">200009</span>],l,r,team[<span class="number">200009</span>],pd[<span class="number">100009</span>],u,v1,e;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lt</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    op++,v[op]=y;</span><br><span class="line">    next[op]=head[x],head[x]=op,len[op]=z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> f)</span><span class="comment">//SPFA……</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">200009</span>;i++)&#123;dis[i]=<span class="number">999999999</span>;&#125;</span><br><span class="line">    l=<span class="number">0</span>,r=<span class="number">1</span>,team[<span class="number">1</span>]=s,pd[s]=<span class="number">1</span>,dis[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l!=r)</span><br><span class="line">    &#123;</span><br><span class="line">        l=(l+<span class="number">1</span>)%<span class="number">90000</span>,u=team[l],pd[u]=<span class="number">0</span>,e=head[u];</span><br><span class="line">        <span class="keyword">while</span>(e!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            v1=v[e];</span><br><span class="line">            <span class="keyword">if</span>(dis[v1]&gt;dis[u]+len[e])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v1]=dis[u]+len[e];</span><br><span class="line">                <span class="keyword">if</span>(!pd[v1])</span><br><span class="line">                &#123;</span><br><span class="line">                    r=(r+<span class="number">1</span>)%<span class="number">90000</span>,</span><br><span class="line">                    team[r]=v1,</span><br><span class="line">                    pd[v1]=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            e=next[e];</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[f];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">    <span class="built_in">lt</span>(<span class="number">1</span>,<span class="number">2</span>,a);<span class="built_in">lt</span>(<span class="number">2</span>,<span class="number">3</span>,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in">SPFA</span>(<span class="number">1</span>,<span class="number">3</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-Floyed"><a href="#4-Floyed" class="headerlink" title="4.Floyed"></a>4.Floyed</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n=<span class="number">3</span>,a,b,dis[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dis[i][j]=<span class="number">2147483647</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dis[<span class="number">1</span>][<span class="number">2</span>]=a,dis[<span class="number">2</span>][<span class="number">3</span>]=b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[i][j]=<span class="built_in">min</span>(dis[i][j],dis[i][k]+dis[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dis[<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-递归算法"><a href="#5-递归算法" class="headerlink" title="5.递归算法"></a>5.递归算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a,b,c;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">dg</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a&lt;=<span class="number">5</span>)&#123;<span class="keyword">return</span> a;&#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">dg</span>(a/<span class="number">2</span>)+<span class="built_in">dg</span>(a-a/<span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    c=<span class="built_in">dg</span>(a)+<span class="built_in">dg</span>(b);</span><br><span class="line">    cout&lt;&lt;c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-高精度计算"><a href="#6-高精度计算" class="headerlink" title="6.高精度计算"></a>6.高精度计算</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a1[<span class="number">1000</span>],b1[<span class="number">1000</span>];</span><br><span class="line">      <span class="keyword">int</span> a[<span class="number">1000</span>]=&#123;<span class="number">0</span>&#125;,b[<span class="number">1000</span>]=&#123;<span class="number">0</span>&#125;,c[<span class="number">1000</span>]=&#123;<span class="number">0</span>&#125;,la,lb,lc,i,x;</span><br><span class="line">      cin&gt;&gt;a1&gt;&gt;b1;</span><br><span class="line">      la=<span class="built_in">strlen</span>(a1);</span><br><span class="line">      lb=<span class="built_in">strlen</span>(b1);</span><br><span class="line">      <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=la<span class="number">-1</span>;i++)&#123;a[la-i]=a1[i]<span class="number">-48</span>;&#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=lb<span class="number">-1</span>;i++)&#123;b[lb-i]=b1[i]<span class="number">-48</span>;&#125;</span><br><span class="line">      lc=<span class="number">1</span>,x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(lc&lt;=la||lc&lt;=lb)&#123;c[lc]=a[lc]+b[lc]+x,x=c[lc]/<span class="number">10</span>,c[lc]%=<span class="number">10</span>,lc++;&#125;</span><br><span class="line">    c[lc]=x;</span><br><span class="line">    <span class="keyword">if</span>(c[lc]==<span class="number">0</span>)&#123;lc--;&#125;</span><br><span class="line">    <span class="keyword">for</span>(i=lc;i&gt;=<span class="number">1</span>;i--)&#123;cout&lt;&lt;c[i];&#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-压位高精"><a href="#7-压位高精" class="headerlink" title="7.压位高精"></a>7.压位高精</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p 8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> carry 100000000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn=<span class="number">50001</span>;  </span><br><span class="line"><span class="keyword">char</span> s1[Maxn],s2[Maxn];  </span><br><span class="line"><span class="keyword">int</span> a[Maxn],b[Maxn],ans[Maxn];  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">char</span> s[],<span class="keyword">int</span> n[])</span>   </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">char</span> temp[Maxn];   </span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(s+<span class="number">1</span>),cur=<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span>(len/p)</span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">strncpy</span>(temp,s+len-p+<span class="number">1</span>,p);</span><br><span class="line">        n[++cur]=<span class="built_in">atoi</span>(temp); </span><br><span class="line">        len-=p;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span>(len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(temp,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(temp));  </span><br><span class="line">        <span class="built_in">strncpy</span>(temp,s+<span class="number">1</span>,len);  </span><br><span class="line">        n[++cur]=<span class="built_in">atoi</span>(temp);   </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> b[],<span class="keyword">int</span> c[],<span class="keyword">int</span> l1,<span class="keyword">int</span> l2)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,l3=<span class="built_in">max</span>(l1,l2);  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=l3;i++)</span><br><span class="line">    &#123;  </span><br><span class="line">        c[i]=a[i]+b[i]+x;  </span><br><span class="line">        x=c[i]/carry;</span><br><span class="line">        c[i]%=carry;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">while</span>(x&gt;<span class="number">0</span>)&#123;c[++l3]=x%<span class="number">10</span>;x/=<span class="number">10</span>;&#125;  </span><br><span class="line">    <span class="keyword">return</span> l3;</span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> len)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a[len]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=len<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)<span class="built_in">printf</span>(<span class="string">&quot;%0*d&quot;</span>,p,a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>,s1+<span class="number">1</span>,s2+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> la=<span class="built_in">change</span>(s1,a);</span><br><span class="line">    <span class="keyword">int</span> lb=<span class="built_in">change</span>(s2,b);</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">add</span>(a,b,ans,la,lb);    </span><br><span class="line">    <span class="built_in">print</span>(ans,len);</span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="8-树状数组"><a href="#8-树状数组" class="headerlink" title="8.树状数组"></a>8.树状数组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&amp;(-a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">2</span>,m=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ans[m+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> a[n+<span class="number">1</span>],c[n+<span class="number">1</span>],s[n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> o=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(c));</span><br><span class="line">    s[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        s[i]=s[i<span class="number">-1</span>]+a[i];</span><br><span class="line">        c[i]=s[i]-s[i-<span class="built_in">lowbit</span>(i)];<span class="comment">//树状数组创建前缀和优化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> q=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(q==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="keyword">int</span> x,y;</span><br><span class="line">           cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">           <span class="keyword">int</span> j=x;</span><br><span class="line">           <span class="keyword">while</span>(j&lt;=n)</span><br><span class="line">           &#123;</span><br><span class="line">               c[j]+=y;</span><br><span class="line">               j+=<span class="built_in">lowbit</span>(j);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x=<span class="number">1</span>,y=<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> s1=<span class="number">0</span>,s2=<span class="number">0</span>,p=x<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(p&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                s1+=c[p];</span><br><span class="line">                p-=<span class="built_in">lowbit</span>(p);</span><br><span class="line">            &#125;</span><br><span class="line">            p=y;</span><br><span class="line">            <span class="keyword">while</span>(p&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                s2+=c[p];</span><br><span class="line">                p-=<span class="built_in">lowbit</span>(p);</span><br><span class="line">            &#125;    </span><br><span class="line">            o++;</span><br><span class="line">            ans[o]=s2-s1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=o;i++)</span><br><span class="line">        cout&lt;&lt;ans[i]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-粗暴模拟人工运算"><a href="#9-粗暴模拟人工运算" class="headerlink" title="9.粗暴模拟人工运算"></a>9.粗暴模拟人工运算</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> fu=<span class="number">1</span>,f=<span class="number">1</span>,a,b,c=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="keyword">if</span>(a&lt;<span class="number">0</span>&amp;&amp;b&gt;<span class="number">0</span>)fu=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;<span class="number">0</span>&amp;&amp;b&lt;<span class="number">0</span>)fu=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span>(a&lt;<span class="number">0</span>&amp;&amp;b&lt;<span class="number">0</span>)f=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="number">0</span>)&#123;cout&lt;&lt;b;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)&#123;cout&lt;&lt;a;<span class="keyword">return</span> <span class="number">0</span>;&#125; </span><br><span class="line">    a=<span class="built_in">abs</span>(a);</span><br><span class="line">    b=<span class="built_in">abs</span>(b);</span><br><span class="line">    <span class="keyword">if</span>(a&gt;b&amp;&amp;fu==<span class="number">3</span>)f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(b&gt;a&amp;&amp;fu==<span class="number">3</span>)f=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(b&gt;a&amp;&amp;fu==<span class="number">2</span>)f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(b&lt;a&amp;&amp;fu==<span class="number">2</span>)f=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(fu==<span class="number">1</span>)c=a+b;</span><br><span class="line">    <span class="keyword">if</span>(fu&gt;<span class="number">1</span>)c=<span class="built_in">max</span>(a,b)-<span class="built_in">min</span>(a,b);</span><br><span class="line">    c*=f;</span><br><span class="line">    cout&lt;&lt;c;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-Dijkstra-STL的优先队列优化"><a href="#10-Dijkstra-STL的优先队列优化" class="headerlink" title="10.Dijkstra+STL的优先队列优化"></a>10.Dijkstra+STL的优先队列优化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">405</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,w;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edge[N*N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> dis[N*N];</span><br><span class="line"><span class="keyword">bool</span> vis[N*N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dis[a]&gt;dis[b];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;,cmp&gt; dijQue;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    dijQue.<span class="built_in">push</span>(start);</span><br><span class="line">    dis[start]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!dijQue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u=dijQue.<span class="built_in">top</span>();</span><br><span class="line">        dijQue.<span class="built_in">pop</span>();</span><br><span class="line">        vis[u]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(u==end)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;edge[u].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> v=edge[u][i].v;</span><br><span class="line">            <span class="keyword">if</span>(dis[v]==<span class="number">-1</span> || dis[v]&gt;dis[u]+edge[u][i].w) &#123;</span><br><span class="line">                dis[v]=dis[u]+edge[u][i].w;</span><br><span class="line">                <span class="keyword">if</span>(!vis[v]) &#123;</span><br><span class="line">                    vis[v]=<span class="literal">true</span>;</span><br><span class="line">                    dijQue.<span class="built_in">push</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[end];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">    Edge Qpush;</span><br><span class="line">    </span><br><span class="line">    Qpush.v=<span class="number">1</span>;</span><br><span class="line">    Qpush.w=a;</span><br><span class="line">    edge[<span class="number">0</span>].<span class="built_in">push_back</span>(Qpush);</span><br><span class="line">    </span><br><span class="line">    Qpush.v=<span class="number">2</span>;</span><br><span class="line">    Qpush.w=b;</span><br><span class="line">    edge[<span class="number">1</span>].<span class="built_in">push_back</span>(Qpush);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in">Dijkstra</span>(<span class="number">0</span>,<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-分治算法（二分法）"><a href="#11-分治算法（二分法）" class="headerlink" title="11.分治算法（二分法）"></a>11.分治算法（二分法）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a,b,c;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;<span class="keyword">long</span> <span class="keyword">long</span> l=-<span class="built_in"><span class="keyword">int</span></span>(<span class="number">1e9</span>)&lt;&lt;<span class="number">1</span>,r=<span class="built_in"><span class="keyword">int</span></span>(<span class="number">1e9</span>)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">     <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">     <span class="keyword">while</span>(r-l&gt;<span class="number">1</span>)&#123;c=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">         <span class="keyword">if</span>(c-b&lt;a)l=c;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span>(c-b&gt;a)r=c;</span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,c),<span class="number">0</span>;</span><br><span class="line">     &#125;<span class="keyword">if</span>(l!=r)<span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,r),<span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="12-位运算"><a href="#12-位运算" class="headerlink" title="12.位运算"></a>12.位运算</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> m, n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;m, &amp;n);</span><br><span class="line">    <span class="keyword">int</span> u = m &amp; n;</span><br><span class="line">    <span class="keyword">int</span> v = m ^ n;</span><br><span class="line">    <span class="keyword">while</span> (u) &#123;</span><br><span class="line">        <span class="keyword">int</span> s = v;</span><br><span class="line">        <span class="keyword">int</span> t = u &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        u = s &amp; t;</span><br><span class="line">        v = s ^ t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-线段树"><a href="#13-线段树" class="headerlink" title="13.线段树"></a>13.线段树</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val,l,r;</span><br><span class="line">&#125;;</span><br><span class="line">node t[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>],f[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> node)</span></span>&#123;</span><br><span class="line">    t[node].l=l;t[node].r=r;t[node].val=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        f[l]=node;</span><br><span class="line">        t[node].val=a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(l,mid,node*<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">build</span>(mid+<span class="number">1</span>,r,node*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">    t[node].val=t[node*<span class="number">2</span>].val+t[node*<span class="number">2</span>+<span class="number">1</span>].val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node==<span class="number">1</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> fa=node&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    t[fa].val=t[fa*<span class="number">2</span>].val+t[fa*<span class="number">2</span>+<span class="number">1</span>].val;</span><br><span class="line">    <span class="built_in">update</span>(fa);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[node].l==l&amp;&amp;t[node].r==r)&#123;</span><br><span class="line">        <span class="keyword">return</span> t[node].val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> lc=node*<span class="number">2</span>;<span class="keyword">int</span> rc=lc+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(t[lc].r&gt;=l)&#123;</span><br><span class="line">        <span class="keyword">if</span>(t[lc].r&gt;=r)&#123;</span><br><span class="line">            sum+=<span class="built_in">find</span>(l,r,lc);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            sum+=<span class="built_in">find</span>(l,t[lc].r,lc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t[rc].l&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(t[rc].l&lt;=l)&#123;</span><br><span class="line">            sum+=<span class="built_in">find</span>(l,r,rc);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            sum+=<span class="built_in">find</span>(t[rc].l,r,rc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in">find</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14-快读"><a href="#14-快读" class="headerlink" title="14.快读"></a>14.快读</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f=<span class="number">1</span>,x=<span class="number">0</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in">read</span>()+<span class="built_in">read</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-基础算法&quot;&gt;&lt;a href=&quot;#1-基础算法&quot; class=&quot;headerlink&quot; title=&quot;1.基础算法&quot;&gt;&lt;/a&gt;1.基础算法&lt;/h3&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutte</summary>
      
    
    
    
    <category term="编程算法" scheme="https://billma.top/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="computer,cpp" scheme="https://billma.top/tags/computer-cpp/"/>
    
  </entry>
  
  <entry>
    <title>C++中fstream的用法</title>
    <link href="https://billma.top/2021/08/04/cpp-fstream/"/>
    <id>https://billma.top/2021/08/04/cpp-fstream/</id>
    <published>2021-08-04T06:48:06.000Z</published>
    <updated>2021-09-04T13:03:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面：啥是fstream"><a href="#写在前面：啥是fstream" class="headerlink" title="写在前面：啥是fstream"></a>写在前面：啥是fstream</h2><p>ofstream是从内存到硬盘，ifstream是从硬盘到内存，其实所谓的流缓冲就是内存空间;</p><p>在C++中，有一个stream这个类，所有的I/O都以这个“流”类为基础的，包括我们要认识的文件I/O，stream这个类有两个重要的运算符：</p><h3 id="1、插入器-lt-lt-向流输出数据"><a href="#1、插入器-lt-lt-向流输出数据" class="headerlink" title="1、插入器(&lt;&lt;) 向流输出数据"></a>1、插入器(&lt;&lt;) 向流输出数据</h3><p>比如说系统有一个默认的标准输出流(cout)，一般情况下就是指的显示器，所以，cout&lt;&lt;“Write Stdout”&lt;&lt;’\n’;就表示把字符串”Write Stdout”和换行字符(‘\n’)输出到标准输出流。</p><h3 id="2、析取器-gt-gt-从流中输入数据"><a href="#2、析取器-gt-gt-从流中输入数据" class="headerlink" title="2、析取器(&gt;&gt;) 从流中输入数据"></a>2、析取器(&gt;&gt;) 从流中输入数据</h3><p>比如说系统有一个默认的标准输入流(cin)，一般情况下就是指的键盘，所以，cin&gt;&gt;x;就表示从标准输入流中读取一个指定类型(即变量x的类型)的数据。</p><p>在C++中，对文件的操作是通过stream的子类fstream(file stream)来实现的，所以，要用这种方式操作文件，就必须加入头文件fstream.h。下面就把此类的文件操作过程一一道来。</p><h2 id="一、打开文件"><a href="#一、打开文件" class="headerlink" title="一、打开文件"></a>一、打开文件</h2><p>在fstream类中，有一个成员函数open()，就是用来打开文件的，其原型是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* filename,<span class="keyword">int</span> mode,<span class="keyword">int</span> access)</span></span>;</span><br></pre></td></tr></table></figure><p>参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">filename：　　要打开的文件名</span><br><span class="line">mode：　　　　要打开文件的方式</span><br><span class="line">access：　　　打开文件的属性</span><br><span class="line"></span><br><span class="line">打开文件的方式在类<span class="built_in">ios</span>(是所有流式I/O类的基类)中定义，常用的值如下：</span><br><span class="line">ios::app：　　　以追加的方式打开文件</span><br><span class="line">ios::ate：　　　文件打开后定位到文件尾，ios:app就包含有此属性</span><br><span class="line">ios::binary：　以二进制方式打开文件，缺省的方式是文本方式。两种方式的区别见前文</span><br><span class="line">ios::in：　　　 文件以输入方式打开（文件数据输入到内存）</span><br><span class="line">ios::out：　　　文件以输出方式打开（内存数据输出到文件）</span><br><span class="line">ios::nocreate： 不建立文件，所以文件不存在时打开失败</span><br><span class="line">ios::noreplace：不覆盖文件，所以打开文件时如果文件存在失败</span><br><span class="line">ios::trunc：　　如果文件存在，把文件长度设为<span class="number">0</span> 可以用“或”把以上属性连接起来，如ios::out|ios::binary</span><br></pre></td></tr></table></figure><p>打开文件的属性取值是：</p><p>0：普通文件，打开访问</p><p>1：只读文件</p><p>2：隐含文件</p><p>4：系统文件</p><p>可以用“或”或者“+”把以上属性连接起来，如3或1|2就是以只读和隐含属性打开文件。</p><p>例如：以二进制输入方式打开文件c:\config.sys</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fstream file1; file1.<span class="built_in">open</span>(“c:\config.sys”,ios::binary|ios::in,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>如果open函数只有文件名一个参数，则是以读/写普通文件打开，即：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file1.<span class="built_in">open</span>(“c:\config.sys”);</span><br><span class="line"><span class="comment">/*等价于*/</span></span><br><span class="line">file1.<span class="built_in">open</span>(“c:\config.sys”,ios::in|ios::out,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>另外，fstream还有和<code>open()</code>一样的构造函数，对于上例，在定义的时侯就可以打开文件了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fstream <span class="title">file1</span><span class="params">(“c:\config.sys”)</span></span>;</span><br></pre></td></tr></table></figure><p>特别提出的是，fstream有两个子类：<code>ifstream(input file stream)</code>和<code>ofstream(outpu file stream)</code>，ifstream默认以输入方式打开文件，而ofstream默认以输出方式打开文件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">file2</span><span class="params">(“c:\pdos.def”)</span></span>;<span class="comment">//以输入方式打开文件 </span></span><br><span class="line"><span class="function">ofstream <span class="title">file3</span><span class="params">(“c:\x<span class="number">.123</span>”)</span></span>;<span class="comment">//以输出方式打开文件</span></span><br></pre></td></tr></table></figure><p>所以，在实际应用中，根据需要的不同，选择不同的类来定义：如果想以输入方式打开，就用ifstream来定义；如果想以输出方式打开，就用ofstream来定义；如果想以输入/输出方式来打开，就用fstream来定义。</p><h2 id="二、关闭文件"><a href="#二、关闭文件" class="headerlink" title="二、关闭文件"></a>二、关闭文件</h2><p>打开的文件使用完成后一定要关闭，fstream提供了成员函数<code>close()</code>来完成此操作，如：<code>file1.close();</code>就把file1相连的文件关闭。</p><h2 id="三、读写文件"><a href="#三、读写文件" class="headerlink" title="三、读写文件"></a>三、读写文件</h2><p> 读写文件分为文本文件和二进制文件的读取，对于文本文件的读取比较简单，用插入器和析取器就可以了；而对于二进制的读取就要复杂些，下要就详细的介绍这两种方式</p><h3 id="1、文本文件的读写"><a href="#1、文本文件的读写" class="headerlink" title="1、文本文件的读写"></a>1、文本文件的读写</h3><p> 文本文件的读写很简单：用插入器(&lt;&lt;)向文件输出；用析取器(&gt;&gt;)从文件输入。假设file1是以输入方式打开，file2以输出打开。示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file2&lt;&lt;“I Love You”;<span class="comment">//向文件写入字符串&quot;I Love You&quot; </span></span><br><span class="line"><span class="keyword">int</span> i; file1&gt;&gt;i;<span class="comment">//从文件输入一个整数值。</span></span><br></pre></td></tr></table></figure><p>这种方式还有一种简单的格式化能力，比如可以指定输出为16进制等等，具体的格式有以下一些</p><p>操纵符 功能 输入/输出 dec 格式化为十进制数值数据 输入和输出 endl 输出一个换行符并刷新此流 输出 ends 输出一个空字符 输出 hex 格式化为十六进制数值数据 输入和输出 oct 格式化为八进制数值数据 输入和输出 setpxecision(int p) 设置浮点数的精度位数 输出</p><p>比如要把123当作十六进制输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file1&lt;&lt;hex&lt;&lt;<span class="number">123</span>;</span><br></pre></td></tr></table></figure><p>要把3.1415926以5位精度输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file1&lt;&lt;<span class="built_in">setpxecision</span>(<span class="number">5</span>)&lt;&lt;<span class="number">3.1415926</span>。</span><br></pre></td></tr></table></figure><h3 id="2、二进制文件的读写"><a href="#2、二进制文件的读写" class="headerlink" title="2、二进制文件的读写"></a>2、二进制文件的读写</h3><h4 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h4><p>put()函数向流写入一个字符，其原型是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ofstream &amp;<span class="title">put</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br></pre></td></tr></table></figure><p>使用也比较简单，如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file1.<span class="built_in">put</span>(‘c’);</span><br></pre></td></tr></table></figure><p>就是向流写一个字符’c’。</p><h4 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h4><p>get()函数比较灵活，有3种常用的重载形式：</p><p>一种就是和put()对应的形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream &amp;<span class="title">get</span><span class="params">(<span class="keyword">char</span> &amp;ch)</span></span>;</span><br></pre></td></tr></table></figure><p>功能是从流中读取一个字符，结果保存在引用ch中，如果到文件尾，返回空字符。如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file2.<span class="built_in">get</span>(x);</span><br></pre></td></tr></table></figure><p>表示从文件中读取一个字符，并把读取的字符保存在x中。</p><p>另一种重载形式的原型是：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>这种形式是从流中返回一个字符，如果到达文件尾，返回EOF，如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x=file2.<span class="built_in">get</span>();</span><br></pre></td></tr></table></figure><p>和上例功能是一样的。</p><p>还有一种形式的原型是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream &amp;<span class="title">get</span><span class="params">(<span class="keyword">char</span> *buf,<span class="keyword">int</span> num,<span class="keyword">char</span> delim=<span class="string">&#x27;\n&#x27;</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>这种形式把字符读入由 buf 指向的数组，直到读入了 num 个字符或遇到了由 delim 指定的字符，如果没使用 delim 这个参数，将使用缺省值换行符’\n’。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file2.<span class="built_in">get</span>(str1,<span class="number">127</span>,‘A’); <span class="comment">//从文件中读取字符到字符串str1，当遇到字符’A’或读取了127个字符时终止。</span></span><br></pre></td></tr></table></figure><h4 id="读写数据块"><a href="#读写数据块" class="headerlink" title="读写数据块"></a>读写数据块</h4><p>要读写二进制数据块，使用成员函数<code>read()</code>和<code>write()</code>成员函数，它们原型如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span>(<span class="keyword">unsigned</span> <span class="keyword">char</span> *buf,<span class="keyword">int</span> num); <span class="built_in">write</span>(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>*buf,<span class="keyword">int</span> num);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>num 个字符到 buf 指向的缓存中，如果在还未读入 num 个字符时就到了文件尾，可以用成员函数 int gcount();来取得实际读取的字符数；而``` write() ```从buf 指向的缓存写 num 个字符到文件中，值得注意的是缓存的类型是 ```unsigned char *```，有时可能需要类型转换。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">例：</span><br><span class="line"></span><br><span class="line">```C++</span><br><span class="line">unsigned char str1[]=“I Love You”;</span><br><span class="line">int n[5];</span><br><span class="line">ifstream in(“xxx.xxx”); </span><br><span class="line">ofstream out(“yyy.yyy”);</span><br><span class="line">out.write(str1,strlen(str1));//把字符串str1全部写到yyy.yyy中 </span><br><span class="line">in.read((unsigned char*)n,sizeof(n));//从xxx.xxx中读取指定个整数，注意类型转换 </span><br><span class="line">in.close();</span><br><span class="line">out.close();</span><br></pre></td></tr></table></figure><h2 id="四、检测EOF"><a href="#四、检测EOF" class="headerlink" title="四、检测EOF"></a>四、检测EOF</h2><p>成员函数eof()用来检测是否到达文件尾，如果到达文件尾返回非0值，否则返回0。原型是int eof();</p><p>例：　　</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(in.<span class="built_in">eof</span>()) <span class="built_in">ShowMessage</span>(<span class="string">&quot;已经到达文件尾！&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="五、文件定位"><a href="#五、文件定位" class="headerlink" title="五、文件定位"></a>五、文件定位</h2><p>和C的文件操作方式不同的是，C++ I/O系统管理两个与一个文件相联系的指针。一个是读指针，它说明输入操作在文件中的位置；另一个是写指针，它下次写操作的位置。每次执行输入或输出时，相应的指针自动变化。所以，C++的文件定位分为读位置和写位置的定位，对应的成员函数是seekg()和seekp()。seekg()是设置读位置， seekp是设置写位置。它们最通用的形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream &amp;<span class="title">seekg</span><span class="params">(streamoff offset,seek_dir origin)</span></span>; <span class="function">ostream &amp;<span class="title">seekp</span><span class="params">(streamoff offset,seek_dir origin)</span></span>;</span><br></pre></td></tr></table></figure><p>streamoff定义于 iostream.h 中，定义有偏移量 offset 所能取得的最大值，seek_dir 表示移动的基准位置，是一个有以下值的枚举：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ios::beg　　<span class="comment">//文件开头</span></span><br><span class="line">ios::cur　　<span class="comment">//文件当前位置 </span></span><br><span class="line">ios::end　　<span class="comment">//文件结尾</span></span><br></pre></td></tr></table></figure><p>这两个函数一般用于二进制文件，因为文本文件会因为系统对字符的解释而可能与预想的值不同。例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file1.<span class="built_in">seekg</span>(<span class="number">1234</span>,ios::cur); <span class="comment">//把文件的读指针从当前位置向后移1234个字节 file2.seekp(1234,ios::beg); //把文件的写指针从文件开头向后移1234个字节</span></span><br></pre></td></tr></table></figure><h2 id="六-fstream的用法"><a href="#六-fstream的用法" class="headerlink" title="六.fstream的用法"></a>六.fstream的用法</h2><h3 id="开一个文件"><a href="#开一个文件" class="headerlink" title="开一个文件"></a>开一个文件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fstream f; </span><br><span class="line">f.<span class="built_in">open</span>(“<span class="number">1.</span>txt”, ios::in | ios::binary); </span><br><span class="line"><span class="keyword">if</span> (!f.<span class="built_in">is_open</span>()) <span class="comment">// 检查文件是否成功打开 </span></span><br><span class="line">cout &lt;&lt; “cannot open file.” &lt;&lt; endl; </span><br></pre></td></tr></table></figure><p>ios::in与ios::bianry均为int型，定义文件打开的方式。<br>ios::in – 打开文件用于读。<br>ios::out – 打开文件用于写，如果文件不存在，则新建一个；存在则清空其内容。<br>ios::binary – 以二进制bit流方式进行读写，默认是ios::text，但最好指定这种读写方式，即使要读写的是文本。因为在ios::text模式下，在写入时’\ n’字符将转换成两个字符：回车+换行（HEX: 0D 0A) 写入，读入时作逆转换，这容易引起不必要的麻烦。<br>ios::app – 打开文件在文件尾进行写入，即使使用了seekp改变了写入位置，仍将在文件尾写入。<br>ios::ate – 打开文件在文件尾进行写入，但seekp有效。</p><h3 id="读写位置的改变"><a href="#读写位置的改变" class="headerlink" title="读写位置的改变"></a>读写位置的改变</h3><p>f.seekg(0, ios::beg); // 改变读入位置<br>g mean Get f.seekp(0, ios::end); // 改变写入位置 p mean Put 第一个参数是偏移量offset(long)，第二个参数是offset相对的位置，三个值： ios::beg – 文件头 ios::end – 文件尾 ios::cur – 当前位置</p><h3 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s[<span class="number">50</span>]; f.<span class="built_in">read</span>(s, <span class="number">49</span>); s[<span class="number">50</span>] = ‘\<span class="number">0</span>’; <span class="comment">// 注意要自己加上字符串结束符</span></span><br><span class="line"><span class="keyword">char</span> *s = “hello”; f.<span class="built_in">write</span>(s, <span class="built_in">strlen</span>(s));</span><br></pre></td></tr></table></figure><h2 id="七、补充"><a href="#七、补充" class="headerlink" title="七、补充"></a>七、补充</h2><p>记得读写完成后用f.close()关闭文件。</p><p>例子 下面的程序用于删除带有行号的源程序中的行号。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义要删除的行号格式，下面定义的是型如: #0001 的行号</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> LINE_NUM_LENGTH = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> LINE_NUM_START = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fstream f;</span><br><span class="line">    <span class="keyword">char</span> *s = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; argc; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Processing file &quot;</span> &lt;&lt; argv[i] &lt;&lt; <span class="string">&quot;......&quot;</span>;</span><br><span class="line">        f.<span class="built_in">open</span>(argv[i], ios::in | ios::binary);</span><br><span class="line">        <span class="keyword">if</span> (!f.<span class="built_in">is_open</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;CANNOT OPEN&quot;</span>&lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        f.<span class="built_in">seekg</span>(<span class="number">0</span>, ios::end);</span><br><span class="line">        n = f.<span class="built_in">tellg</span>(); <span class="comment">// 文件大小</span></span><br><span class="line">        s = <span class="keyword">new</span> <span class="keyword">char</span>[n+<span class="number">1</span>];</span><br><span class="line">        f.<span class="built_in">seekg</span>(<span class="number">0</span>, ios::beg);</span><br><span class="line">        f.<span class="built_in">read</span>(s, n);</span><br><span class="line">        s[n] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        f.<span class="built_in">close</span>();</span><br><span class="line">        <span class="comment">// 采用一种简单的判断，遇到LINE_NUM_START后接一个数字，</span></span><br><span class="line">        <span class="comment">// 则认为它是一个行号.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[j] == LINE_NUM_START &amp;&amp;</span><br><span class="line">            (s[j+<span class="number">1</span>] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[j+<span class="number">1</span>] &lt;= <span class="string">&#x27;9&#x27;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt; j + LINE_NUM_LENGTH; k++)</span><br><span class="line">                    s[k] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        f.<span class="built_in">open</span>(argv[i], ios::out | ios::binary);</span><br><span class="line">        <span class="keyword">if</span> (!f.<span class="built_in">is_open</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;CANNOT OPEN&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">delete</span>[] s;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        f.<span class="built_in">write</span>(s, n);</span><br><span class="line">        f.<span class="built_in">close</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;OK&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span>[] s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;写在前面：啥是fstream&quot;&gt;&lt;a href=&quot;#写在前面：啥是fstream&quot; class=&quot;headerlink&quot; title=&quot;写在前面：啥是fstream&quot;&gt;&lt;/a&gt;写在前面：啥是fstream&lt;/h2&gt;&lt;p&gt;ofstream是从内存到硬盘，ifstre</summary>
      
    
    
    
    <category term="编程算法" scheme="https://billma.top/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>C++ 中string用法详解</title>
    <link href="https://billma.top/2021/08/01/cpp-string/"/>
    <id>https://billma.top/2021/08/01/cpp-string/</id>
    <published>2021-07-31T23:26:08.000Z</published>
    <updated>2021-09-04T13:03:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>本文根据 CC BY-NC-SA 4.0 许可协议参考Nicolai M.Josuttis的文章并进行小部分转载</em></p><hr><p>C++ 语言是个十分优秀的语言，但优秀并不表示完美。还是有许多人不愿意使用C或者C++，为什么？原因众多，其中之一就是C/C++的文本处理功能太麻烦，用起来很不方便。</p><p>举例来说，如果文本格式是：用户名 电话号码，文件名name.txt</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Tom <span class="number">23245332</span> </span><br><span class="line">Jenny <span class="number">22231231</span> </span><br><span class="line">Heny <span class="number">22183942</span> </span><br><span class="line">Tom <span class="number">23245332</span> </span><br><span class="line">…</span><br></pre></td></tr></table></figure><p>现在我们需要对用户名排序，且只输出不同的姓名。</p><p>那么在shell 编程中，可以这样用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;&#123;print $1&#125;&#x27; name.txt | sort | uniq</span><br></pre></td></tr></table></figure><p>如果使用C/C++ 就麻烦了，他需要做以下工作： 先打开文件，检测文件是否打开，如果失败，则退出。 声明一个足够大得二维字符数组或者一个字符指针数组 读入一行到字符空间 然后分析一行的结构，找到空格，存入字符数组中。 关闭文件 写一个排序函数，或者使用写一个比较函数，使用sort()排序 遍历数组，比较是否有相同的，如果有，则要删除，copy… 输出信息</p><p>你可以用C++或者C语言去实现这个流程。如果一个人的主要工作就是处理这种类似的文本(例如做apache的日志统计和分析),你说他会喜欢C/C++么？</p><p>当然，有了STL，这些处理会得到很大的简化。我们可以使用 fstream来代替麻烦的fopen fread fclose, 用vector来代替数组。最重要的是用 string来代替char * 数组，使用sort排序算法来排序，用unique 函数来去重。听起来好像很不错。看看下面代码(例程1）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">&quot;name.txt&quot;</span>)</span></span>;</span><br><span class="line">    string strtmp;</span><br><span class="line">    vector&lt;string&gt; vect;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">getline</span>(in, strtmp, <span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line">    vect.<span class="built_in">push_back</span>(strtmp.<span class="built_in">substr</span>(<span class="number">0</span>, strtmp.<span class="built_in">find</span>(<span class="string">&#x27; &#x27;</span>)));</span><br><span class="line">    <span class="built_in">sort</span>(vect.<span class="built_in">begin</span>(), vect.<span class="built_in">end</span>());</span><br><span class="line">    vector&lt;string&gt;::iterator it=<span class="built_in">unique</span>(vect.<span class="built_in">begin</span>(), vect.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">copy</span>(vect.<span class="built_in">begin</span>(), it, ostream_iterator&lt;string&gt;(cout, <span class="string">&quot;\n&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也还不错吧，至少会比想象得要简单得多！（代码里面没有对错误进行处理，只是为了说明问题，不要效仿).</p><p>当然，在这个文本格式中，不用vector而使用map会更有扩充性，例如，还可通过人名找电话号码等等，但是使用了map就不那么好用sort了。你可以用map试一试。</p><p>这里string的作用不只是可以存储字符串，还可以提供字符串的比较，查找等。在sort和unique函数中就默认使用了less 和equal_to函数, 上面的一段代码，其实使用了string的以下功能： 存储功能，在getline() 函数中 查找功能，在find() 函数中 子串功能，在substr() 函数中 string operator &lt; , 默认在sort() 函数中调用 string operator == , 默认在unique() 函数中调用</p><p>总之，有了string 后，C++的字符文本处理功能总算得到了一定补充，加上配合STL其他容器使用，其在文本处理上的功能已经与perl, shell, php的距离缩小很多了。 因此掌握string 会让你的工作事半功倍。</p><h3 id="1-string使用"><a href="#1-string使用" class="headerlink" title="1.string使用"></a>1.string使用</h3><p>其实，string并不是一个单独的容器，只是basic_string 模板类的一个typedef 而已，相对应的还有wstring, 你在string 头文件中你会发现下面的代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C++&quot;</span> &#123;</span><br><span class="line"><span class="keyword">typedef</span> basic_string &lt;<span class="keyword">char</span>&gt; string;</span><br><span class="line"><span class="keyword">typedef</span> basic_string &lt;<span class="keyword">wchar_t</span>&gt; wstring;</span><br><span class="line">&#125; <span class="comment">// extern &quot;C++&quot;</span></span><br></pre></td></tr></table></figure><p>由于只是解释string的用法，如果没有特殊的说明，本文并不区分string 和 basic_string的区别。</p><p>string 其实相当于一个保存字符的序列容器，因此除了有字符串的一些常用操作以外，还有包含了所有的序列容器的操作。字符串的常用操作包括：增加、删除、修改、查找比较、链接、输入、输出等。详细函数列表参看附录。不要害怕这么多函数，其实有许多是序列容器带有的，平时不一定用的上。</p><p>如果你要想了解所有函数的详细用法，你需要查看basic_string，或者下载STL编程手册。这里通过实例介绍一些常用函数。</p><h4 id="1-1-充分使用string-操作符"><a href="#1-1-充分使用string-操作符" class="headerlink" title="1.1 充分使用string 操作符"></a>1.1 充分使用string 操作符</h4><p>string 重载了许多操作符，包括 +, +=, &lt;, =, , [], «, »等，正式这些操作符，对字符串操作非常方便。先看看下面这个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string strinfo=<span class="string">&quot;Please input your name:&quot;</span>;</span><br><span class="line">    cout &lt;&lt; strinfo ;</span><br><span class="line">    cin &gt;&gt; strinfo;</span><br><span class="line">    <span class="keyword">if</span>( strinfo == <span class="string">&quot;winter&quot;</span> )</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;you are winter!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( strinfo != <span class="string">&quot;wende&quot;</span> )</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;you are not wende!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( strinfo &lt; <span class="string">&quot;winter&quot;</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;your name should be ahead of winter&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;your name should be after of winter&quot;</span>&lt;&lt;endl;</span><br><span class="line">    strinfo += <span class="string">&quot; , Welcome to China!&quot;</span>;</span><br><span class="line">    cout &lt;&lt; strinfo&lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;Your name is :&quot;</span>&lt;&lt;endl;</span><br><span class="line">    string strtmp = <span class="string">&quot;How are you? &quot;</span> + strinfo;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; strtmp.<span class="built_in">size</span>(); i ++)</span><br><span class="line">        cout&lt;&lt;strtmp[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*下面是程序的输出</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Please input your name:Hero</span></span><br><span class="line"><span class="comment">you are not wende!</span></span><br><span class="line"><span class="comment">Hero , Welcome to China!</span></span><br><span class="line"><span class="comment">How are you? Hero , Welcome to China!</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>有了这些操作符，在STL中仿函数都可以直接使用string作为参数，例如 less, great, equal_to 等，因此在把string作为参数传递的时候，它的使用和int 或者float等已经没有什么区别了。例如，你可以使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="keyword">int</span>&gt; mymap; <span class="comment">//以上默认使用了 less&lt;string&gt;</span></span><br></pre></td></tr></table></figure><p>有了 operator + 以后，你可以直接连加，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string strinfo=<span class="string">&quot;Winter&quot;</span>;</span><br><span class="line">string strlast=<span class="string">&quot;Hello &quot;</span> + strinfo + <span class="string">&quot;!&quot;</span>;</span><br><span class="line">string strtest=<span class="string">&quot;Hello &quot;</span> + strinfo + <span class="string">&quot; Welcome&quot;</span> + <span class="string">&quot; to China&quot;</span> + <span class="string">&quot; !&quot;</span>;</span><br></pre></td></tr></table></figure><p>看见其中的特点了吗？只要你的等式里面有一个 string 对象，你就可以一直连续”+”，但有一点需要保证的是，在开始的两项中，必须有一项是 string 对象。其原理很简单：</p><p>系统遇到”+“号，发现有一项是string 对象。 系统把另一项转化为一个临时 string 对象。 执行 operator + 操作，返回新的临时string 对象。 如果又发现”+“号，继续第一步操作。</p><p>由于这个等式是由左到右开始检测执行，如果开始两项都是const char<em>，程序自己并没有定义两个const char</em> 的加法，编译的时候肯定就有问题了。</p><p>有了操作符以后，assign(), append(), compare(), at()等函数，除非有一些特殊的需求时，一般是用不上。当然at()函数还有一个功能，那就是检查下标是否合法，如果是使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string str=<span class="string">&quot;winter&quot;</span>;<span class="comment">//下面一行有可能会引起程序中断错误</span></span><br><span class="line">str[<span class="number">100</span>]=<span class="string">&#x27;!&#x27;</span>;<span class="comment">//下面会抛出异常:throws: out_of_range</span></span><br><span class="line">cout&lt;&lt;str.<span class="built_in">at</span>(<span class="number">100</span>)&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>了解了吗？如果你希望效率高，还是使用[]来访问，如果你希望稳定性好，最好使用at()来访问。</p><h4 id="1-2-眼花缭乱的string-find-函数"><a href="#1-2-眼花缭乱的string-find-函数" class="headerlink" title="1.2 眼花缭乱的string find 函数"></a>1.2 眼花缭乱的string find 函数</h4><p>由于查找是使用最为频繁的功能之一，string 提供了非常丰富的查找函数。其列表如下： 函数名 描述 find 查找 rfind 反向查找 find_first_of 查找包含子串中的任何字符，返回第一个位置 find_first_not_of 查找不包含子串中的任何字符，返回第一个位置 find_last_of 查找包含子串中的任何字符，返回最后一个位置 find_last_not_of 查找不包含子串中的任何字符，返回最后一个位置以上函数都是被重载了4次，以下是以find_first_of 函数为例说明他们的参数，其他函数和其参数一样，也就是说总共有24个函数 ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">size_type <span class="title">find_first_of</span><span class="params">(<span class="keyword">const</span> basic_string&amp; s, size_type pos = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">size_type <span class="title">find_first_of</span><span class="params">(<span class="keyword">const</span> charT* s, size_type pos, size_type n)</span></span></span><br><span class="line"><span class="function">size_type <span class="title">find_first_of</span><span class="params">(<span class="keyword">const</span> charT* s, size_type pos = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">size_type <span class="title">find_first_of</span><span class="params">(charT c, size_type pos = <span class="number">0</span>)</span></span></span><br></pre></td></tr></table></figure><p>所有的查找函数都返回一个size_type类型，这个返回值一般都是所找到字符串的位置，如果没有找到，则返回string::npos。有一点需要特别注意，所有和string::npos的比较一定要用string::size_type来使用，不要直接使用int 或者unsigned int等类型。其实string::npos表示的是-1, 看看头文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">CharT</span>, <span class="keyword">class</span> _<span class="title">Traits</span>, <span class="keyword">class</span> _<span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">const</span> basic_string&lt;_CharT,_Traits,_Alloc&gt;::size_type</span><br><span class="line">basic_string&lt;_CharT,_Traits,_Alloc&gt;::npos</span><br><span class="line">= basic_string&lt;_CharT,_Traits,_Alloc&gt;::size_type) <span class="number">-1</span>;</span><br></pre></td></tr></table></figure><p>find 和 rfind 都还比较容易理解，一个是正向匹配，一个是逆向匹配，后面的参数pos都是用来指定起始查找位置。对于find_first_of 和find_last_of 就不是那么好理解。</p><p>find_first_of 是给定一个要查找的字符集，找到这个字符集中任何一个字符所在字符串中第一个位置。或许看一个例子更容易明白。</p><p>有这样一个需求：过滤一行开头和结尾的所有非英文字符。看看用string 如何实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string strinfo=<span class="string">&quot; //*---Hello Word!......------&quot;</span>;</span><br><span class="line">    string strset=<span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> first = strinfo.<span class="built_in">find_first_of</span>(strset);</span><br><span class="line">     <span class="keyword">if</span>(first == string::npos)</span><br><span class="line">     &#123;</span><br><span class="line">      cout&lt;&lt;<span class="string">&quot;not find any characters&quot;</span>&lt;&lt;endl;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">int</span> last = strinfo.<span class="built_in">find_last_of</span>(strset);</span><br><span class="line">     <span class="keyword">if</span>(last == string::npos)</span><br><span class="line">     &#123;</span><br><span class="line">      cout&lt;&lt;<span class="string">&quot;not find any characters&quot;</span>&lt;&lt;endl;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     cout &lt;&lt; strinfo.<span class="built_in">substr</span>(first, last - first + <span class="number">1</span>)&lt;&lt;endl;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里把所有的英文字母大小写作为了需要查找的字符集，先查找第一个英文字母的位置，然后查找最后一个英文字母的位置，然后用substr 来的到中间的一部分，用于输出结果。下面就是其结果：<code>Hello Word</code><br>前面的符号和后面的符号都没有了。像这种用法可以用来查找分隔符，从而把一个连续的字符串分割成为几部分，达到 shell 命令中的 awk 的用法。特别是当分隔符有多个的时候，可以一次指定。例如有这样的需求：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">张三|3456123, 湖南</span><br><span class="line">李四,4564234| 湖北</span><br><span class="line">王小二, 4433253|北京</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>我们需要以 “|” “,“为分隔符，同时又要过滤空格，把每行分成相应的字段。</p><p>1.3 string insert, replace, erase</p><p>了解了string 的操作符，查找函数和substr，其实就已经了解了string的80%的操作了。insert函数, replace函数和erase函数在使用起来相对简单。下面以一个例子来说明其应用。 string只是提供了按照位置和区间的replace函数，而不能用一个string字串来替换指定string中的另一个字串。这里写一个函数来实现这个功能：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">string_replace</span><span class="params">(string &amp; strBig, <span class="keyword">const</span> string &amp; strsrc, <span class="keyword">const</span> string &amp;strdst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     string::size_type pos=<span class="number">0</span>;</span><br><span class="line">    string::size_type srclen=strsrc.<span class="built_in">size</span>();</span><br><span class="line">    string::size_type dstlen=strdst.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span>( (pos=strBig.<span class="built_in">find</span>(strsrc, pos)) != string::npos)</span><br><span class="line">     &#123;</span><br><span class="line">      strBig.<span class="built_in">replace</span>(pos, srclen, strdst);</span><br><span class="line">      pos += dstlen;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看如何调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     string strinfo=<span class="string">&quot;This is Winter, Winter is a programmer. Do you know Winter?&quot;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Orign string is :\n&quot;</span>&lt;&lt;strinfo&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">string_replace</span>(strinfo, <span class="string">&quot;Winter&quot;</span>, <span class="string">&quot;wende&quot;</span>);</span><br><span class="line">     cout&lt;&lt;<span class="string">&quot;After replace Winter with wende, the string is :\n&quot;</span>&lt;&lt;strinfo&lt;&lt;endl;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Orign string is :</span><br><span class="line">This is Winter, Winter is a programmer. Do you know Winter?</span><br><span class="line">After replace Winter with wende, the string is :</span><br><span class="line">This is wende, wende is a programmer. Do you know wende?</span><br></pre></td></tr></table></figure><p>如果不用replace函数，则可以使用erase和insert来替换，也能实现string_replace函数的功能：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">string_replace</span><span class="params">(string &amp; strBig, <span class="keyword">const</span> string &amp; strsrc, <span class="keyword">const</span> string &amp;strdst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     string::size_type pos=<span class="number">0</span>;</span><br><span class="line">     string::size_type srclen=strsrc.<span class="built_in">size</span>();</span><br><span class="line">    string::size_type dstlen=strdst.<span class="built_in">size</span>();</span><br><span class="line">     <span class="keyword">while</span>( (pos=strBig.<span class="built_in">find</span>(strsrc, pos)) != string::npos)</span><br><span class="line">    &#123;</span><br><span class="line">     strBig.<span class="built_in">erase</span>(pos, srclen);</span><br><span class="line">     strBig.<span class="built_in">insert</span>(pos, strdst);</span><br><span class="line">     pos += dstlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，这种方法没有使用replace来得直接.</p><h3 id="2-string-和C-style字符串"><a href="#2-string-和C-style字符串" class="headerlink" title="2 string 和C-style字符串"></a>2 string 和C-style字符串</h3><p>现在看了这么多例子，发现const char* 可以和string 直接转换，例如我们在上面的例子中，使用</p><p><code>string_replace(strinfo, &quot;Winter&quot;, &quot;wende&quot;);</code>来代用<code>void</code></p><p><code>string_replace(string &amp; strBig, const string &amp; strsrc, const string &amp;strdst)</code><br>在C语言中只有<code>char*</code> 和 <code>const char*</code>，为了使用起来方便，string提供了三个函数满足其要求：</p><p>const charT<em>c_str() const<br>const charT</em> data() const<br>size_type copy(charT* buf, size_type n, size_type pos = 0) const<br>其中： c_str 直接返回一个以\0结尾的字符串。 data 直接以数组方式返回string的内容，其大小为size()的返回值，结尾并没有\0字符。 copy 把string的内容拷贝到buf空间中。 你或许会问，c_str()的功能包含data()，那还需要data()函数干什么？看看源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> charT* <span class="title">c_str</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="built_in">length</span> () == <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="built_in">terminate</span> ();</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">data</span> ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来c_str()的流程是：先调用terminate()，然后在返回data()。因此如果你对效率要求比较高，而且你的处理又不一定需要以\0的方式结束，你最好选择data()。但是对于一般的C函数中，需要以const char*为输入参数，你就要使用c_str()函数。</p><p>对于c_str() data()函数，返回的数组都是由string本身拥有，千万不可修改其内容。其原因是许多string实现的时候采用了引用机制，也就是说，有可能几个string使用同一个字符存储空间。而且你不能使用sizeof(string)来查看其大小。详细的解释和实现查看Effective STL的条款15：小心string实现的多样性。</p><p>另外在你的程序中，只在需要时才使用c_str()或者data()得到字符串，每调用一次，下次再使用就会失效，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">string <span class="title">strinfo</span><span class="params">(<span class="string">&quot;this is Winter&quot;</span>)</span></span>;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//最好的方式是:</span></span><br><span class="line"><span class="built_in">foo</span>(strinfo.<span class="built_in">c_str</span>());</span><br><span class="line"><span class="comment">//也可以这么用:</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* pstr=strinfo.<span class="built_in">c_str</span>();</span><br><span class="line"><span class="built_in">foo</span>(pstr);</span><br><span class="line"><span class="comment">//不要再使用了pstr了, 下面的操作已经使pstr无效了。</span></span><br><span class="line">strinfo += <span class="string">&quot; Hello!&quot;</span>;</span><br><span class="line"><span class="built_in">foo</span>(pstr);<span class="comment">//错误！</span></span><br></pre></td></tr></table></figure><p>会遇到什么错误？当你幸运的时候pstr可能只是指向<code>&quot;this is Winter Hello!“</code>的字符串，如果不幸运，就会导致程序出现其他问题，总会有一些不可遇见的错误。总之不会是你预期的那个结果。</p><h3 id="3-string-和-Charactor-Traits-了解了string的用法，该详细看看string的真相了"><a href="#3-string-和-Charactor-Traits-了解了string的用法，该详细看看string的真相了" class="headerlink" title="3 string 和 Charactor Traits 了解了string的用法，该详细看看string的真相了"></a>3 string 和 Charactor Traits 了解了string的用法，该详细看看string的真相了</h3><p>前面提到string 只是basic_string的一个typedef。看看basic_string 的参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">charT</span>, <span class="keyword">class</span> <span class="title">traits</span> =</span> char_traits&lt;charT&gt;,</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Allocator</span> =</span> allocator&lt;charT&gt; &gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">basic_string</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char_traits不仅是在basic_string 中有用，在basic_istream 和 basic_ostream中也需要用到。 就像Steve Donovan在过度使用C++模板中提到的，这些确实有些过头了，要不是系统自己定义了相关的一些属性，而且用了个<span class="keyword">typedef</span>，否则还真不知道如何使用。</span><br><span class="line"></span><br><span class="line">但复杂总有复杂道理。有了char_traits，你可以定义自己的字符串类型。当然，有了char_traits &lt; <span class="keyword">char</span> &gt; 和char_traits &lt; <span class="keyword">wchar_t</span> &gt; 你的需求使用已经足够了，为了更好的理解string ，咱们来看看char_traits都有哪些要求。</span><br><span class="line"></span><br><span class="line">如果你希望使用你自己定义的字符，你必须定义包含下列成员的结构： 表达式 描述</span><br><span class="line"></span><br><span class="line">```C++</span><br><span class="line">char_type 字符类型</span><br><span class="line">int_type <span class="keyword">int</span> 类型</span><br><span class="line">pos_type 位置类型</span><br><span class="line">off_type 表示位置之间距离的类型</span><br><span class="line">state_type 表示状态的类型</span><br><span class="line"><span class="built_in">assign</span>(c1,c2) 把字符c2赋值给<span class="function">c1</span></span><br><span class="line"><span class="function"><span class="title">eq</span><span class="params">(c1,c2)</span> 判断c1,c2 是否相等</span></span><br><span class="line"><span class="function"><span class="title">lt</span><span class="params">(c1,c2)</span> 判断c1是否小于c2</span></span><br><span class="line"><span class="function"><span class="title">length</span><span class="params">(str)</span> 判断str的长度</span></span><br><span class="line"><span class="function"><span class="title">compare</span><span class="params">(s1,s2,n)</span> 比较s1和s2的前n个字符</span></span><br><span class="line"><span class="function"><span class="title">copy</span><span class="params">(s1,s2, n)</span> 把s2的前n个字符拷贝到s1中</span></span><br><span class="line"><span class="function"><span class="title">move</span><span class="params">(s1,s2, n)</span> 把s2中的前n个字符移动到s1中</span></span><br><span class="line"><span class="function"><span class="title">assign</span><span class="params">(s,n,c)</span> 把s中的前n个字符赋值为c</span></span><br><span class="line"><span class="function"><span class="title">find</span><span class="params">(s,n,c)</span> 在s的前n个字符内查找c</span></span><br><span class="line"><span class="function"><span class="title">eof</span><span class="params">()</span> 返回end-of-file</span></span><br><span class="line"><span class="function"><span class="title">to_int_type</span><span class="params">(c)</span> 将c转换成int_type</span></span><br><span class="line"><span class="function"><span class="title">to_char_type</span><span class="params">(i)</span> 将i转换成char_type</span></span><br><span class="line"><span class="function"><span class="title">not_eof</span><span class="params">(i)</span> 判断i是否为EOF</span></span><br><span class="line"><span class="function"><span class="title">eq_int_type</span><span class="params">(i1,i2)</span> 判断i1和i2是否相等</span></span><br></pre></td></tr></table></figure><p>想看看实际的例子，你可以看看sgi STL的char_traits结构源码.</p><p>现在默认的string版本中，并不支持忽略大小写的比较函数和查找函数，如果你想练练手，你可以试试改写一个char_traits , 然后生成一个case_string类, 也可以在string 上做继承，然后派生一个新的类，例如：ext_string，提供一些常用的功能，例如：</p><p>定义分隔符。给定分隔符，把string分为几个字段。 提供替换功能。例如，用winter, 替换字符串中的wende 大小写处理。例如，忽略大小写比较，转换等 整形转换。例如把”123”字符串转换为123数字。 这些都是常用的功能，如果你有兴趣可以试试。其实有人已经实现了，看看Extended STL string。如果你想偷懒，下载一个头文件就可以用，有了它确实方便了很多。要是有人能提供一个支持正则表达式的string，我会非常乐意用。</p><h3 id="4-string-建议"><a href="#4-string-建议" class="headerlink" title="4.string 建议"></a>4.string 建议</h3><p>使用string 的方便性就不用再说了，这里要重点强调的是string的安全性。 string并不是万能的，如果你在一个大工程中需要频繁处理字符串，而且有可能是多线程，那么你一定要慎重(当然，在多线程下你使用任何STL容器都要慎重)。 string的实现和效率并不一定是你想象的那样，如果你对大量的字符串操作，而且特别关心其效率，那么你有两个选择，首先，你可以看看你使用的STL版本中string实现的源码；另一选择是你自己写一个只提供你需要的功能的类。 string的c_str()函数是用来得到C语言风格的字符串，其返回的指针不能修改其空间。而且在下一次使用时重新调用获得新的指针。 string的data()函数返回的字符串指针不会以’\0’结束，千万不可忽视。 尽量去使用操作符，这样可以让程序更加易懂</p><h3 id="5-小结"><a href="#5-小结" class="headerlink" title="5 小结"></a>5 小结</h3><p> 难怪有人说：string 使用方便功能强，我们一直用它！</p><h3 id="6-附录"><a href="#6-附录" class="headerlink" title="6 附录"></a>6 附录</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">string 函数列表 函数名 描述</span><br><span class="line">begin 得到指向字符串开头的Iterator</span><br><span class="line">end 得到指向字符串结尾的Iterator</span><br><span class="line">rbegin 得到指向反向字符串开头的Iterator</span><br><span class="line">rend 得到指向反向字符串结尾的Iterator</span><br><span class="line">size 得到字符串的大小</span><br><span class="line">length 和size函数功能相同</span><br><span class="line">max_size 字符串可能的最大大小</span><br><span class="line">capacity 在不重新分配内存的情况下，字符串可能的大小</span><br><span class="line">empty 判断是否为空</span><br><span class="line"><span class="keyword">operator</span>[] 取第几个元素，相当于数组</span><br><span class="line">c_str 取得C风格的<span class="keyword">const</span> <span class="keyword">char</span>* 字符串</span><br><span class="line">data 取得字符串内容地址</span><br><span class="line"><span class="keyword">operator</span>= 赋值操作符</span><br><span class="line">reserve 预留空间</span><br><span class="line">swap 交换函数</span><br><span class="line">insert 插入字符</span><br><span class="line">append 追加字符</span><br><span class="line">push_back 追加字符</span><br><span class="line"><span class="keyword">operator</span>+= += 操作符</span><br><span class="line">erase 删除字符串</span><br><span class="line">clear 清空字符容器中所有内容</span><br><span class="line">resize 重新分配空间</span><br><span class="line">assign 和赋值操作符一样</span><br><span class="line">replace 替代</span><br><span class="line">copy 字符串到空间</span><br><span class="line">find 查找</span><br><span class="line">rfind 反向查找</span><br><span class="line">find_first_of 查找包含子串中的任何字符，返回第一个位置</span><br><span class="line">find_first_not_of 查找不包含子串中的任何字符，返回第一个位置</span><br><span class="line">find_last_of 查找包含子串中的任何字符，返回最后一个位置</span><br><span class="line">find_last_not_of 查找不包含子串中的任何字符，返回最后一个位置</span><br><span class="line">substr 得到字串</span><br><span class="line">compare 比较字符串</span><br><span class="line"><span class="keyword">operator</span>+ 字符串链接</span><br><span class="line"><span class="keyword">operator</span>== 判断是否相等</span><br><span class="line"><span class="keyword">operator</span>!= 判断是否不等于</span><br><span class="line"><span class="keyword">operator</span>&lt; 判断是否小于</span><br><span class="line"><span class="keyword">operator</span>&gt;&gt; 从输入流中读入字符串</span><br><span class="line"><span class="keyword">operator</span>&lt;&lt; 字符串写入输出流</span><br><span class="line">getline 从输入流中读入一行 </span><br></pre></td></tr></table></figure><p>之所以抛弃char*的字符串而选用C++标准程序库中的string类，是因为他和前者比较起来，不必担心内存是否足够、字符串长度等等，而且作为一个类出现，他集成的操作函数足以完成我们大多数情况下(甚至是100%)的需要。我们可以用 = 进行赋值操作，== 进行比较，+ 做串联（是不是很简单?）。我们尽可以把它看成是C++的基本数据类型。 好了，进入正题……… 首先，为了在我们的程序中使用string类型，我们必须包含头文件<code>&lt;cstring&gt;</code>。</p><h4 id="1．声明一个C-字符串"><a href="#1．声明一个C-字符串" class="headerlink" title="1．声明一个C++字符串"></a>1．声明一个C++字符串</h4><p>声明一个字符串变量很简单：<br><code>string Str;</code><br>这样我们就声明了一个字符串变量，但既然是一个类，就有构造函数和析构函数。上面的声明没有传入参数，所以就直接使用了string的默认的构造函数，这个函数所作的就是把Str初始化为一个空字符串。String类的构造函数和析构函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">a)    string s;  <span class="comment">//生成一个空字符串s</span></span><br><span class="line">b)    <span class="function">string <span class="title">s</span><span class="params">(str)</span> <span class="comment">//拷贝构造函数 生成str的复制品</span></span></span><br><span class="line"><span class="function">c)    string <span class="title">s</span><span class="params">(str,stridx)</span> <span class="comment">//将字符串str内“始于位置stridx”的部分当作字符串的初值</span></span></span><br><span class="line"><span class="function">d)    string <span class="title">s</span><span class="params">(str,stridx,strlen)</span> <span class="comment">//将字符串str内“始于stridx且长度顶多strlen”的部分作为字符串的初值</span></span></span><br><span class="line"><span class="function">e)    string <span class="title">s</span><span class="params">(cstr)</span> <span class="comment">//将C字符串作为s的初值</span></span></span><br><span class="line"><span class="function">f)    string <span class="title">s</span><span class="params">(chars,chars_len)</span> <span class="comment">//将C字符串前chars_len个字符作为字符串s的初值。</span></span></span><br><span class="line"><span class="function">g)    string <span class="title">s</span><span class="params">(num,c)</span> <span class="comment">//生成一个字符串，包含num个c字符</span></span></span><br><span class="line"><span class="function">h)    string <span class="title">s</span><span class="params">(beg,end)</span> <span class="comment">//以区间beg;end(不包含end)内的字符作为字符串s的初值</span></span></span><br><span class="line"><span class="function">i)    s.~<span class="title">string</span><span class="params">()</span> <span class="comment">//销毁所有字符，释放内存</span></span></span><br></pre></td></tr></table></figure><p>都很简单，我就不解释了。</p><h4 id="2．字符串操作函数"><a href="#2．字符串操作函数" class="headerlink" title="2．字符串操作函数"></a>2．字符串操作函数</h4><p>这里是C++字符串的重点，我先把各种操作函数罗列出来，不喜欢把所有函数都看完的人可以在这里找自己喜欢的函数，再到后面看他的详细解释。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">a) =,<span class="built_in">assign</span>()   <span class="comment">//赋以新值</span></span><br><span class="line">b) <span class="built_in">swap</span>()   <span class="comment">//交换两个字符串的内容</span></span><br><span class="line">c) +=,<span class="built_in">append</span>(),<span class="built_in">push_back</span>() <span class="comment">//在尾部添加字符</span></span><br><span class="line">d) <span class="built_in">insert</span>() <span class="comment">//插入字符</span></span><br><span class="line">e) <span class="built_in">erase</span>() <span class="comment">//删除字符</span></span><br><span class="line">f) <span class="built_in">clear</span>() <span class="comment">//删除全部字符</span></span><br><span class="line">g) <span class="built_in">replace</span>() <span class="comment">//替换字符</span></span><br><span class="line">h) + <span class="comment">//串联字符串</span></span><br><span class="line">i) ==,!=,&lt;,&lt;=,&gt;,&gt;=,<span class="built_in">compare</span>()  <span class="comment">//比较字符串</span></span><br><span class="line">j) <span class="built_in">size</span>(),<span class="built_in">length</span>()  <span class="comment">//返回字符数量</span></span><br><span class="line">k) <span class="built_in">max_size</span>() <span class="comment">//返回字符的可能最大个数</span></span><br><span class="line">l) <span class="built_in">empty</span>()  <span class="comment">//判断字符串是否为空</span></span><br><span class="line">m) <span class="built_in">capacity</span>() <span class="comment">//返回重新分配之前的字符容量</span></span><br><span class="line">n) <span class="built_in">reserve</span>() <span class="comment">//保留一定量内存以容纳一定数量的字符</span></span><br><span class="line">o) [ ], <span class="built_in">at</span>() <span class="comment">//存取单一字符</span></span><br><span class="line">p) &gt;&gt;,<span class="built_in">getline</span>() <span class="comment">//从stream读取某值</span></span><br><span class="line">q) &lt;&lt;  <span class="comment">//将谋值写入stream</span></span><br><span class="line">r) <span class="built_in">copy</span>() <span class="comment">//将某值赋值为一个C_string</span></span><br><span class="line">s) <span class="built_in">c_str</span>() <span class="comment">//将内容以C_string返回</span></span><br><span class="line">t) <span class="built_in">data</span>() <span class="comment">//将内容以字符数组形式返回</span></span><br><span class="line">u) <span class="built_in">substr</span>() <span class="comment">//返回某个子字符串</span></span><br><span class="line">v)查找函数</span><br><span class="line">w)<span class="built_in">begin</span>() <span class="built_in">end</span>() <span class="comment">//提供类似STL的迭代器支持</span></span><br><span class="line">x) <span class="built_in">rbegin</span>() <span class="built_in">rend</span>() <span class="comment">//逆向迭代器</span></span><br><span class="line">y) <span class="built_in">get_allocator</span>() <span class="comment">//返回配置器</span></span><br></pre></td></tr></table></figure><h5 id="2．1-C-字符串和C字符串的转换"><a href="#2．1-C-字符串和C字符串的转换" class="headerlink" title="2．1 C++字符串和C字符串的转换"></a>2．1 C++字符串和C字符串的转换</h5><p>C++提供的由C++字符串得到对应的C_string的方法是使用data()、c_str()和copy()，其中，data()以字符数组的形式返回字符串内容，但并不添加’\0’。c_str()返回一个以‘\0’结尾的字符数组，而copy()则把字符串的内容复制或写入既有的c_string 或字符数组内。C++字符串并不以’\0’结尾。我的建议是在程序中能使用C++字符串就使用，除非万不得已不选用c_string。由于只是简单介绍，详细介绍掠过，谁想进一步了解使用中的注意事项可以给我留言(到我的收件箱)。我详细解释。</p><h5 id="2．2-大小和容量函数"><a href="#2．2-大小和容量函数" class="headerlink" title="2．2 大小和容量函数"></a>2．2 大小和容量函数</h5><p> 一个C++字符串存在三种大小：a)现有的字符数，函数是size()和length()，他们等效。Empty()用来检查字符串是否为空。 b)max_size() 这个大小是指当前C++字符串最多能包含的字符数，很可能和机器本身的限制或者字符串所在位置连续内存的大小有关系。我们一般情况下不用关心他，应该大小足够我们用的。但是不够用的话，会抛出length_error异常c)capacity()重新分配内存之前 string所能包含的最大字符数。这里另一个需要指出的是reserve()函数，这个函数为string重新分配内存。重新分配的大小由其参数决定，默认参数为0，这时候会对string进行非强制性缩减。</p><p>还有必要再重复一下C++字符串和C字符串转换的问题，许多人会遇到这样的问题，自己做的程序要调用别人的函数、类什么的（比如数据库连接函数 Connect(char*,char*)），但别人的函数参数用的是char<em>形式的，而我们知道，c_str()、data()返回的字符数组由该字符串拥有，所以是一种const char</em>,要想作为上面提及的函数的参数，还必须拷贝到一个char*,而我们的原则是能不使用C字符串就不使用。那么，这时候我们的处理方式是：如果此函数对参数(也就是char*)的内容不修改的话，我们可以这样Connect((char*)UserID.c_str(), (char*)PassWD.c_str()),但是这时候是存在危险的，因为这样转换后的字符串其实是可以修改的（有兴趣地可以自己试一试），所以我强调除非函数调用的时候不对参数进行修改，否则必须拷贝到一个char<em>上去。当然，更稳妥的办法是无论什么情况都拷贝到一个char</em>上去。同时我们也祈祷现在仍然使用C字符串进行编程的高手们（说他们是高手一点儿也不为过，也许在我们还穿开裆裤的时候他们就开始编程了，哈哈…）写的函数都比较规范，那样我们就不必进行强制转换了。</p><h5 id="2．3元素存取"><a href="#2．3元素存取" class="headerlink" title="2．3元素存取"></a>2．3元素存取</h5><p> 我们可以使用下标操作符[] 和函数at()对元素包含的字符进行访问。但是应该注意的是操作符[]并不检查索引是否有效（有效索引 0~str.length()），如果索引失效，会引起未定义的行为。而at()会检查，如果使用at()的时候索引无效，会抛出 out_of_range异常。 有一个例外不得不说，const string a;的操作符[]对索引值是a.length()仍然有效，其返回值是’\0’。其他的各种情况，a.length()索引都是无效的。举例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> string <span class="title">Cstr</span><span class="params">(“<span class="keyword">const</span> string”)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">Str</span><span class="params">(“string”)</span></span>;</span><br><span class="line"></span><br><span class="line">Str[<span class="number">3</span>];    <span class="comment">//ok</span></span><br><span class="line">Str.<span class="built_in">at</span>(<span class="number">3</span>);  <span class="comment">//ok</span></span><br><span class="line"></span><br><span class="line">Str[<span class="number">100</span>]; <span class="comment">//未定义的行为</span></span><br><span class="line">Str.<span class="built_in">at</span>(<span class="number">100</span>);  <span class="comment">//throw out_of_range</span></span><br><span class="line"></span><br><span class="line">Str[Str.<span class="built_in">length</span>()]  <span class="comment">//未定义行为</span></span><br><span class="line">Cstr[Cstr.<span class="built_in">length</span>()] <span class="comment">//返回 ‘\0’</span></span><br><span class="line">Str.<span class="built_in">at</span>(Str.<span class="built_in">length</span>());<span class="comment">//throw out_of_range</span></span><br><span class="line">Cstr.<span class="built_in">at</span>(Cstr.<span class="built_in">length</span>()) <span class="comment">////throw out_of_range</span></span><br></pre></td></tr></table></figure><p>我不赞成类似于下面的引用或指针赋值： <code>char&amp; r=s[2]; char* p= &amp;s[3];</code></p><p>因为一旦发生重新分配，r,p立即失效。避免的方法就是不使用。</p><h5 id="2．4比较函数"><a href="#2．4比较函数" class="headerlink" title="2．4比较函数"></a>2．4比较函数</h5><p> C++字符串支持常见的比较操作符（&gt;,&gt;=,&lt;,&lt;=,==,!=），甚至支持string与C-string的比较(如 str&lt;”hello”)。在使用&gt;,&gt;=,&lt;,&lt;=这些操作符的时候是根据“当前字符特性”将字符按字典顺序进行逐一得比较。字典排序靠前的字符小，比较的顺序是从前向后比较，遇到不相等的字符就按这个位置上的两个字符的比较结果确定两个字符串的大小。同时，string(“aaaa”) &lt;string(aaaaa)。 另一个功能强大的比较函数是成员函数compare()。他支持多参数处理，支持用索引值和长度定位子串来进行比较。他返回一个整数来表示比较结果，返回值意义如下：0-相等 〉0-大于 &lt;0-小于。举例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(“abcd”)</span></span>;</span><br><span class="line">s.<span class="built_in">compare</span>(“abcd”); <span class="comment">//返回0</span></span><br><span class="line">s.<span class="built_in">compare</span>(“dcba”); <span class="comment">//返回一个小于0的值</span></span><br><span class="line">s.<span class="built_in">compare</span>(“ab”); <span class="comment">//返回大于0的值</span></span><br><span class="line">s.<span class="built_in">compare</span>(s); <span class="comment">//相等</span></span><br><span class="line">s.<span class="built_in">compare</span>(<span class="number">0</span>,<span class="number">2</span>,s,<span class="number">2</span>,<span class="number">2</span>); <span class="comment">//用”ab”和”cd”进行比较 小于零</span></span><br><span class="line">s.<span class="built_in">compare</span>(<span class="number">1</span>,<span class="number">2</span>,”bcx”,<span class="number">2</span>); <span class="comment">//用”bc”和”bc”比较。</span></span><br></pre></td></tr></table></figure><p>怎么样？功能够全的吧！什么？还不能满足你的胃口？好吧，那等着，后面有更个性化的比较算法。先给个提示，使用的是STL的比较算法。什么？对STL一窍不通？你重修吧！</p><h5 id="2．5-更改内容"><a href="#2．5-更改内容" class="headerlink" title="2．5 更改内容"></a>2．5 更改内容</h5><p> 这在字符串的操作中占了很大一部分。 首先讲赋值，第一个赋值方法当然是使用操作符=，新值可以是string(如：s=ns) 、c_string(如：s=”gaint”)甚至单一字符（如：s=’j’）。还可以使用成员函数assign()，这个成员函数可以使你更灵活的对字符串赋值。还是举例说明吧：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">assign</span>(str); <span class="comment">//直接</span></span><br><span class="line">s.<span class="built_in">assign</span>(str,<span class="number">1</span>,<span class="number">3</span>);<span class="comment">//如果str是”iamangel” 就是把”ama”赋给字符串</span></span><br><span class="line">s.<span class="built_in">assign</span>(str,<span class="number">2</span>,string::npos);<span class="comment">//把字符串str从索引值2开始到结尾赋给s</span></span><br><span class="line">s.<span class="built_in">assign</span>(“gaint”); <span class="comment">//不说</span></span><br><span class="line">s.<span class="built_in">assign</span>(“nico”,<span class="number">5</span>);<span class="comment">//把’n’ ‘I’ ‘c’ ‘o’ ‘\0’赋给字符串</span></span><br><span class="line">s.<span class="built_in">assign</span>(<span class="number">5</span>,’x’);<span class="comment">//把五个x赋给字符串</span></span><br></pre></td></tr></table></figure><p>把字符串清空的方法有三个：s=””;s.clear();s.erase();(我越来越觉得举例比说话让别人容易懂！)。 string提供了很多函数用于插入（insert）、删除（erase）、替换（replace）、增加字符。 先说增加字符（这里说的增加是在尾巴上），函数有 +=、append()、push_back()。举例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">s+=str;<span class="comment">//加个字符串</span></span><br><span class="line">s+=”my name is jiayp”;<span class="comment">//加个C字符串</span></span><br><span class="line">s+=’a’;<span class="comment">//加个字符</span></span><br><span class="line"></span><br><span class="line">s.<span class="built_in">append</span>(str);</span><br><span class="line">s.<span class="built_in">append</span>(str,<span class="number">1</span>,<span class="number">3</span>);<span class="comment">//不解释了 同前面的函数参数assign的解释</span></span><br><span class="line">s.<span class="built_in">append</span>(str,<span class="number">2</span>,string::npos)<span class="comment">//不解释了</span></span><br><span class="line"></span><br><span class="line">s.<span class="built_in">append</span>(“my name is jiayp”);</span><br><span class="line">s.<span class="built_in">append</span>(“nico”,<span class="number">5</span>);</span><br><span class="line">s.<span class="built_in">append</span>(<span class="number">5</span>,’x’);</span><br><span class="line"></span><br><span class="line">s.<span class="built_in">push_back</span>(‘a’);<span class="comment">//这个函数只能增加单个字符 对STL熟悉的理解起来很简单</span></span><br></pre></td></tr></table></figure><p>也许你需要在string中间的某个位置插入字符串，这时候你可以用insert()函数，这个函数需要你指定一个安插位置的索引，被插入的字符串将放在这个索引的后面。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">insert</span>(<span class="number">0</span>,”my name”);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">1</span>,str);</span><br></pre></td></tr></table></figure><p>这种形式的insert()函数不支持传入单个字符，这时的单个字符必须写成字符串形式(让人恶心)。既然你觉得恶心，那就不得不继续读下面一段话：为了插入单个字符，insert()函数提供了两个对插入单个字符操作的重载函数：<code>insert(size_type index,size_type num,chart c)和insert(iterator pos,size_type num,chart c)</code>。其中size_type是无符号整数，iterator是char*,所以，你这么调用insert函数是不行的：insert(0,1,’j’);这时候第一个参数将转换成哪一个呢？所以你必须这么写：insert((string::size_type)0,1,’j’)！第二种形式指出了使用迭代器安插字符的形式，在后面会提及。顺便提一下，string有很多操作是使用STL的迭代器的，他也尽量做得和STL靠近。 删除函数erase()的形式也有好几种（真烦！），替换函数replace()也有好几个。举例吧：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string s=”il8n”;</span><br><span class="line">s.<span class="built_in">replace</span>(<span class="number">1</span>,<span class="number">2</span>,”nternationalizatio”);<span class="comment">//从索引1开始的2个替换成后面的C_string</span></span><br><span class="line">s.<span class="built_in">erase</span>(<span class="number">13</span>);<span class="comment">//从索引13开始往后全删除</span></span><br><span class="line">s.<span class="built_in">erase</span>(<span class="number">7</span>,<span class="number">5</span>);<span class="comment">//从索引7开始往后删5个</span></span><br></pre></td></tr></table></figure><p>2．6提取子串和字符串连接</p><p>题取子串的函数是：substr(),形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">substr</span>();<span class="comment">//返回s的全部内容</span></span><br><span class="line">s.<span class="built_in">substr</span>(<span class="number">11</span>);<span class="comment">//从索引11往后的子串</span></span><br><span class="line">s.<span class="built_in">substr</span>(<span class="number">5</span>,<span class="number">6</span>);<span class="comment">//从索引5开始6个字符</span></span><br></pre></td></tr></table></figure><p>把两个字符串结合起来的函数是+。（谁不明白请致电120）</p><p>2．7输入输出操作 1．» 从输入流读取一个string。 2．« 把一个string写入输出流。 另一个函数就是getline(),他从输入流读取一行内容，直到遇到分行符或到了文件尾。</p><p>2．8搜索与查找 查找函数很多，功能也很强大，包括了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span>()</span><br><span class="line"><span class="built_in">rfind</span>()</span><br><span class="line"><span class="built_in">find_first_of</span>()</span><br><span class="line"><span class="built_in">find_last_of</span>()</span><br><span class="line"><span class="built_in">find_first_not_of</span>()</span><br><span class="line"><span class="built_in">find_last_not_of</span>()</span><br></pre></td></tr></table></figure><p>这些函数返回符合搜索条件的字符区间内的第一个字符的索引，没找到目标就返回npos。所有的函数的参数说明如下： 第一个参数是被搜寻的对象。第二个参数（可有可无）指出string内的搜寻起点索引，第三个参数（可有可无）指出搜寻的字符个数。比较简单，不多说 不理解的可以向我提出，我再仔细的解答。当然，更加强大的STL搜寻在后面会有提及。 最后再说说npos的含义，string::npos的类型是string::size_type,所以，一旦需要把一个索引与npos相比，这个索引值必须是string::size)type类型的，更多的情况下，我们可以直接把函数和npos进行比较（如：if(s.find(“jia”)==string::npos)）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;em&gt;本文根据 CC BY-NC-SA 4.0 许可协议参考Nicolai M.Josuttis的文章并进行小部分转载&lt;/em&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;C++ 语言是个十分优秀的语言，但优秀并不表示完美。还是有许多人不愿意使用C或者C++，为什么？原因众多，其中之一就是</summary>
      
    
    
    
    <category term="编程算法" scheme="https://billma.top/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>C++中如何使用struct和STL创建链表结构</title>
    <link href="https://billma.top/2021/07/21/stl_use/"/>
    <id>https://billma.top/2021/07/21/stl_use/</id>
    <published>2021-07-21T07:39:00.000Z</published>
    <updated>2021-09-04T13:04:04.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-链表结构的使用"><a href="#一-链表结构的使用" class="headerlink" title="一.链表结构的使用"></a>一.链表结构的使用</h2><h3 id="1-创建"><a href="#1-创建" class="headerlink" title="1.创建"></a>1.创建</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;<span class="comment">//该链数据</span></span><br><span class="line">    node *next;<span class="comment">//指向链表下一个数据</span></span><br><span class="line">&#125;</span><br><span class="line">node *p;<span class="comment">//链表所在的地址</span></span><br></pre></td></tr></table></figure><h3 id="2-新增存储单元"><a href="#2-新增存储单元" class="headerlink" title="2.新增存储单元"></a>2.新增存储单元</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = <span class="keyword">new</span> node;</span><br></pre></td></tr></table></figure><h3 id="3-其他所需的操作符"><a href="#3-其他所需的操作符" class="headerlink" title="3.其他所需的操作符"></a>3.其他所需的操作符</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node *head;<span class="comment">//指向头节点</span></span><br><span class="line">node *p;<span class="comment">//用来申请新的数据单元</span></span><br><span class="line">node *r;<span class="comment">//用来指向末节点(最后一个数据)</span></span><br></pre></td></tr></table></figure><h3 id="4-输入一个链表"><a href="#4-输入一个链表" class="headerlink" title="4.输入一个链表"></a>4.输入一个链表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x;<span class="comment">//每次输入的数据</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line"><span class="keyword">while</span> (<span class="comment">/*输入链条的终止条件*/</span>)&#123;</span><br><span class="line">    p=<span class="keyword">new</span> node;<span class="comment">//申请一个新节点</span></span><br><span class="line">    p-&gt;data=x;<span class="comment">//录入数据</span></span><br><span class="line">    p-&gt;next=<span class="literal">NULL</span>;<span class="comment">//初始化下一个节点避免闪退</span></span><br><span class="line">    r-&gt;next=p;<span class="comment">//将新节点接到前面链表中</span></span><br><span class="line">    r=p;<span class="comment">//末节点后移</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);<span class="comment">//输入下一个数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-输出链表"><a href="#5-输出链表" class="headerlink" title="5.输出链表"></a>5.输出链表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p=head-&gt;next;<span class="comment">//p指针回到链表开头</span></span><br><span class="line"><span class="keyword">while</span>(p-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,p-&gt;data);</span><br><span class="line">    p=p-&gt;next;<span class="comment">//到下一个节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,p-&gt;data);<span class="comment">//把最后一个数据也输出</span></span><br></pre></td></tr></table></figure><h3 id="6-查找某个条件的数据"><a href="#6-查找某个条件的数据" class="headerlink" title="6.查找某个条件的数据"></a>6.查找某个条件的数据</h3><h4 id="a-查找满足一定条件的节点"><a href="#a-查找满足一定条件的节点" class="headerlink" title="a.查找满足一定条件的节点"></a>a.查找满足一定条件的节点</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p=head-&gt;next;</span><br><span class="line"><span class="keyword">while</span>((p-&gt;data !=(满足的条件))&amp;&amp;(p-&gt;next !=<span class="literal">NULL</span>))p=p-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(p-&gt;data ==(满足的条件))处理该数据;</span><br><span class="line"><span class="keyword">else</span> 输出不存在;</span><br></pre></td></tr></table></figure><h4 id="b-查找所有满足条件的点"><a href="#b-查找所有满足条件的点" class="headerlink" title="b.查找所有满足条件的点"></a>b.查找所有满足条件的点</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p=head-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(p-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;data==(满足的条件))&#123;</span><br><span class="line">        <span class="comment">/*处理该数据*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    p=p-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二-使用STL容器进行"><a href="#二-使用STL容器进行" class="headerlink" title="二.使用STL容器进行"></a>二.使用STL容器进行</h2><h3 id="a-set"><a href="#a-set" class="headerlink" title="a.set"></a>a.set</h3><h4 id="1-特点"><a href="#1-特点" class="headerlink" title="1.特点"></a>1.特点</h4><p>无序，随机，类似于指针（但其实不是指针，STL容器过于强大）</p><h4 id="2-头文件"><a href="#2-头文件" class="headerlink" title="2.头文件"></a>2.头文件</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure><h4 id="3-定义容器"><a href="#3-定义容器" class="headerlink" title="3.定义容器"></a>3.定义容器</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set&lt;kind&gt;name</span><br><span class="line"><span class="comment">/*例：*/</span>set&lt;string&gt;class_set;<span class="comment">//类中的一个学生列表</span></span><br></pre></td></tr></table></figure><h4 id="4-添加元素"><a href="#4-添加元素" class="headerlink" title="4.添加元素"></a>4.添加元素</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="comment">/*满足条件*/</span>)&#123;</span><br><span class="line">    string str;</span><br><span class="line">    cin&gt;&gt;str;</span><br><span class="line">    class_set.<span class="built_in">insert</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-输出学生集合（无序的）"><a href="#5-输出学生集合（无序的）" class="headerlink" title="5.输出学生集合（无序的）"></a>5.输出学生集合（无序的）</h4><h5 id="1-创建迭代器"><a href="#1-创建迭代器" class="headerlink" title="[1]创建迭代器"></a>[1]创建迭代器</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set&lt;kind&gt;::const_iterator cur_name;<span class="comment">//cur_name为迭代器</span></span><br><span class="line"><span class="comment">/*example*/</span>set&lt;string&gt;::const_iterator cur_student;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="2-遍历输出"><a href="#2-遍历输出" class="headerlink" title="[2]遍历输出"></a>[2]遍历输出</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(cur_student = class_set.<span class="built_in">begin</span>();</span><br><span class="line">    cur_student !=class_set.<span class="built_in">end</span>();</span><br><span class="line">    cur_student++)cout&lt;&lt;*cur_student&lt;&lt;endl;</span><br></pre></td></tr></table></figure><blockquote><p>cur_student被定义成string类型的迭代器，类似于指针地址</p></blockquote><blockquote><p>初始条件：cur_student指针指向class_set.begin()的地址</p></blockquote><blockquote><p>终止条件：cur_student指针指向class_set.end()的地址</p></blockquote><p><em><strong>注意：不能将for循环里面的！=改成&lt;或者其他符号，因为列表是无序的。++指的是地址后移一位，而不是数字+1</strong></em></p><h5 id="3-使用foreach函数进行遍历输出"><a href="#3-使用foreach函数进行遍历输出" class="headerlink" title="[3]使用foreach函数进行遍历输出"></a>[3]使用foreach函数进行遍历输出</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*1.头文件*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="comment">/*2.创建输出指令*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(set&lt;string&gt;::const_iterator cur_student)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;*cur_student&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*3.使用foreach进行遍历*/</span></span><br><span class="line">foreach(class_set.<span class="built_in">begin</span>(),class_set.<span class="built_in">end</span>(),write);</span><br></pre></td></tr></table></figure><h4 id="6-其它"><a href="#6-其它" class="headerlink" title="6.其它"></a>6.其它</h4><p>set容器当中不能有重复的元素，否则程序会意外终止。如果你想要存放重复元素，你可以将上述set换成multiset即可。</p><h3 id="b-map"><a href="#b-map" class="headerlink" title="b.map"></a>b.map</h3><h4 id="1-特点-1"><a href="#1-特点-1" class="headerlink" title="1.特点"></a>1.特点</h4><p>不同于set，map有两个值，第一个可以称为关键字(key)，每个关键字只能在map中出现一次；第二个可能称为该关键字的值(value)；</p><p>key在一个map只能出现一次，但是value可以出现多次。</p><p>key和value是一对一(one-to-one)的，而不同于set，map是有序对。</p><h4 id="2-头文件-1"><a href="#2-头文件-1" class="headerlink" title="2.头文件"></a>2.头文件</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure><h4 id="3-声明map"><a href="#3-声明map" class="headerlink" title="3.声明map"></a>3.声明map</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std:map&lt;type1,type2&gt; variable;</span><br><span class="line"><span class="comment">/*example*/</span>std:map&lt;<span class="keyword">int</span>,string&gt; person;</span><br></pre></td></tr></table></figure><p>当然，如果你觉得每次都定义一个map太烦了，你可以使用<code>typedef</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> map&lt;<span class="keyword">int</span>,string&gt; mapp;</span><br><span class="line">mapp variable1;</span><br><span class="line">mapp variable2;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="4-加入元素"><a href="#4-加入元素" class="headerlink" title="4.加入元素"></a>4.加入元素</h4><p>现在，我们已经声明了一个叫做<code>variable</code>的map容器(你自己随便声明一个也无所谓)。插入有几种方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//First Kind:INSERT function</span></span><br><span class="line"><span class="comment">//1.insert+pair</span></span><br><span class="line">varibale.<span class="built_in">insert</span>(pair&lt;type1,type2&gt;(key,value));</span><br><span class="line"><span class="comment">/*example*/</span>variable.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>,string&gt;(<span class="number">1</span>,<span class="string">&quot;Bill Gates&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.insert+value_type</span></span><br><span class="line">variable.<span class="built_in">insert</span>(map&lt;type1,type2&gt;::<span class="built_in">value_type</span>(key,value));</span><br><span class="line"><span class="comment">/*example*/</span>variable.<span class="built_in">insert</span>(map&lt;<span class="keyword">int</span>,string&gt;::<span class="built_in">value_type</span>(<span class="number">2</span>,<span class="string">&quot;Jeff Bezos&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//Second Kind:Array[]</span></span><br><span class="line">variable[key]=value;</span><br><span class="line"><span class="comment">/*example*/</span>variable[<span class="number">3</span>]=<span class="string">&quot;Michael Dell&quot;</span>;</span><br></pre></td></tr></table></figure><p>为什么我要分为两种呢？因为使用insert+pair和insert+value_type组合效果是相同的。他俩都是通过insert函数插入数据。但是，如果某key已经有了一个value，insert函数是会自动跳过不执行指令的。如果使用array数组进行插入，新输入的数据就会把原有的数据覆盖住。</p><h4 id="5-查找元素"><a href="#5-查找元素" class="headerlink" title="5.查找元素"></a>5.查找元素</h4><p>这个时候又要用到迭代器了。先声明一个迭代器iterate，随后循环查找：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iterate = variable.<span class="built_in">find</span>(key);</span><br><span class="line"><span class="keyword">while</span>(iterate != variable.<span class="built_in">end</span>())&#123;</span><br><span class="line">    <span class="comment">/*处理该数据*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-删除元素"><a href="#6-删除元素" class="headerlink" title="6.删除元素"></a>6.删除元素</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.iterate</span></span><br><span class="line">iterate =variable.<span class="built_in">find</span>(key);</span><br><span class="line"><span class="keyword">int</span> del =variable.<span class="built_in">erase</span>(iterate);</span><br><span class="line"><span class="comment">//erase函数删除成功返回1，否则返回0，下同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.key</span></span><br><span class="line"><span class="keyword">int</span> del =variable.<span class="built_in">erase</span>(key);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.delete key1~key2</span></span><br><span class="line"><span class="keyword">int</span> del =variable.<span class="built_in">erase</span>(key1,key2);</span><br><span class="line"><span class="comment">//把key1到key2之间所有的数据全部删除</span></span><br><span class="line"><span class="comment">//如果想删除某map所有数据，有以下两种办法：</span></span><br><span class="line"><span class="comment">/*1*/</span><span class="keyword">int</span> del =variable.<span class="built_in">erase</span>(variable.<span class="built_in">begin</span>(),variable.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">/*2*/</span><span class="keyword">int</span> del =variable.<span class="built_in">clear</span>();</span><br></pre></td></tr></table></figure><h4 id="7-map大小"><a href="#7-map大小" class="headerlink" title="7.map大小"></a>7.map大小</h4><p>我怎么知道map里面目前有多少数据呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num =variable.<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure><p>未完待续。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一-链表结构的使用&quot;&gt;&lt;a href=&quot;#一-链表结构的使用&quot; class=&quot;headerlink&quot; title=&quot;一.链表结构的使用&quot;&gt;&lt;/a&gt;一.链表结构的使用&lt;/h2&gt;&lt;h3 id=&quot;1-创建&quot;&gt;&lt;a href=&quot;#1-创建&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="编程算法" scheme="https://billma.top/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>我的第一篇博客</title>
    <link href="https://billma.top/2021/07/10/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <id>https://billma.top/2021/07/10/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</id>
    <published>2021-07-09T20:23:52.000Z</published>
    <updated>2021-08-25T13:40:50.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="首先-欢迎各位到访我的空间"><a href="#首先-欢迎各位到访我的空间" class="headerlink" title="首先,欢迎各位到访我的空间"></a>首先,欢迎各位到访我的空间</h3><p>一直没时间打理这个博客,时至今日,终于在凌晨从百忙中完成了我的第一篇博客.<br>这就算我的第一篇博客吧.</p><iframe src="//player.bilibili.com/player.html?aid=459511106&bvid=BV1t5411K71N&cid=309837458&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;首先-欢迎各位到访我的空间&quot;&gt;&lt;a href=&quot;#首先-欢迎各位到访我的空间&quot; class=&quot;headerlink&quot; title=&quot;首先,欢迎各位到访我的空间&quot;&gt;&lt;/a&gt;首先,欢迎各位到访我的空间&lt;/h3&gt;&lt;p&gt;一直没时间打理这个博客,时至今日,终于在凌晨从百忙中</summary>
      
    
    
    
    
  </entry>
  
</feed>
