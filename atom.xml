<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Bill Ma&#39;s Blog</title>
  
  <subtitle>Welcome!</subtitle>
  <link href="https://billma.top/atom.xml" rel="self"/>
  
  <link href="https://billma.top/"/>
  <updated>2021-10-30T14:07:52.000Z</updated>
  <id>https://billma.top/</id>
  
  <author>
    <name>Bill Ma</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>孔子：黑暗王国里的残烛</title>
    <link href="https://billma.top/2021/10/30/%E5%AD%94%E5%AD%90%EF%BC%9A%E9%BB%91%E6%9A%97%E7%8E%8B%E5%9B%BD%E9%87%8C%E7%9A%84%E6%AE%8B%E7%83%9B/"/>
    <id>https://billma.top/2021/10/30/%E5%AD%94%E5%AD%90%EF%BC%9A%E9%BB%91%E6%9A%97%E7%8E%8B%E5%9B%BD%E9%87%8C%E7%9A%84%E6%AE%8B%E7%83%9B/</id>
    <published>2021-10-30T13:49:45.000Z</published>
    <updated>2021-10-30T14:07:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>原作者：鲍鹏山，民革成员，文学博士，作家，学者。上海开放大学人文学院教授 ，青海师范大学硕士研究生导师 [2]  、上海交通大学兼职教授。中国作家协会会员、中国孔子基金会学术委员会委员。潜心研究先秦诸子数十年，长期从事中国古代文学研究。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><div class="story post-story"><p>儒家者流。盖出于司徒之官，助人君顺阴阳明教化者也。游文于六经之中，留意于仁义之际，祖述尧舜，宪章文武，宗师仲尼，以重其言，于道最为高。——《汉书·艺文志》</p><p>士不可不弘毅，任重而道远。仁以为己任，不亦重乎！死而后已，不亦远乎！——曾参</p></div><h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><div class="story post-story"><p>　　孔子的长相颇怪。“生而圩顶”，就是说，他天生的脑袋畸型，头顶上中间低，四周高，司马贞说，其形状恰像倒过来的屋顶。名之曰丘，固当。不知命相学家是如何解释的。这种头顶是否暗示着承受天地之甘露阳光？孔子自学而成大才，其天赋必然很高。而其身长亦不凡，“九尺有六寸”，这在那时可以说是“硕人”了，“人皆谓之长人而异之”，人人都说他是长人，感到惊异。真正的一个齐鲁大汉。不过，这个“长人”的身影也确实够长了——长到遮蔽了整个民族漫长的历史，—个民族都—直顺着他的倒影前行两干多年了，我们何时才能走出这漫漫的阴影呢?</p><p>　　据司马迁和《孔子家语》的记载，孔子乃是商代“三仁”之一微子的后代。那个有名的“仁义之师”的统帅宋襄公，便是他的十一世祖——难怪他也像宋襄公那样泥古不化，自讨苦吃。用古老的仁义道德去对付现世的流氓强盗，这也是他家族的祖传秘诀吧，只可惜常常不灵。到孔子的六世祖孔父嘉，“五世亲尽，别为公族”，不再属王族，姓也成了“孔”。后来孔父嘉又为人所逼而奔鲁。所以孔子确实是一位“没落贵族”。到他父亲叔梁纥，便是连人丁也很寥落了：正妻连生九女，—妾生子叫孟皮，却又是个跛子。年近七十的叔梁纥大概非常绝望了。但他还要作最后的努力，于是便向颜氏求婚，颜氏少女颜征“从父命”而嫁给了古稀之年的叔梁纥。所以，司马迁说这是“野合”，“野”与“礼”相对，夫妻双方年龄差别太大，不合周礼，所以这婚姻不是“礼合”，而是“野合”。“野合而生孔子”——这实在太有意味了，为什么呢？孔子终其一生都在为“礼坏乐崩”而头疼，而愤怒，而奔走呼号，要人们“克己复礼”，孰料他本人即是个不合礼的产儿呢。如果他的那位老父亲真的克制自己来恢复周礼，可就没有孔子了。真玄哪。要知道，这不合“礼”的产儿，竟是他们这古老家族之链上最辉煌的一环，也是我们这古老民族历史上最辉煌的人物啊！</p><p>　　宋人说，“天不生仲尼，万古长如夜”。好抬杠的李贄就此讽刺道，怪不得孔子出生之前，人们都点着蜡烛走路。我想，话不能这么说，也不是这么说的。我觉得，孔子确实是悬挂在那个遥远古世纪的一盏明灯，他使我们对那个遥远的时代不再觉得晦暗和神秘，他使那时代的人与后代乃至于我们沟通了。我们由他知道，即便在那么一个洪荒时代，也是有阳光普照着而万物不探手段地生机勃勃；那时代也发生着我们今天一样的事情：暴力和弱者的呻吟；混乱和宁静的企望；束缚与挣扎；阴谋与流血；理想碰了钉子；天真遇见邪恶；友情温暖，世态炎凉。在他手订的《诗经》中，我们甚至可以体验到最个性的感受——当那些面孔不一情性各异的个人复活时，那个时代不也就复活了吗？<br>　　孔子生活的时代也真像他所说的，确实是混乱无道。他为之伤心不已：辉煌的“郁郁乎文哉”的周王朝已是日薄西山，伟大的周公早已英魂远逝，他制定的“礼”“乐”也土崩瓦解。“弑君三十六，亡国五十二”，到处都是乱臣贼子，且个个生龙活虎。西周古都废墟上的青草与野黍也一茬一茬地青了又黄，黄了又青，根深而茎壮了，掩埋在草丛中瓦裂的陶器早已流尽了最后一滴汁液。九鼎不知去向，三礼流失民间。东周呢？龟缩在洛邑弹九之地，可怜巴巴地看着那些纵横天下的伯霸诸侯，把九州版图闹得瓜分而豆刮。</p><p>　　无可奈何花落去，还有谁来用红巾翠袖，擦去周王混浊的老泪？连孔子本人都不曾去那里。在这种时候，要“兴灭国，继绝世，举逸民”，真无异于痴人说梦。孔子正是这样的一位痴人。痴人往往缺乏现实感。他的精神就常常脱逸出现实的背景，沉浸在过去的辉煌中，追寻着万物逝去的方向。是的，他一生都在追寻，他周游列国，颠颠簸簸，既是在找人，找一个能实施他主张的人，更是在找过去的影子，找东周昔日的文明昌盛。面对这一伟大帝国的文化废墟，孔子领悟到并承诺了自己的使命！但挽狂澜于既倒，或知其不可而为之，只不过是一种令人钦敬的悲剧精神罢了，他最终还是失败了。当他奔波倦极归来，在一条小河边饮他那匹汗马时，他偶然从平静的流水中惊见自己斑驳的两鬓，“甚矣，吾衰矣”（太惨啦！我已经衰老了！）他顿时心凉如水。这衰弱的老人，他的多少雄心都失败了，多少理想都破灭了。壮志不酬，眺望茫茫无语的宇宙，他心事浩茫。人世渺小，天道无情，青山依旧，哲人其萎。于是，一句意味深长的叹息便如一丝凉风，吹彻古今：“逝者如斯夫！”</p><p>　　我在几千年后的漆黑的夜里写这篇文章时，宛如见到他当初衰弱地站在苍茫高天之下的无情逝水边。那无限凄惶的老人的晚景使我大为感动。于是这篇文章的题目也就一闪而现了：这衰弱的，即将随着时间的流水逝去的老人，不就像黑暗旷野上快要燃尽的一枝蜡烛吗？四面飚风，寒意四逼，这支蜡烛艰难地闪耀……</p><p>　　孔子死后，鲁哀公装模作样地悲痛一番，悼念一番，他写了一篇诔文，似乎感伤得很：“上天太不公平啦。不肯留下一位老人陪我，让我一人在鲁国孤零零的，唉，多么悲痛。”孔子的弟子子贡毫不客气地顶了回去：“生不能用，死而诔之，非礼也！”</p><p>　　其实，对孔子“生不能用”的，岂止—位鲁哀公呢？孔子一生见过不少诸侯，像楚昭王，齐景公，卫灵公……等等，有谁用他呢？天下人事纷纷扬扬，新生事物层出不穷，人人都在玩新花样，搞新名堂，他老先生拿着一把过时的且是万古不变的尺子，东量量，西测测，这也不合“礼”，那也不合“乐”，到处招人惹人，别人对他敬而远之也是很自然的。同时他又像一个蹩脚的推销员，推销过时的、早已更新换代的产品。这产品不是按顾客的需求而设计，而是要以这产品的规格来设计顾客，正如韩非嘲笑他的，不是根据脚的大小来选鞋，而是根据鞋的大小来“削足”。他这么不合时宜，被人拒绝不是很正常的么？子贡以他的经济实力和外交天才，到处为老师打点鼓吹，也没有什么效果。子贡的悲痛心情是可以理解的，但过分责备鲁哀公不能用孔子，就不大合情合理啦。</p></div><h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><div class="story post-story"><p>　　痴人有多种，或因情深而痴，或因智浅而痴，孔子属于前者，而他的很多徒子徒孙，如宋明之际的理学家们，就属于后者了，新儒家们当更是等而下之。因情而痴的孔子常常沉湎在过去的怀想之中，“郁郁乎文哉！吾从周！”“逝者如斯夫！”这时，他就是一位抒情者，抒得很动情，很感人。在一个抽象的、冷酷的、沉闷的老子之后，出现一个一往情深、感怀万端的孔子，使我们再次感受到—种温软，一种熨帖，这实在是让我们大大舒了—口气，历史终于在绝望中咧口而哭出了声，一些可怕的心理能量在孔子的歌哭、幽默、感喟中被释放了。</p><p>　　孔子使一些无序的暴力变成了有目的有方向的努力与企望，他使天下英雄入于他的彀中，并带着这些社会精英致力于建构新的理想。当混乱的历史有了理想与方向时，混乱就不再是一无是处，相反，倒往往显示出一种蓬蓬勃勃、生机无穷的魅力。春秋战国时代是一个刀光剑影的时代，一个流血漂橹的时代，一个杀人盈城、杀人盈野的时代，但它不也是一个充满理想，充满激情，充满公理仁德的时代吗？谁开辟了这样的时代？是孔子。非常具有象征意义的是，当孔子和弟子们周游列国的时候，他往往自己驾车——他确实是在驾着这个时代的马车。弟子们在车上或呼呼大睡或哈欠连天，一脸凄迷与怀疑，只有他永远目光炯炯，自信目标就在前方。</p><p>　　有一次，在一条汤汤而流的小河边他们又找不到渡口了。远处的水田中有两人在耕作，子路便上前去打问。<br>　　其中的一个细长个子却不回答子路的询问，而是反问子路：</p><p>　　“那个执缰绳的人是谁？”</p><p>　　子路恭敬地回答：“是孔丘。”</p><p>　　“是鲁国的那个孔丘吗？”——可见孔子的知名度颇高。</p><p>　　子路答：“是”。这个细高个冷冷的就来了一句：“既然是鲁国的那个孔丘，他应该知道渡口在哪里嘛”。</p><p>　　没奈何，已经由绿林好汉改邪归正到孔子门下的子路，只能按捺住火气，转过身去问另一位。这一位魁梧雄桀，是个大块头。大块头也反问子路：“你是谁？”</p><p>　　子路仍然是恭敬地回答：“我是仲由。”</p><p>　　“你是孔丘的门徒吗？”</p><p>　　“是。”</p><p>　　现在又轮到大块头来教训子路了：“天下混乱，举世皆然。谁能改变这种局面？我看你身体强壮，是个好庄稼汉。与其跟随孔子这样的避人之士东奔西走，鼓唇摇舌，倒不如跟随我们这些避世之士，躬耕垄亩的好！”</p><p>　　这里我先解释两个词。什么叫“避人”呢？避人就是择人，就是避开那些昏庸无道的诸侯，而去寻找志同道合的有为之君，一同来重整乾坤。良禽择木而栖，贤才择主而事嘛，不择主，只要给富贵就帮他卖力，那是苏秦张仪的作为。孔子一心要的是救世，而不是个人富贵，所以他恓恓惶惶的马车在纵横阡陌间奔走扬尘，就是要避开身后的昏君而去寻找前面的明君。什么是“避世”？在“避人”的基础上再跨一步，彻底冷了心，闭了眼，认定天下不可能有什么诸侯还能与他一起改变这世界，于是彻底绝望；从而彻底不抱希望，回到田园中去，回到自己的内心中去，告别都市、政治与熙熙攘攘的外部世界，就叫避世。</p><p>　　再回头说子路被这两人教训得一愣一愣的，又要注意自己此时的身份，不能发作，只好垂头丧气地回来向孔子汇报。孔子听完，不尽的迷惘。谁说这两位隐士说得不对呢？这不也是孔子自己内心中常有的感触吗？但他历尽艰辛，学而不厌，“十年磨一剑，霜刃未曾试”，难道就此卷而怀之吗？他有教无类，诲人不倦，门徒三千，贤者七十二，就是为了培养一批隐士，或者懂文化的农夫吗？于是他感慨万端：“人总不能与鸟兽一起生活在山林之中啊，我不和芸芸众生生活在一起，与他们共享欢乐共担不幸，我又能和谁生活在一起呢？他们说天下无道，但不正因为天下混乱无道，才需要我们去承担责任吗？假如天下有道，还需要我们吗?”</p><p>　　《论语》中的这一段，很传神，两千多年了，那条汤汤小河边发生的这场争论就好像发生在昨天似的。这几个人好像还在我们身边。我尤其为孔子感动。他恓惶而寂寞，迷惘而执拗。“志于道”的人越来越少了，不少人顺应潮流，从而成了新贵，或成为新贵的红人，其中甚至有他的门徒，比如那个顶善于察言观色的弟子冉求。又有不少人冷了心，折断宝剑为锄犁，平戎策换得种树书，如长沮，桀溺；其中也有他的弟子，如樊迟。樊迟向他问稼，问为圃，大概也是准备避世了吧。望望眼前，路漫漫其修远兮，看看身后，追随者渐渐寥落。“道不行，乘桴浮于海，从我者，其由与！”（道行不通了，我只能乘小船漂荡到大海中去了。到那时还能跟随我的，可能只有一个仲由了吧！）<br>　　这位可敬可叹的老人，想凭自己个人的德行与魅力来聚集一批年轻人，让他们传道义之火，文化之火；拯民于水火，匡世于既颠，但年轻人不容易经受得了各种诱惑，“吾未见好德如好色者”（我从未见过一个喜爱德行比得上喜爱美色的人。）“吾未见刚者”（我未见过刚强的人）“吾未见好仁者，恶不仁者”，（我未见过喜好仁厌恶不仁的人）“末闻好学者”（没听说过好学的人）。这些话不也把他的三千弟子甚至七十二贤者都包括在内了吗？要让这些弟子们“无欲则刚”、“好德如好色”都不可能，更何况别人？韩非就曾刻薄尖酸地揶揄孔子，说凭着孔子那么巨大的个人德行，不就只有七十子之徒跟随他么？而下等君主鲁哀公却能让一国人都服从他，孔子本人也不得不向鲁哀公臣服。所以，人是多么容易向权势屈服，而向慕仁义的人是多么少啊。孔子此时的处境，真是令人同情。</p><p>　　但他更让我们尊敬。这就是他的那种“知其不可而为之”的殉道精神。“三军可夺帅也，匹夫不可夺志也”（三军可以更改主帅，匹夫却不能逼他改变志向）。匹夫尚且不能夺志，更何况圣人之志，得天地浩然正气，至大至刚，岂容玷污？天下一团漆黑了，不少原先追求光明的人也练就了猫头鹰的眼睛，从适应黑暗而进于喜欢黑暗，为黑暗辩护，他们把这称为提高了觉悟和认识，并且得道似的沾沾自喜于在黑森林中占据了一棵枝丫，又转过头来嘲笑别人不知变通。而孔子，这位衰弱的老人却在那里一意孤行！我很喜欢“一意孤行”这个词，很喜欢这个词所指称的那种性情与人格。敢于一意孤行的人必有大精神，大人格。</p><p>　　一位楚地的狂生曾经警告过孔子：“往者不可谏，来者犹可追。已而已而，今之从政者殆而！”（你过去糊涂就算了，以后你可改了吧！算了吧算了吧！现在追随政治危险得很啦！）但不能因为政治危险，就置天下苍生于不顾，听任他们受暴政的煎熬，置自己的伦理责任于不顾！“政者，正也”——政治，就是对暴政的矫正！就是正义！所以，孔子庄严宣告：“志士仁人，无求生以害仁，有杀身以成仁。”虽然他也说过“危邦不入，乱邦不居，天下有道则见，无道则隐”之类的话；虽然他也称赞蘧伯玉：“邦有道则仕，邦无道则卷而怀之”，宁武子“邦有道则知，邦无道则愚”，并慨叹“其知可及也，其愚不可及也”（他的聪明别人是比得上，他的糊涂别人就比不上了），大有郑板桥“由糊涂入聪明难，由聪明入糊涂尤难”的意味，但他对自己，却有更高的要求，那就是如史鱼一样，“邦有道，如矢，邦无道，如矢”，永远是如射出的箭一样，正道直行，永不回头。</p><p>　　自魏晋以后，中国的文化传统中，就有了一种极古怪的现象，那就是人格理想与伦理责任的分离。最受人敬仰的人格乃是那些在天下苦难面前卷而怀之、闭目养神的隐君子！他们的伦理关怀哪里去了？他们的道德痛苦哪里去了？作为知识分子，他们的基本人道精神哪里去了？难道我们不应该要求知识分子有起码的价值关怀吗？但我们却偏偏认为他们是涵养最高、道德最纯洁的人！鲁迅禁不住对这些人怒形于色：泰山崩，黄河溢，隐士目无见，耳无闻！这种目不关注人间苦难，耳不听弱者呻吟的人物，不就是饭桶酒囊茶壶甚至权势的尿壶么！现在不少人飘飘然地要“告别鲁迅”，却又腻歪歪地对“茶壶”周作人大为钟情。这种人是难以让人生出敬意的。一个人让人尊敬是有条件的。在孔子那里，在他的学说之中，那种古典的崇高确实让我们这些聪明机灵的后来人愈显扁平而单薄。</p></div><h2 id="三"><a href="#三" class="headerlink" title="三"></a>三</h2><div class="story post-story"><p>　　孔子的哲学核心是“仁”。在《论话》中，“仁”以不同的面目，在不同的背景下出现了无数次。这些闪烁不定的面容并不是因为孔子的“仁”没有“一以贯之”的主旨，而恰恰说明了“仁”内涵的丰富。樊迟问“仁”，孔子答曰“爱人”；颜回问“仁”，孔子答曰“克己”，曾子概括说，“夫子之道，忠恕而已”。朱熹解释说，尽自己的力量去办事叫忠，推己及人叫恕。这样看来，孔子的“仁”，也就是从人我双方立论，相当于我们今天常说的“人类共存意识”吧。</p><p>　　“仁”的内涵里，主要的两方面就是“忠”和“恕”。有了这个“忠”，就会有足够的自我约束；有了这个“恕”，就会有足够的对别人的宽容。这个顶重要了。孟子后来讲“仁”，就不大讲“恕”了，这就一步一步走向专制。孟子就没有孔子可爱。当然，孔子的“仁”，不仅仅是指一个人应当具有的人格境界，而且还应该是一个社会政治应当具有的政治理念。是公理，是正义。因而，在非常时刻应当“杀身以成仁”，而决不能”求生以害仁”。他自己一生，倡导“仁”，实践“仁”，修自身为“仁”，又要改造社会政治为“仁”。修自身成“仁”，他是做到了，改造社会政治为“仁”，他失败了。但他“颠沛必于是，造次必于是”，何曾有—丝—毫的媚俗之态！他正大光明，磊磊落落，他一意孤行，坦坦荡荡。</p><p>　　他亦知道改造社会是不可能的，但他“知其不可而为之”，关键在于做！他肯定已经意识到了他在未来的影响，所以他要用自己的行为树立一个榜样，以自己的生命之汁点亮一盏明灯，使后世一切以各种借口逃避伦理责任的行为无所遁形。——既然他已经在知其不可的情形下做了，而且做得如此艰苦，如此卓绝，如此寂寞，又如此轰轰烈烈，如此失败，又如此辉煌灿烂。因失败而辉煌，我以为这是古典悲剧的基本定律，不失败何以感人心？不辉煌何以长人志？但这失败必须是大失败，必须是必然的失败，是自由在逻辑面前的失败，是个人意志在历史规律面前的失败，而且必须是主人公已经预知的失败。他已经预先知道结局了，但高傲的心性使他无法改变自己人生的方向。在古典悲剧中，生命的投入是人格成就的最后一道工序，如干将莫邪之铸剑，最后必以自身的血肉之躯投入熔炉，用自己的血光赋予宝剑以阳刚杀气。</p><p>　　孔子的“得其真传”的弟子曾参，有一段话：“士不可不弘毅，任重而道远。仁以为己任，不亦重乎？死而后已，不亦远乎？”我无法不为这句话而感动，虽然我已经被那些最靠近话筒，因而最有发言权的某些人的这个“后”那个“后后”，还有什么“解构”，解构得没有什么完整的心智了。曾子的这段话包含着两个推论，所以我们可以把它译成问答句：士为什么要弘大坚定？因为他们任重道远。为什么说他们任重？因为他们是把仁当作自己的人生责任的；又为什么道远？因为他们除非死掉，不然就不能卸下这副担子。这就是自讨苦吃式的崇高。我上文说，让人尊敬是有条件的，不能因为你读了不少书，甚至读了不少洋文书，知道各种主义，就能受人尊敬。你还得有所承担。孔子及其弟子们，在那么—个时代，就已经意识到担当道义是知识分子的最高使命甚至无法摆脱的宿命了，就已经知道执行文化批判而不是文化媚俗文化献媚是知识分子的基本职责了，他们怎能不伟大，又怎能不为这伟大而颠沛，造次！</p><p>　　那些冷了心肠的隐士讽刺孔子，还有些愤世嫉俗的道理。而下面这位“丈人”对孔子的批评就莫名其妙了：</p><p>　　子路从而后，遇丈人。以杖荷蓧。</p><p>　　子路问曰：“子见夫子乎？”</p><p>　　丈人曰：“四体不勤，五谷不分，孰为夫子？”植其杖而芸（耘）。</p><p>　　子路拱而立。</p><p>　　止子路宿。杀鸡为黍而食之。见其二子焉。</p><p>　　……</p><p>　　子路曰：“不仕无义。……欲洁其身而乱大伦！君子之仕也，行其义也。道之不行，已知之矣。”</p><p>　　这一段中的“四体不勤，五谷不分”，后来成为不少人批评孔子的口实。是的，在一个小农意识很浓厚的国家里，这种情形较易发生，并且较易引来阵阵喝彩。甚至人们还能这样想：你孔子四肢不勤劳，五谷分不清，你连一个农夫都比不上。这种说法会引来更多的喝彩，因为很多人一下子从孔子的缺点中找回了自己的自信心。——但我要说，这种批评的荒谬性太明显了。在春秋后期，我们缺少一位农夫吗？减少一位卓越的思想家，增添一名普通的农夫，我们就是这样算账的吗？我们这个民族的历史与文化会因此更加辉煌灿烂吗？我们这个“文明古国”就会更加文明吗？</p><p>　　另外，我们民族在那个时代连养活一位像孔子这样的大思想家的经济能力都没有，还必须让他自己去耕种自存吗？或者，我们这个民族连给孔子这样的大思想家提供必要的生活条件都不愿意，而必欲使之和农夫一样才心满意足吗？这些问法可以换成现代式的：我们必须分给陈景润一块自留地，由他自己播种，收获，磨粉，蒸馒头，吃下去，然后再去桌子边求证他的哥德巴赫猜想吗？如果不是这样，他即使证出了1+2，由于他不会蒸馒头，于是我们就可以鄙夷他连一个馒头师傅都不如吗？我的这种问法不是没有道理的，二十多年前，我们就这么干过。否则，要办那么多的“干校”干什么?</p><p>　　樊迟问稼问为圃，孔子怒不可遏，甚至在背后骂他是“小人”。又有不少人说这是孔子轻视体力劳动，现在的某些大学教材上就有这种说法。这种批评也太师心自用了。问如何种菜种小麦，需要问孔子吗？孔子的回答：“我不如老农民，我不如老菜农”，已经说得很明白了：你樊迟要学这些，你何必到我这儿来？你去问老农即是。要学腌泡菜蒸馒头切土豆丝，需要去中科院生问博士生导师吗？</p><p>　　以上的问题还在于，培养一个老农易，至少在孔子那时，还不提倡科学种田时是这样。那时候就没有什么农业技术学校，但遍地是老农在种麦子种大头菜。培养一个知识分子就难了。孔子的时代，传播知识，提高人口素质，似乎比自己去亲自参加劳动更迫切。所以，孔子的这些言行，与轻视体力劳动如何扯得上。这一位“植其杖而芸（耘）”的“丈人”，耘来耘去，也就那一亩二分地，所养活的，不过就是他自己及家人。这又如何能与孔子比呢？他自己的言行能够传留后世，还是沾的孔子的光呢。孔子所耘的是什么荒？是文化之荒！所培养的是什么苗？是文化之苗！柳诒徵《中国文化史》云：</p><p>　　孔子者中国文化之中心也，无孔子则无中国文化。自孔子以前数千年之文化赖孔子而传，自孔子以后数千年之文化赖孔子而开。</p><p>　　孔子所给予我们这个民族的，甚至全世界的，又如何能估量？又如何是小农思想满脑子的人所能理喻、所能批评的？</p><p>　　所以，上述的那些对孔子的批评，让我联想到今天一些人对鲁迅的批评，以及他们莫名其妙的对于鲁迅的优胜感。鲁迅的某些缺点确实让某些人孱弱的心性得到一种自信的证明。但他们对于鲁迅的批评，恰像旧时代老爷家中感觉很幸福从而很温柔的小妾，对现代独身女性的批评；又好比是青铜时代贵族几案上的玲珑的酒器或床底下温静的溺器，对铁器时代绿林好汉手中青锋长剑的批评。</p><p>　　我对古代的隐士评价不高。相应的，我对现代的周作人及其鼓吹者们也心存怀疑。我认为，一个人，比如这几年“告别鲁迅”而麋集到周作人羽翼下的一些人，他在这个社会里占有了比别人好—些的地位、财富、机会，使他能上大学读书，能明理，他理应对这个社会有所回报，有所补偿。按我们现在的大学招生数和报考数，有一个上大学的，就必至少有一个或更多上不了大学的。这种回报与补偿就是把自己的聪明才智贡献出来，使这个社会有所进步，人们的幸福能有所增进。也就是说，他的知识应该有益于社会，而不是把这种知识当成自己的文雅的小妾。我在一篇文章里，就认为周作人是把他的学识当小妾，只让她陪自己喝茶谈玄。而如果把知识当作取媚权力的手段，就更等而下之了。另一方面，出于某种自私的目的，掩盖自己的智慧，就是对社会的背叛；隐匿自己的发现，就是对社会的犯罪——当然，这种行为在专制社会里可能是迫不得已的。</p></div><h2 id="四"><a href="#四" class="headerlink" title="四"></a>四</h2><div class="story post-story"><p>　　因为怕孔子到楚国后说陈蔡诸侯的不是，陈蔡的小政客们便把孔子围在郊野。小政客毕竟是小政客，他们把孔子围住后，却拿不准到底要怎么样。面对一位文化巨人，他们的内心毕竟很虚怯。他们很憎恨孔子文化人格的光芒，所以，他们把他包围起来，试图挡住这光芒的四射，但他们又绝没有胆量去迫近光源——于是在陈蔡之野，便有了这样一种既滑稽又尴尬的场面：里面的人出不去，外面的人也不进来。彼此都迫切希望有一个第三者出现，来给大家一个台阶下。在第三者楚昭王派兵迎接孔子之前，孔子和他的弟子们在饥肠辘辘与满脸菜色中进行一番有趣的对话，其主题是讨论道与势的关系。</p><p>　　孔子的知音司马迁在记叙这一段历险时，把孔子的人格精神写得淋漓尽致。据司马迁记载，此时的孔子，有意识地利用这次挫折，来考验、考查弟子们对道的忠诚贞定。孔子先叫来子路，问他：“难道我的主张不对吗？我为什么落得这个下场？”忠厚的子路疑疑惑惑地说：“是不是我们还不仁呢？人们不信任我们？是不是我们还不智呢？人们不放心我们？”悲愤的孔子说：“仲由啊，你听着，假使仁义的人一定受信任，怎么会有饿死首阳山的伯夷和叔齐？假使智慧的人一定行得通，怎么会有被纣王挖腹剖心的王子比干？”子贡进来了，孔子用同样的问题问他，子贡说：“老师，你的道太伟大了，所以这狭隘的世界容不了你。你能不能稍微降格以求呢？”孔子说：“赐啊，好的农夫只问耕耘不问收获，好的工匠只追求技巧而不追求苟顺人意，作为君子，修习大道，是不能讲苟合的啊。”</p><p>　　最后是颜回入见，这位比孔子小三十岁的小学生，聪慧谦让，悟性高，不爱显山露水，能过苦日子，深受孔子的喜爱。他的回答，令先生愁肠顿开：“夫子之道至大，故天下莫能容。虽然，夫子推而行之，不容何病？不容然后见君子！夫道之不修也，是吾丑也，夫道既已修而不用，是有国者之丑也。不容何病！不容然后见君子！”孔子欣然而笑，说：“说得好啊，颜家小于！将来你发财时，我给你赶车吧！</p></div><h2 id="五"><a href="#五" class="headerlink" title="五"></a>五</h2><div class="story post-story"><p>　　孔子晚年，倦于奔波。鲁迅曾在一篇颇似游戏的文字中推测孔子晚年有严重的胃病和胃下垂。一个医生对一个常年在坎坷的道路上颠簸的人很容易下这个判断。总之，孔子老了，病了，不能再奔波了，况且奔波又有什么收获呢？于是，在离开鲁国十四年之后，靠弟子冉求的疏通，又回到了鲁国故乡。此时孔子已是知命了，不说心如死灰，但心如止水却是必然的。鲁君无意用他，他也懒洋洋的不求用了。回到自己阔别多年的老屋，撩去门楣窗棂上的蛛网，拂去案几上的积尘，他坐下来，心境一片茫然。这时，外面的世界更混乱了，乱臣贼子们活得更神气了，但也令他更无奈了。宝剑折断，铩羽而归，他还能做些什么呢？他打开了竹简。这是一个有世界意义的举动。孔子现实政治活动的失败使中国少了一位晏婴、子产或管仲式的人物，但却使世界从此有了一个伟大文化的源头。这活力绵绵不绝的文化之源，浩浩荡荡，渐远渐无穷，使整个东方世界都浸润其中。是的，当孔子的现实政治活动失败后，他埋头于古代典籍的整理；在被自己的时代拒绝之后，他成功地通过文化符号进入了未来的世纪；在被几个诸侯国的诸侯和政客拒绝后，他的影响力却遍及全世界，名声响彻天下。</p><p>　　孔子本来是想通过立功来传名后世的，像他终生倾慕的周公一样。但这一点已经毫无疑问地没有可能了。“君子疾没世而名不称焉！”（君子很惧怕死后没有名声留传啊）于是他便想通过立言来不朽。我们知道，在这一点上，他成功了，而且在立言中他还立了德。“三不朽”他完成了两项。据司马迁的记载，“六经”都是经他手订的。也正因了他的手，这些积满时光尘土的古典才成为“经”，而为后世不断地钻研，又在这不断的琢磨中发出历久弥新的光芒。</p><p>　　那本“饥者歌其食，劳者歌其事”的三百零五首“诗”，记录着那么遥远时代的真切的痛苦，更是因为他的手订，由愚夫愚妇引车卖浆者流的歌吟一跃而成为六经之首，“子曰”与“诗云”并称。实际上，就是因为“孔子曰”，孔子的赞誉，《诗》中愚夫愚妇们的“云”，才成为中国古代文学的圣经。他对这三百首《诗》说过些什么呢？他和子夏讨论过“巧笑倩兮，美目盼兮”；他和子贡讨论过“如切如磋，如琢如磨”；他说：“不学《诗》，无以言”，他还说，“《诗》可以怨”！他把《诗》当作教材，传授给弟子们，正是因为这种口耳相传式的传授，才使得《诗经》能避开暴君赢政的焚书之火和莽汉项羽的复仇之火，斯文不灭。他还庄重地为《诗》回护，说：“《诗》三百，一言以蔽之，曰思无邪！”这就使后世很多对《诗经》暗怀不满的人，比如朱熹，只能做些鬼鬼祟祟的歪曲的勾当。孔子是文学的守护神呢。原来他不仅是一位庄严谨恪的人，还是一位情感丰富的人！因此，他不仅要求人类要有道德，就是对人类的情感——包括对人性的弱点，他也有那么多善意的回护与爱惜！他要人们好德，但也不反对人们好色，“国风好色而不淫”，不过分，就行了嘛。</p><p>　　说到这里，插入一件小事。跟孔子学语言修辞的子夏，有一个毛病，那就是吝啬。知生莫如师，孔子深知子夏这一毛病，于是就刻意为他遮掩。一次孔子出门，碰上下雨，而子夏有伞，孔子却不去借，甘冒雨淋之苦。有人问孔子为何不问子夏借伞，孔子说，子夏有这个小毛病，若向他借伞，借，他心里不痛快；不借，不是把他的缺点暴露给众人了吗？如果能掩盖住别人的缺点，我淋点雨算什么呢？</p><p>　　文学是人学，文学就是人性的表现。不能对人性的优点有极崇高的敬意，对人性的弱点有极宽厚的怜悯，是不可能理解文学的。我们再举一个相反的例子，朱熹。对这个人我老实说没有一丝一毫的好感。且不说他的那一套“存天理，灭人欲”的理论是多么仇视人性，我只想举他对《诗经》中一首诗的评论来说说。《诗经·卫风》中有一首诗叫《氓》，是一位被遗弃女子的哀歌。这个女子坚持要明媒正娶地嫁给她所爱的男人（这就是“乐而不淫”），做了妻子后她辛勤贤慧，但最后还是被抛弃了，即便这样，她也依然那么理智，节制，哀而不伤，怨而不怒。老实说，我读到这首诗的最后“亦已焉哉”（唉，算了吧），是颇失望的，我私下里希望她能报复对方一下。我知道这种想法不对，既不合法也不合理，但我觉得这才合情。美狄亚就实施了惨烈的报复么。孔子也提倡“以直报怨”么。但朱熹对这个不幸女子的评论，使我觉得他很卑鄙，很没有人性。他说：“此淫妇为人所弃，自叙其事以道其悔恨之意也”（这个淫荡的女子被别人始乱终弃了，自己追叙自己的所作所为，倾吐出悔恨之意）”读到这样的议论如果不觉得朱熹卑鄙下流，就不是正派人。因为朱熹凭空污人清白（在这首诗中一点也看不出这个女子有什么淫荡的地方）；他对一位多情的恋人（婚前）一个贤淑的妻子（婚后）毫无首肯之意，理学家之不懂欣赏女人，于此可见一斑，而理学家之仇视—切鲜活的女性，对人间痛苦毫无同情心也在此原形毕露。这些只知“以理杀人”的后儒们，他们何曾及得上孔子的一分—毫啊。</p><p>　　由于孔子丰富的文学情怀，他把人格修养的最高境界理解为一种自由的艺术境界，而不是严谨的道德境界。在这一点上他又和后世的道德家们大相径庭。我们也一直没注意这一点。孔子在道德的熔炉里冶炼自己，而最后出炉的结果却大出我们意料：他熔炼出的不是森森剑戟，而是更加的幽默生动。你看他说的：“志于道，据于德，依于仁，游于艺”，又说“兴于诗，立于礼，成于乐”。他最后的形象是“成于乐”而“游于艺”！他一下子变得亲近了，不再壁垒森严了。你看他：“闻《韶》，三月不知肉味”，这时他能是一位皱着眉头板着面孔不苟言笑的人么？他是一位手之舞之、足之蹈之的老顽童哩！他极爱音乐，即便在围困之中，也是每日“弦歌不衰”，只要附近没死丧，他每日都大声地唱歌。司马迁的《孔子世家》中记载了孔子与音乐的一件轶事：他在师襄子那里学了一首曲子，一连弹了十数天还不换其他曲子，直到他从这首曲子里“听”出了那个肤色黝黑、身材顾长、眼神忧郁的文王的形象！“作《易》者，其有忧患乎！”文王可不就是一个满腹忧患的古之高人么？孔子的精神通过飞翔的音符而与之相通了！</p><p>　　有这样的音乐修养与音乐情怀，“三百五篇孔子皆弦歌之。”这是多么宏伟壮丽的大乐章啊。我们今天已经不能再聆听孔子弦歌过的音乐了，“此曲只应天上有，人间哪得几回闻”。但那古老而简朴的文字仍留传下来，那远古时代活生生个体的欢乐与哀伤，希望与失望，怨愤与爱慕……仍然如此鲜活，是的，那远古的神经末梢仍在向我们传来敏锐而清晰的刺痛……</p><p>　　《诗经》中有一百六十首都是采自民间，包括黄河流域，汉水、汝水流域。我们可以由此贴近这片辽阔土地上的风、水、丘陇与庄稼，贴近这片土地上的阳光、情感、悲欢与离合。班固与何休都提到当时有专门采诗的行人，摇着木铎顺着乡间小道去采诗。我有时痴想，没有比这更好的职业了。如果我在那时，我一定做个采诗者。不采诗还干什么呢？还有什么比这更快乐的工作呢？</p><p>　　——冬日的蛰居过去了，春光融融，芳草萋萋。我立于道口，望农夫荷锄远来，而他的歌声亦悠扬而感伤……</p><p>　　我在村落间徘徊，看顽童嬉闹；我亦走上田头，看麦苗油油，静观灌溉之水汩汩流淌。</p><p>　　多忧伤的故事啊。有一个人因想念远方的恋人而去了，从此杳无音信；一位多情的女子被人遗弃了，哭泣着回到娘家；而服役归来的人，拄杖立于田头，他的家园已成一片废墟，丘垄上葬着他的亲人……</p><p>　　在还处飘来的歌声面前，我老泪纵横。</p><p>　　我是被《诗经》感动了。最幸福的时候就是被感动的时候。谁能说当孔子对这三百零五首诗逐一弦歌时，他不也是感怀万端呢？“四方有羡，我独居忧。民莫不逸，我独不敢休”（《十月之交》），这样的句子，如此贴切他忧患人生的情怀，如此真切地反映他奔波为天下的辛苦，他能不感慨吗？而那一位走过周朝旧都，面对废墟上的野黍而“中心摇摇”悲不自禁的诗人，不更是他的同调吗？面对伟大朝代的文化废墟，他不更是忧患满怀吗？“知我者谓我心忧，不知我者谓我何求。悠悠苍天，此何人哉？”（《黍离》），是啊，孔子，他是—位什么样的人呢？</p></div><h2 id="六"><a href="#六" class="headerlink" title="六"></a>六</h2><div class="story post-story"><p>　　《尚书》之流传具有传奇色彩，我们今天读到的本子乃是东晋豫章内史梅赜所献的《孔传古文尚书》。这个“孔”字乃是孔安国，司马迁的老师。他也是孔子的十一代孙。而这个孔安国所传的《尚书》，乃是汉鲁共王从孔子故居的墙壁中得到的。光这—点，就可知孔子与《尚书》之关系了。</p><p>　　如果说《诗经》是中国历史上最早的诗歌总集，那么，作为“上古之书”的《尚书》乃是中国历史上最早的散文集。同时，如果说《诗经》是民间的（风、雅都可以算作是民间的），那么《尚书》就是朝廷的。《诗》是民间的情感，《书》是朝廷的意志。《诗》是抒情的，《书》是理智的。《诗》是散漫的，《书》是约束的。</p><p>　　《诗》唱个性感受，《书》倡国家价值。《诗》是艺术，《书》是道德。《诗》是大地，是天空，是大地上的野花，是天空中的飞鸟；《书》是庙宇，是碑石，是庙宇中的祖训．是碑石中的缄言。《诗》是音乐《书》是建筑，谢林说，音乐是流动的建筑，建筑是凝固的音乐。没错，《诗》是意志的流动，《书》是情感的凝固……我们民族最古老最本质的东西，都积淀在《诗》、《书》之中了。它们都与孔子有关。</p><p>　　《易》据说最初乃是“大墙文化”，乃是周文王为商纣所拘押，在狱中无聊，又担心自己就此玩完，“没世而名不称”，推演而成。但文王的《周易》，纯属卜筮之书，对一般读者不啻天书。“孔子晚而喜易，序《彖》，《系》，《象》，《说卦》，《文言》，谈《易》，韦编三绝”（《史记》）。他的研究成果，经口授学生，学生整理成册，始有“十翼”，翼者，辅翼，辅助理解也。应该说，孔子是把卜筮之书改造成了哲学之书，综合天地人，探究天道人道，从“究天人之际，通古今之变”而“成一家之言”。所以，就《易》在这个意义上影响中国传统文化，我们又是在这个意义上理解《易》，毋宁说，《易》乃是孔子的著作了。孔子晚年，一边穷年兀兀以研《易》，一边却又担心时不我与，叹息道：“假我数年，若是，我于《易》则彬彬矣”。天不灭斯文，孔子而后，《易》果然彬彬而盛。“易者，易也，不易也。”这截然不同却又相辅相承的训释，恰好表明了天道人道的反复，变与不变的统一。《诗经》说：“鸢飞戾天，鱼跃于渊”（《早鹿》）《易》言：“天行健，君子以自强不息”“天地之大德曰生”，这是一个生机盎然蓬勃如斯的宇宙，这也是一个满腹忧患、自强不息的人生！</p><p>　　《礼》《乐》亦是孔子的教化工具。孔子对枯燥乏味的周代官制、礼仪的记录《仪礼》进行研究，指出其内涵、作用与本质。这一切都不过是“托古改制”而已。孔子说：“夫礼，先王以承天之道，以治人之情”，仍然是天道与人道。伟大的周公盛世初建，创建周礼，规范一个大帝国的行为与思想，开创了灿烂的周文化；伟大的孔子身当乱世，礼崩乐坏，他所做的，乃是在文化废墟上的考古、整理与保存。帝国的庞大躯体，已然僵仆，他已不能使之复生，他能做的乃是使帝国的精神与文化长存人间。他所唱的，乃是伟大文化的挽歌，世运不可回，人事有兴替，挽歌者，挽留之歌也！</p><p>　　在《礼运》的记载中，孔子根据可考历史的发展情况，预见着未来的道路。他认为，人类社会之发展经历着三个阶段：据乱世，升平世和太平世。据乱世就是他所处的时代了，而他为后人设想的“太平世”是什么样子呢？<br>　　天下为公，选贤与能，讲信修睦。故人不独亲其亲，不独子其子。使老有所终，壮有所用，幼有所长，鳏寡、孤独、废疾者皆有所养；男有分，女有归。</p><p>　　谁说孔子只是向后看呢？他也展望未来啊！只是这位衰弱的老人自知自己是等不到那黄河清的一天了！</p><p>　　《乐记》也还是在谈哲学，谈政治：</p><p>　　(音乐)清明象天，广大象地。终始象四时，周还象风雨……乐行而伦清，耳目聪明，血气和平，移风易俗，天下皆宁。</p><p>　　好像不能一味指责孔子把文艺都搞成道德教化，都搞成政治蓝图。你看他所处的是什么时代？一个“仁以为己任”的思想家，他不关心天下不宁，还关心什么？他不祈望天下皆宁并为之奋斗，他还祈望什么？让他回到家里，关上门，温壶春酒，泡杯苦茶，弹琴逍遥吗？</p><p>　　最后就要谈到《春秋》了。这是使一个时代都因此而得名的著作。</p><p>　　晚年的孔子顾视日影，喟然叹息：“不行啊不行啊，君子很惧怕死后没有留下名声啊。我的道行不通了，我凭什么在后世传名呢？”他搬来鲁国历代太史记录的史料，开始著作历史。以前在做官审案时，他很谦虚地与其他陪审官商定判辞，而此时他却突然“专断”起来，“笔则笔，削则削，子夏之徒不能赞一辞”。连插嘴提建议的机会都不给！这本以“微言大义”著称的历史著作，孔子是有意把它写成政治学著作、伦理学著作的！他在这里要审判的，是整个历史！而且他所进行的不止是历史批判，更重要的倒是他的政治批判与道德批判！他希望他的这本书能成为人的道德准则，更希望它能建立一种合理有序的政治运行法则。这就是这本书使“乱臣贼子惧”的原因。</p><p>　　孔子在给弟子们讲授《春秋》时感慨地说：“后世知丘者以《春秋》，而罪丘者亦以《春秋》。”丘吉尔说，影响历史的最好方法就是写历史，“春秋”以后的历史，不都受着《春秋》的影响么？孔子一直在参与着历史进程啊。只是他本人没有到场罢了，对后来的历史而言，他只是一个缺席者。</p></div><h2 id="七"><a href="#七" class="headerlink" title="七"></a>七</h2><div class="story post-story"><p>　　我认为，孔子最伟大的贡献乃是他的“私学”。最初开办私学的人未必就是孔子，但把私学办成传授文化、培养人格、培养知识阶层的场所，则毫无疑问是孔子。正是在他的私学里，才出现了中国历史上第一批真正意义上的知识分子。——这些人既不是世袭贵族，也不是后来的科举士大夫，他们不是官僚机构中的成员。他们是那时代冒出来的“新人”，名称叫“士”，后来孟子宣称“大德者不官不王”，魏文侯之师田子方宣称“行不合，言不用，则去之楚越，如脱屦然。”可以见出这些人的傲慢与偏见——对诸侯的傲慢是那么显眼，对学问的偏见又是那么深固。</p><p>　　谁培养了这一批特行独立的知识分子？是孔子。上引的孟子与田子方都是孔门后学。所以，孔子的私学促成了文化的独立，文化由权势者股掌之间的小妾，蜕变为特行独立的汉子，“大丈夫”（孟子语）。这种文化不以取悦权势换得宠爱为目的，而以社会批判为天职。文化而以社会批判为天职，这就是文化的本质属性了。谁赋予了文化这种本质属性？是孔子。对于世俗政权而言，权力体制自身的制衡是必要的，重要的；而文化批判所产生的文化制衡尤其重要。中国后来漫长的封建社会里，之所以没能在权力体制之中产生制衡，这与封建政权把文化纳入权力体制，取消其独立性，否定其文化批判的必要性合理性有极大的关系。也就是说，当我们否定了文化批判之后，权力内部的制衡也就相应的被消解。官僚系统之内的权力制衡是为了政府及其各职权部门行为的合法有序及防止权力滥用；而文化批判所产生的制衡则是保证整个社会的行为合乎人性，合乎理性。孔子以后的百家私说，不都是在这个意义上讨论世俗政权的合理性么？</p></div><h2 id="八"><a href="#八" class="headerlink" title="八"></a>八</h2><div class="story post-story"><p>　　孔子曾描述过自己的形象，“学而不厌，诲人不倦，不知老之将至”。在他的身边，一批勤奋好学安贫乐道的年轻人在成长着。看看这些蓬勃的春花，他真的就想不到自己已是秋天的一枚黄叶？这句话我看应该这么理解，正是因为知道自己老冉冉而将逝，才抱定“朝闻道，夕死可矣”的信念与日逐走，学而不厌。同时又把自己的心得传授给弟子们，诲人不倦他已是明白地知道，自己来日无多了！鲁迅晚年自知不久于人世，便一再告诫自己要“赶紧做”。孔子也是在与自己的生命赛跑，赶紧做呵。“天下无道久矣，而莫能宗予，”他已无力回天了，“道不行，乘桴浮于海”，他要离开我们去那道山了！</p><p>　　颜渊死了，他的精神受到沉重的打击。“天丧予！天丧予！（天要灭我，天要灭我啊！）安贫而乐道的颜回死于贫困，死后连棺材也没有。孔子为之深深恸哭。“我不为他哭还为谁哭呢？”他越来越老了，世道也越来越混乱了，不久，有消息传来，仲由死在卫国了，正中了孔子以前的忧心忡忡的预言：“不得其死”，被人剁为肉酱。仲由是众弟子中唯一敢于冲撞他的学生，小他九岁，总是雄纠纠的样子。孔子知道这个有些粗野的弟子其实最为忠厚义气，他还曾设想，当他远遁人世时，让仲由跟随着他。可现在又死在他前面了。他已经多次承受着这白发人送黑发人的惨痛了。他的心境更为凄凉了。做生意的端木赐（子贡）来看他，给老师一些周济，他正拄着拐杖在门外看西山的落日，那落日如血的余辉最后一次染红大地与天空。孤独的孔子问端木赐：“赐啊，你为什么到现在才来看我呢？”接着便低吟了一首绝命歌，那简单的字句和厚重的内涵使人想到宇宙中最简单而又最本质的哲理，人间的生死竟也牵动着宇宙的毁成：</p><p>　　太山坏乎！</p><p>　　梁柱摧乎!</p><p>　　哲人萎乎！</p><p>　　圣人洒泪而尽了。带着他的雄心去了。如蜡烛最后一次耀眼的一跳，熄灭了。天地之间，一片黑暗。但，也就是从那一刻起，他不再仅属于一个时代，而属于千秋万代！</p><p> 　　痴人有多种，或因情深而痴，或因智浅而痴，孔子属于前者，而他的很多徒子徒孙，如宋明之际的理学家们，就属于后者了，新儒家们当更是等而下之。因情而痴的孔子常常沉湎在过去的怀想之中，“郁郁乎文哉!吾从周：”“逝者如斯夫!”这时，他就是一位抒情者，抒得很动情，很感人。在一个抽象的、冷酷的、沉闷的老子之后，出现一个一往情深、感怀万端的孔子，使我们再次感受到一种温软，一种熨帖，这实在是让我们大大舒了一口气，历史终于在绝望中咧口而哭出了声，一些可怕的心理能量在孔子的歌哭、幽默、感喟中被释放了。孔子使一些无序的暴力变成了有目的、有方向的努力与企望，他使天下英雄人于他的彀中，带着这些社会精英致力于建构新的理想。当混乱的历史有了理想与方向时，混乱就不再是一无是处，相反，倒往注显示出一种蓬蓬勃勃、生机无穷的魅力。</p><p>　　春秋战国时代是一个刀光剑影的时代，一个流血漂橹的时代，一个杀人盈城、杀人盈野的时代，但它不也是一个充满理想、充满激情，充满公理仁德的时代吗?谁开辟了这样的时代?是孔子！非常具有象征意义的是，当孔子子和弟子们周游列国的时候，他往往自己驾车一一他确实是在驾着这个时代的马车。弟子们在车上或呼呼大睡或哈欠连天．一脸凄迷与怀疑。只有他永远目光炯炯，自信目标就在前方。</p><p>　　有一次。在一条汤汤而流的小河边。他们又找不到渡口了。远处的水田中有两人在耕作，子路便上前去打问。其中的一个细长个子却不回答子路的询问，而是反问子路：</p><p>　　“那个执缰绳的人是谁？”</p><p>　子路恭敬地回答：“是孔丘。”</p><p>　　“是鲁国的那个孔丘吗?”——可见孔子的知名度颇高。</p><p>　　子路答：“是。”这个细高个冷冷地就来了一句：“既然是鲁国的那个孔丘，他应该知道渡口在哪里嘛。”</p><p>　　没奈何，已经由绿林好汉改邪归正到孔子门下的子路，只能捺住火气，转过身去问另一位。这一位魁梧雄桀，是个大块头。大块头也反问子路：“你是谁?”</p><p>　　子路仍然是恭敬地回答：“我是仲由。”</p><p>　　“你是孔丘的门徒吗?”</p><p>　　“是。”</p><p>　　现在又轮到大块头来教训子路了：“天下混乱，举世皆然。谁能改变这种局面?我看你身体强壮，是个好庄稼汉。与其跟随孔子这样的避人之士东奔西走，鼓唇摇舌，倒不如跟随我们这些避世之士，躬耕垄亩的好!”</p><p>　　这里我先解释两个词。什么叫“避人”呢?避人就是择人，就是避开那些昏庸无道的诸侯，而去寻找志同道合的有为之君，一同来重整乾坤。良禽择木而栖，贤才择主而事嘛，不择主，只要给富贵就帮他卖力，那是苏秦张仪的作为。孔子一心要的是救世，而不是个人富贵，所以他栖 惶惶的马车在纵横阡陌间奔走扬尘，就是要避开身后的昏君而去寻找前面的明君。什么是“避世”?在“避人”的基础上再跨一步，彻底冷了心，闭了眼，认定天下不可能有什么诸侯还能与他一起改变这世界，于是彻底绝望，从而彻底不抱希望，回到田园中去，回到自己的内心中去，告别都市、政治与熙熙攘攘的外部世界，就叫避世。</p><p>　　再回头说子路被这两人教训得一楞一楞的，又要注意自己此时的身份，不能发作，只好垂头丧气地回来向孔子汇报。孔子听完。不尽的迷悯。谁说这两位隐士说得不对呢?这不也是孔子自己内心中常有的感触吗?但他历尽艰辛，学而不厌，“十年磨一剑，霜刃未曾试”，难道就此卷而怀之吗?他有教无类，诲人不倦。门徒三千，贤者七十二，就是为了培养一批隐士，或者懂文化的农夫吗?于是他感慨万端：“人总不能与乌兽一起生活在山林之中啊，我不和芸芸众生生活在一起，与他们共享欢乐共担不幸，我又能和淮生活在一起呢?他们说天下无道，但不正因为天下混乱无道，才需要我们去承担责任吗?假如天下有道，还需要我们吗?”</p><p>　　《论语》中的这一段，很传神，两干多年了，那条汤汤小河边发生的这场争论就好像发生在昨天似的。这几个人好像还在我们身边。我尤其为孔子感动。惜惶而寂寞，迷悯而执拗。“志于道”的人越来越少了，不少人顺应潮流，从而成了新贵，或成为新贵的红人，其中甚至有他的门徒，比如那个顶善于察言观色的弟子冉求。又有不少人冷了心，折断宝剑为锄犁，平戎策换得种树书，如长沮，桀溺；其中也有他的弟子，如樊迟。樊迟向他稼、问为圃，大概也是准备避世了吧。望望眼前。路漫漫其修远今，看看身后，追随者渐渐寥落。”道不行，乘俘浮于海，从我者，其由与!”(道行不通了，我只能乘小船漂荡到大海中去了。到那时还能跟随我的、可能只有一个仲由了吧!)这位可敬可叹的老人，想凭自己个人的德行与魅力来聚集一批年轻人，让他们传道义之火，文化之火；拯民于水火，匡世于既颠，但年轻人不容易经受得了各种诱惑，“吾未见好德如好色者’’(我从未见过一个喜爱德行比得上喜爱美色的人)“吾未见刚者”(我未见过刚强的人)“吾未见好仁者，恶不仁者”(我未见过喜好仁厌恶不仁的人)“末闻好学者’’(没听说过好学的人)。这些话不也把他的三千弟子甚至七十二贤者都包括在内了吗?要让这些弟子们“无欲而刚”“好德如好色”都不可能，更何况别人?韩非就曾刻薄尖酸地椰榆孔子，说凭着孔子那么巨大的个人德行，不就只有七十子之徒跟随他么?而下等君主鲁哀公却能让一国人都服从他，孔子本人也不得不向鲁哀公臣服。所以，人是多么容易向权势屈服，而向幕仁义的人是多么少啊。孔子此时的处境，真是令人同情。</p><p>　　但他更让我们尊敬。这就是他的那种“知其不可而为之”的殉道精神。“三军可夺帅也，匹夫不可夺志也”(三军可以更改主帅、匹夫却不能逼他改变志向)。匹夫尚且不能夺志，更何况圣人之志，得天地浩然正气，至大至刚，岂容站污?天下一团混黑了，不少原先追求光明的人也练就了猫头鹰的眼睛，从适应黑暗而进于喜欢黑暗，为黑暗辩护，他们把这称为提高了觉悟和认识，并且得道似的沾沾自喜于在黑森林中占据了一棵枝丫，又转过头来嘲笑别人不知变通。而孔子，这位衰弱的老人却在那里一意孤行!我很喜欢“一意孤行”这个词，很喜欢这个词所指称的那种性情与人格。敢于一意现行的人必有大精神、大人格。一位楚地的狂生曾经警告过孔子：”往者不可谏，来者犹可追。已而已而，今之从政者殆而!”(你过去糊涂就算啦，以后你可改了吧：算了吧算了吧．现在追随政治危险得很啦：)但不能因为政治危险，就置天下苍生于不顾，听任他们受暴政的煎熬，置自己的伦理责任于不顾！“政者，正也”—一政治，就是对暴政的矫正：就是正义！所以孔子庄严宣告：“志士仁人，无求生以害仁，有系身以成仁。”虽然他也说过：“危邦不入，乱邦不居，天下有道则见，无道则隐’’之类的话；虽然他也称赞遽伯玉“邦有道则仕。邦无道则可卷而怀之”，宁武子“邦有道则知，邦无道则愚”、并慨叹“其知可及也，其愚不可及也”(他的聪明别人能比得上，他的糊涂别人就比不上了)，大有郑板桥“由糊涂入聪明难，由聪明人糊涂尤难”的意味，但他对自己，却有更高的要求，那就是如史色一样，“邦有道，如矢，邦无道，如矢”，永远是如射出的箭一样、正道直行，永不回头。</p><p>　　自魏晋以后。中国的文化传统中，就有了一种极古怪的现象，那就是人格理想与伦理责任的分离。最受人敬仰的人格乃是那些在天下苦难面前卷而怀之，闭目养神的隐君子!他们的伦理关怀哪里去了?他们的道德痛苦哪里去了?作为知识分子，他们的基本人道精神哪里去了?难道我们不应该要求知识分子以起码的价值关怀吗?但我们却偏偏认为他们是涵养最高，道德最纯洁的人!鲁迅禁不住对这种人怒形于色：秦山崩，黄河溢，隐士目无见，耳无闻!这种目不关注人间苦难，耳不听弱者呻吟的人物，不就是饭捅酒囊茶壶甚至权势的尿壶么!现在不少人飘飘然地要“告别鲁迅”，却又腻歪歪地对“茶壶”周作人大为钟情。这种人是难以让人生出敬意的。一个人让人尊敬是有条件的。在孔子那里，在他的学说之中，那种古典的崇高确实让我们这些聪明机灵的后来人愈显扁平而单薄。</p><p>　　孔子的哲学核心是“仁”。在《论语》中，“仁”以不同的面目，在不同的背景下出现了无数次。这些闪烁不定的面容并不是因为孔子的“仁’’没有“一以贯之’’的主旨，而恰恰说明了“仁”内涵的丰富。樊迟问“仁”，孔子答曰“爱人”；颜回问“仁”，孔子答曰：“克己”，曾子概括说，“夫子之道，忠恕而已”。朱熹解释说，尽自己的力量去办事叫忠，推己及人叫恕。这样看来，孔子的“仁”，也就是从人我双方立论，相当于我们今天常说的“人类共存意识”吧。“仁”的内涵里，主要的两方面就是“忠”和“恕”。有了这个“忠”，就会有足够的自我约束；有了这个“恕”，就会有足够的对别人的宽容。这个顶重要了。孟子后来讲“仁”，就不大讲“恕”了，这就一步一步走向专制。孟子就没有孔子可爱。当然，孔子的“仁”，不仅仅是指一个人应当具有的人格境界，而且还应该是一个社会政治应当具有的政治理念。是公理，是正义。因而，在非常时刻应当“杀身以成仁”，而决不能“求生以害仁”。他自己一生，倡导“仁”，实践“仁”，修自身为“仁”，又要改造社会政治为“仁”。修自身成“仁”，他是做到了，改造社会政治为“仁”，他失败了。但他“颠沛必于是造次必于是”，何曾有一丝一毫的媚俗之态!他正大光明，磊磊落落，他一意孤行，坦坦荡荡。他亦知道改造社会是不可能的，但他“知其不可而为之”，关键在于做!他肯定已经意识到了他在未来的影响，所以他要用自己的行为树立一个榜样，以自己的生命之汁点亮一盏明灯，使后世一切以各种借口逃避伦理责任的行为无所遁形。——既然他已经在知其不可的情形下做了．而且做得如此艰苦，如此卓绝，如此寂寞，又如此轰轰烈烈，如此失败，又如此辉煌灿烂。因失败而辉煌，我以为这是古典悲剧的基本定律，不失败何以感人心?不辉煌何以长人志?但这失败必须是大失败，必须是必然的失败，是自由在逻辑面前的失败，是个人意志在历史规律面前的失败，而且必须是主人公已经预知的失败。他已经预先知道结局了，但高傲的心性使他无法改变自己人生的方向。在古典悲剧中，生命的投人是人格成就的最后一道工序，如干将莫邪之铸剑，最后必以自身的血肉之躯投入熔炉，用自己的血光赋予宝剑以阳刚杀气。孔子的“得其真传”的弟子曾参，有一段话：“士不可不弘毅，任重而道远。仁以为己任，不亦重乎?死而后巳，不亦远乎?”我无法不为这句话而感动，虽然我已经被那些最靠近话筒，因而最有发言权的某些人的这个“后”那个“后”，还有什么“解构”，解构得没有什么完整的心智了。曾子的这段话包含着两个推论，所以我们可以把它译成问答句：士为什么要弘大坚定?因为他们任重道远。为什么说他们任重?因为他们是把仁当作自己的人生责任的；又为什么道远?因为他们除非死掉，不然就不能卸下这副担子。这就是自讨苦吃式的崇高。我上文说，让人尊敬是有条件的，不能因为你读 了不少书，甚至读了不少洋文书，知道各种主义，就能受人尊敬。你还得有所承担。孔子及其弟子们，在那么一个时代，就已经意识到担当道义是知识分子的最高使命甚至无法摆脱的宿命了，就已经知道执行文化批判而不是文化媚俗文化献媚是知识分子的基本职责了，他们怎能不伟大，又怎能不为这伟大而颠沛，造次!</p><p>　　那些冷了心肠的隐士讽刺孔子，还有些愤世嫉俗的道理。而下面这位“丈人”对孔子的批评就莫名其妙了：</p><p>　　子路路从而后，遇丈人。以杖荷條。</p><p>　　于路问曰：“子见夫子乎?”</p><p>　　丈人曰：“四体不勤，五谷不分，孰为夫子?”植其杖而罢(耘)。</p><p>　　子路拱而立。</p><p>　　止子路宿。杀鸡为泰而食之。见其二于焉。</p><p>　　子路曰：“不仕无义。……欲洁其身而乱大伦!君子之仕也，行其义也。道之不行，已知之矣。”</p><p>　　这一段中的“四体不勤，五谷不分”，后来成为不少人批评孔子的口实。是的，在一个小农意识很浓厚的国家里，这种情形较易发生，并且较易引来阵阵喝彩。甚至人们还能这样想：你孔子子四肢不勤劳，五谷分不清，你连一个农夫都比不上。这种说法会引来更多的喝彩，因为很多人一下子从孔子的缺点中找回了自己的自信心。——但我要说，这种批评的荒谬性太明显了。在春秋后期，我们缺少一位农夫吗?减少一位卓越的思想家，增添一名普通的农夫，我们就是这样算账的吗?我们这个民族的历史与文化会因此更加辉煌灿烂吗?我们这个“文明古国”就会更加文明吗?另外，我们民族在那个时代连养活一位像孔子这样的大思想家的经济能力都没有，还必须让他自己去耕种自存吗?或者，我们这个民族连给孔子这样的大思想家提供必要的生活条件都不愿意，而必欲使之和农夫一样才心满意足吗?这些问法可以换成现代式的：我们必须分给陈景润一块自留地，由他自己播种，收获，磨粉，蒸馒头，吃下去，然后再去桌子边求证他的哥德巴赫猜想吗?如果不是这样，他即使证出了l十2，由于他不会蒸馒头，于是我们就可以鄙夷他连一个馒头师傅都不如吗?我的这种问法不是没有道理的，20多年前．我们就这么干过。否则，要办那么多的“干校”干什么?</p><p>　　樊迟向他问稼问为圃，孔子怒不可遏，甚至在背后骂他是“小人”。又有不少人说这是孔子轻视体力劳动，现在的某些大学教材上就有这种说法。这种批评也太师心自用了。问如何种菜种小麦，需要问孔子吗?孔子的回答是“我不如老农民，我不如老菜农”，已经说得很明白了：你樊迟要学这些，你何必到我这儿来?你去问老农即是。要学腌泡菜蒸馒头切土豆丝，需要去中科院问博士生导师吗?</p><p>　　以上的问题还在于，培养一个老农易，至少在孔子那时，还不提倡科学种田时是这样。那时候就没有什么农业技术学校，但遍地是老农在种麦子种大头菜。培养一个知识分子就难了。孔子的时代，传播知识，提高人口素质，似乎比自己去亲自参加劳动更迫切。所以，孔子的这些言行，与轻视体力劳动如何扯得上。这一位“植其杖而芸(耘)”的“丈人”，耘来耘去，也就那一亩二分地，所养活的，不过就是他自己及家人。这又如何能与孔子相比呢?他自己的言行能够传留后世，还是沾的孔子的光呢。孔子所耕耘的是什么荒?是文化之荒!所培养的是什么苗?是文化之苗!柳绐徵《中国文化史》云：”孔子者中国文化之中心也，无孔子则无中国文化。自孔子以前数千年之文化赖孔于而传，自孔子以后数千年之文化赖孔于而开。”</p><p>　　孔子所给予我们这个民族的，甚至全世界的，又如何能估量?又如何是小农思想满脑子的人所能理喻、所能批评的?</p><p>　　所以，上述的那些对孔子的批评，让我联想到今天一些人对鲁迅的批评，以及他们莫名其妙的对于鲁迅的优胜感。鲁迅的某些缺点确实让某些人民弱的心性得到一种自信的证明。但他们对于鲁迅的批评，恰像旧时代老爷家中感觉很幸福从而很温柔的小妾，对现代独身女性的批评；又好比是青铜时代贵族几案上的玲珑的酒器或床底下温静的溺器。对铁器时代绿林好汉手中青锋长剑的批评。</p><p>　　我对古代的隐士评价不高。相应的，我对现代的周作人及其鼓吹者们也心存怀疑。我认为，一个人，比如这几年“告别鲁迅”而庚集到周作人羽翼下的一些人，他在这个社会里占有了比别人好一些的地位、财富、机会，使他能上大学读书，能明理，他理应对这个社会有所回报，有所补偿。按我们现在的大学招生数和报考数，有一个上大学的，就必有一个或更多上不了大学的。这种回报与补偿就是把自己的聪明才智贡献出来，使这个社会有所进步，人们的幸福能有所增进。也就是说。他的知识应该有益于社会，而不是把这种知识当成自己的文雅的小妾。我在一篇文章里，就认为周作人是把他的学识当小妾，只让她陪自己喝茶谈玄。而如果把知识当作取媚权力的手段，就更等而下之了。另一方面，出于某种自私的目的．掩盖自己的智慧。就是对社会的背叛：隐匿自己的发现，就是对社会的犯罪——当然．这种行为在专制社会里可能是迫不得已的。</p><p>　　孔子晚年，倦于奔波。鲁迅曾在一篇颇似游戏的文字中推测孔子晚年有严重的胃病和胃下垂。一个医生对一个常年在坎坷的道路上颠簸的人很容易下这个判断。总之，孔子老了，病了。不能再奔波了，况且奔波又有什么收获呢?于是，在离开鲁国十四年之后，靠弟子冉求的疏通，又回到了鲁国故乡。此时孔子已是知命了，不说心如死灰。但心如止水却是必然的。鲁君无意用他。他也懒洋洋的不求用了。回到自己阔别多年的老屋。撩去门楣窗棂上的蛛网，拂去案几上的积尘，他坐下来，心境一片茫然。这时，外面的世界更混乱了。乱臣贼子们活得更神气了。但也令他更无奈了。宝剑折断．铩羽而归，他还能做些什么呢?他打开了竹简。这是一个有世界意义的举动。孔子现实政治活动的失败使中国少了一位晏婴、子产或管仲式的人物，但却使世界从此有了一个伟大文化的源头。这活力绵绵不绝的文化之源，浩浩荡荡，渐远渐无穷，使整个东方世界都浸润其中。是的，当孔子的现实政治活动失败后．他埋头于古代典籍的整理；在被自己的时代拒绝之后，他成功地通过文化符号进入了未来的世纪；在被几个诸侯国的诸侯和政客拒绝后。他的影响力却遍及全世界。名声响彻天下。</p><p>　　孔子本来是想通过立功来传名后世的，像他终生倾慕的周公…样。但这一点已经毫无疑问地没有可能了。“君子疾没世而名不称焉!”(君子很惧怕死后没有名声留传啊)于是他使想通过立言来不朽。我们知道，在这一点上，他成功了，而且在立言中他还立了德。”三不朽”他完成了两项。据司马迁的记载，“六经”都是经他手订的。也正因了他的手，这些积满时光尘土的古典才成为“经”．而为后世不断地钻研．又在这不断的琢磨中发出历久弥新的光芒。那本“饥者歌其食，劳者歌其事”的三百零五首“诗”。记录着那么遥远时代的真切的痛苦。更是因为他的手订．由愚夫愚妇引车卖浆者流的歌吟一跃而成为六经之百。“子曰”与“诗云”并称。实际上，就是因了“孔子曰”．孔子的赞誉。《诗》中愚夫愚妇们的“云”。才成为中国古代文学的圣经。他对这三百首《诗》通过些什么呢?他和子夏讨论过“巧笑倩兮，美目盼兮”：他和子贡讨沦过“如切如磋，如琢如磨”；他说：“不学《诗》，无以言”，他还说。“诗，可以怨”!他把《诗》当作教材。传授结弟子 们，正是因为这种口耳相传式的传授．才使得《诗经》能避开暴君赢政的焚书之火和莽汉项羽的复仇之火．斯文不灭—他还庄重地为《诗》回护。说：《诗》三百，—言以蔽之．曰思无邪！”这就使后世很多对《诗经》暗怀不满的人。比如朱熹．只能做些鬼鬼祟祟的、歪曲的勾当。孔子是文学的守护神呢。原来他不仅是—位庄严谨恪的人。还是一位情感丰富的人!因此，他不仅要求人类要有道德。就是对人类的情感——包括对人性的弱点。他也有那么多善意的回护与爱惜!他要人们好德，但也不反对人们好色，“国风好色而不淫”，不过分，就行了嘛。说到这里。插入一件小事。跟孔子学语言修辞的子夏，有—个毛病．那就是吝啬。知生莫如师。孔子深知子夏这一‘毛病．于是就刻意为他遮掩。一次孔子出门．碰上下雨，而子夏有伞。孔子却不去借，甘冒雨淋之苦。有人间孔子为何不向子夏借伞，孔子说。子夏有这个小毛病，若向他借伞。借，他心里不痛快；不借，不是把他的缺点暴露给众人了吗?如果能掩盖住别人的缺点。我淋点雨算什么呢?</p><p>　　文学是人学，文学就是人性的表现。不能对人性的优点有极祟高的敬意．对人性的弱点有极宽厚的怜悯．是不可能理解文学的。我们再举一个相反的例子，朱熹。对这个人我老实说没有——丝一毫的好感。且不说他的那一套“存天理，灭人欲”的理论是多么仇视人性，我只想举他对《诗经》中一首诗的评论来说说。</p><p>　　《诗经·卫风》中有一首诗叫《氓》，是一位被遗弃女子的哀歌。这个女子坚持要明媒正娶地嫁给她所爱的男人(这就是“乐而不淫”)，做了妻子后她辛勤贤患。但最后还是被抛弃了。即便这样，她也依然那么理智、节制，哀而不伤。怨而不怒。老实说，我读到这首诗的最后“亦已焉哉”(唉，算了吧)．是颇失望的，我私下里希望她能报复对方一下。我知道这种想法不对，既不合法也不合理。但我觉得这才合情。美狄亚就实施了惨烈的报复。孔子也提倡“以直报怨”。但朱熹对这个不幸女子的评论，使我觉得他很卑鄙。很没有人性。他说：“此淫妇为人所弃．自叙其事以道其悔恨之意也。”(这个淫荡的女子被别人始乱终弃了．自己追叙自己的所作所为．倾吐出悔恨之意)读到这样的议论如果不觉得朱烹卑鄙下流．就不是正派人。因为朱熹凭空污人清白(在这首诗中一点也看不出这个女子有什么淫荡的地方)；他对一位多情的恋人(婚前)一个贤淑的妻子(婚后)毫无首肯之意，理学家之不懂欣赏女人．于此可见一斑，而理学家之仇视一切鲜活的女性，对人间痛苦毫无同情心也在此原形毕露。这些只知”以理杀人”的后儒们，他们何曾及得上孔子的一分一毫啊。</p><p>　　由于孔子丰富的文学情怀。他把人格修养的最高境界理解为一种自由的艺术境界，而不是严谨的道德境界。在这一点上他又和后世的道德家们大相径庭。我们也一直没注意这一点。孔子在道德的熔炉里冶炼自己．而最后出炉的结果却大出我们意料：他熔炼出的不是森森剑朝。而是更加的幽默生动。你看他说的：“志于道．据于德，依于仁、游于艺”，又说“兴于诗，立于礼，成于乐”。他最后的形象是”成于乐”而“游于艺”：他一下子变得亲近了．不再壁垒森严了。你看他：“闻《韶》，三月不知肉味”，这时他能是一位皱着眉头板着面孔不苟言笑的人么?他是一位手之舞之，足之蹈之的老顽童哩!他极爱音乐．即便在围困之中，也是每日“弦歌不衰”。只要附近没死丧，他每日都大声地唱歌。司马迁的《孔子世家》中记载了孔子与音乐的一件软事：他在师襄子那里学了一首曲子．一连弹了十数天还不换其他曲子、直到他从这首曲子里“听”出了那个肤色黝黑、身材硕长、眼神忧郁的文王的形象!“作《易》者，其有忧患乎！”文王可不就是一个满腹忧患的古之高人吗?孔子的精神通过飞翔的音符而与之相通了!</p><p>　　有这样的音乐修养与音乐情怀。“三百五篇孔子皆弦歌之”。这是多么宏伟壮丽的大乐章啊。我们今天已经不能再聆听孔子弦歌过的音乐了。“此曲只应天上有．人间哪得几回闻”。但那古老而简朴的文字仍留传下来。那远古时代活生生个体的欢乐与哀伤，希望与失望，怨愤与爱慕……仍然如此鲜活。是的，那远古的神经末梢仍在向我们传来敏锐而清晰的刺痛……</p><p>　　《诗经》中有一百六十首都是采自民间。包括黄河流域。汉水、汝水流域。我们可以由此贴近这片辽阔土地上的风、水、丘垄与庄稼。贴近这片土地上的阳光、情感、悲欢与离合。班固与何休都提到当时有专门采诗的行人，摇着木铎顺着乡间小道去采诗。我有时痴想，没有比这更好的职业了。如果我在那时，我一定做个采诗者。不采诗还干什么呢?还有什么比这更快乐的工作呢?</p><p>　　冬日的蛰居过去了，春光融融，芳香萋萋。我立于道口，望农夫荷锄远来，而他的歌声亦悠扬而感伤……</p><p>　　我在村落间徘徊．看顽童嬉闹：我亦走上田头。看麦苗油油，静观灌溉之水汩汩流淌。</p><p>　　那么多忧伤的故事啊。有一个人因想念远方的恋人而去了，从此杳无音信；一位多情的女子被人遗弃了．哭泣着回到娘家；而服役归来的人，拄杖立于田头，他的家园已成一片废墟，丘垄上葬着他的亲人……</p><p>　　在远处飘来的歌声面前，我老泪纵横。</p><pre><code>我是被《诗经》感动了。最幸福的时候就是被感动的时候。谁能说当孔子对这三百零五首诗逐一弦歌时．他不也是感怀万端呢?“四方有羡，我独居忧。民莫不逸，我独不敢休”(《十月之交》)，这样的句子，如此贴切他忧患人生的情怀．如此真切地反映他奔波为天下的辛苦，他能不感慨吗?而那一位走过周朝旧都．面对废墟上的野黍而“中心摇摇”悲不自禁的诗人，不更是他的同调吗?面对伟大朝代的文化废墟，他不更是忧患满怀吗?“知我者谓我心忧，不知我者谓我何求。悠悠苍天，此何人哉?”(《黍离》)，是啊，孔子，他是…位什么样的人呢？</code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;原作者：鲍鹏山，民革成员，文学博士，作家，学者。上海开放大学人文学院教授 ，青海师范大学硕士研究生导师 [2]  、上海交通大学兼职教授。中国作家协会会员、中国孔子基金会学术委员会委员。潜心研究先秦诸子数十年，长期从事中国古代文学研究。&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a</summary>
      
    
    
    
    <category term="精华转载" scheme="https://billma.top/categories/%E7%B2%BE%E5%8D%8E%E8%BD%AC%E8%BD%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>wenyan-compile</title>
    <link href="https://billma.top/2021/10/09/wenyan-compile/"/>
    <id>https://billma.top/2021/10/09/wenyan-compile/</id>
    <published>2021-10-09T14:54:01.000Z</published>
    <updated>2021-10-09T15:16:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、说在前面"><a href="#1、说在前面" class="headerlink" title="1、说在前面"></a>1、说在前面</h1><p>中考总分130分。其中古代诗歌默写6分，文言文阅读11分，古诗鉴赏4分。总共21分。</p><p>古代文学占17.5%</p><p>高考总分150分。文言阅读9分，翻译10分，古诗词鉴赏8分，古诗文默写8分。总共35分。</p><p>古代文学占21.3%</p><p>可见文言文是十分重要的。</p><p>然而。。。你想过用文言文编程吗？？？</p><p>这几年，奇奇怪怪的编程语言逐渐变多，其中一个学霸创建了一个叫文言文的编程语言，风靡github（？</p><h1 id="2、关于wenyan语言的代码与语法"><a href="#2、关于wenyan语言的代码与语法" class="headerlink" title="2、关于wenyan语言的代码与语法"></a>2、关于wenyan语言的代码与语法</h1><h2 id="2-1、认识wenyan语言"><a href="#2-1、认识wenyan语言" class="headerlink" title="2-1、认识wenyan语言"></a>2-1、认识wenyan语言</h2><p>咱们都知道，学习一门编程语言是从什么开始的？？</p><p>众OIer orz ：当然是 A+B~</p><p>哦，不对，学习一门语言应该先从理解这个语言的优缺点啊，基础框架啊等等（回想一下你刚开始学 C++ ， Pascal的时候（那时候我C++框架默了5遍都默错））。</p><p>但是! wenyan 语言 没有框架！</p><p>wenyan就像 Pascal一样，定义好变量后就直接开始打主代码了。不会像 C++一样还有什么万能头啊，什么 STL 啊，没有这么多,简单易懂（还能提升你的文言文阅读水平）。</p><p>现在，我们要开始打主代码，我们先从最基本的 Hello world!开始吧~</p><p>wenyan打三遍Hello world! 的输出是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">吾有一數。曰三。名之曰「甲」。</span><br><span class="line">為是「甲」遍。</span><br><span class="line">吾有一言。曰「「問天地好在。」」。書之。</span><br><span class="line">云云</span><br></pre></td></tr></table></figure><p>编译为Javascript</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;問天地好在。&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 编译为Python</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">3</span></span><br><span class="line"><span class="keyword">for</span> _rand1 <span class="keyword">in</span> <span class="built_in">range</span>(a):</span><br><span class="line">_ans1=<span class="string">&quot;問天地好在。&quot;</span></span><br><span class="line"><span class="built_in">print</span>(_ans1)</span><br></pre></td></tr></table></figure><p> 编译为Ruby</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">3</span></span><br><span class="line">a.times <span class="keyword">do</span> <span class="params">|_rand1|</span></span><br><span class="line">_ans1=<span class="string">&quot;問天地好在。&quot;</span></span><br><span class="line">p([_ans1].join)</span><br><span class="line"><span class="keyword">end</span> </span><br></pre></td></tr></table></figure><p> 自译为c/c++</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;問天地好在。&quot;</span>);</span><br><span class="line">&#125;　</span><br></pre></td></tr></table></figure><p>运行：</p><p><code>問天地好在。問天地好在。問天地好在。</code></p><p>是不是很生动？很形象？对， wenyan 就是这样！清晰易懂，代码简便……</p><p>现在开始介绍 wenyan的基本语法:</p><h2 id="2-2、基本语法"><a href="#2-2、基本语法" class="headerlink" title="2-2、基本语法"></a>2-2、基本语法</h2><h3 id="2-2-1、定义变量"><a href="#2-2-1、定义变量" class="headerlink" title="2-2-1、定义变量"></a>2-2-1、定义变量</h3><p>毕竟都说是文言文编程了，肯定不能出现英文字母和数字的嘛~</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">吾有一數。曰六。名之曰「甲」。 int a（a就是甲）=6;</span><br><span class="line"></span><br><span class="line">有數六。名之曰「蒟蒻」。 int juruo=6;</span><br><span class="line"></span><br><span class="line">吾有一言。曰「「噫吁戲」」。名之曰「乙」。 string b（就是乙）=alas!</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-2-2、ture和false"><a href="#2-2-2、ture和false" class="headerlink" title="2-2-2、ture和false"></a>2-2-2、ture和false</h3><p>true/false 分别对应 wenyan语言中的陽/陰（繁体的阳/阴），类型就是“爻”（卦符的基本符号）：</p><figure class="highlight plaintext"><figcaption><span>C++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">吾有一爻。曰陽。名之曰「丙」。 bool c=true;</span><br><span class="line"></span><br><span class="line">吾有一爻。曰陰。名之曰「丁」。 bool d=false;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-2-3、if判断"><a href="#2-2-3、if判断" class="headerlink" title="2-2-3、if判断"></a>2-2-3、if判断</h3><p>作为一个编程语言怎么少了 ifi判断呢？</p><figure class="highlight plaintext"><figcaption><span>C++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">若三不大於五者。吾有一言。曰「「OK」」。 if(3&lt;=5) cout&lt;&lt;&quot;OK&quot;;</span><br><span class="line"></span><br><span class="line">書之。。若非。乃得「「NO」」也 else cout&lt;&lt;&quot;NO&quot;;</span><br></pre></td></tr></table></figure><h3 id="2-2-4、运算符"><a href="#2-2-4、运算符" class="headerlink" title="2-2-4、运算符"></a>2-2-4、运算符</h3><p>加减乘除一应俱全，连逻辑运算符都有!</p><figure class="highlight plaintext"><figcaption><span>C++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">加一以一。 1+1</span><br><span class="line"></span><br><span class="line">除七以三。所餘幾何。 7%3</span><br><span class="line"></span><br><span class="line">減六六六六以六六六。名之曰「甲」。 int a=6666-666;</span><br></pre></td></tr></table></figure><h3 id="2-2-5-容器类型"><a href="#2-2-5-容器类型" class="headerlink" title="2-2-5 容器类型"></a>2-2-5 容器类型</h3><p>容器类型也支持，而且注意一下，首个下标是从一开始的。</p><figure class="highlight plaintext"><figcaption><span>C++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">吾有一列。名之曰「数组」。充「数组」以四。以二。 int shuzu[]=&#123;4,2&#125;;</span><br><span class="line"></span><br><span class="line">夫「寶劍」之長。 sword.size;</span><br><span class="line"></span><br><span class="line">夫「蒟蒻」之一。 juruo[1];</span><br><span class="line"></span><br><span class="line">夫「中国」之「「名」」。 China[&quot;name&quot;]</span><br></pre></td></tr></table></figure><h3 id="2-2-6-进价语法"><a href="#2-2-6-进价语法" class="headerlink" title="2-2-6 进价语法"></a>2-2-6 进价语法</h3><p>一些 wenyan 的进价语法。。。。。。</p><h4 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h4><p>wenyan：<code>吾有一術。名之曰「吸星大法」。是術曰。⋯⋯是謂「吸星大法」之術也。</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;...&#125;</span><br></pre></td></tr></table></figure><h4 id="定义含参函数"><a href="#定义含参函数" class="headerlink" title="定义含参函数"></a>定义含参函数</h4><p>wenyan：<code>吾有一術。名之曰「六脈神劍」。欲行是術。必先得六數。曰「甲」。曰「乙」。曰「丙」。曰「丁」。曰「戊」。曰「己」乃行是術曰。⋯⋯是謂「六脈神劍」之術也。</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a,b,c,d,e,f</span>)</span>&#123;...&#125;</span><br></pre></td></tr></table></figure><h4 id="定义其他函数"><a href="#定义其他函数" class="headerlink" title="定义其他函数"></a>定义其他函数</h4><p>wenyan：<code>吾有一術。名之曰「翻倍」。欲行是術。必先得一數。曰「甲」。乃行是術曰。乘「甲」以二。名之曰「乙」。乃得「乙」。是謂「翻倍」之術也。</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">a</span>)</span>&#123;<span class="keyword">var</span> b = a * <span class="number">2</span>; <span class="keyword">return</span> b;&#125;</span><br></pre></td></tr></table></figure><p>wenyan：<code>施「翻倍」於「蒟蒻」。</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">double(juruo);</span><br></pre></td></tr></table></figure><p>wenyan：<code>吾有一數。曰五。書之。</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><h3 id="2-2-7-循环"><a href="#2-2-7-循环" class="headerlink" title="2-2-7 循环"></a>2-2-7 循环</h3><p>就是那些 for ， while循环之类的。（注意！ 云云 为 wenyan语言循环的后面必加的东西！）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">為是百遍。⋯⋯ 云云。 <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)</span><br><span class="line"></span><br><span class="line">......恆為是。⋯⋯ 云云。 <span class="keyword">while</span>(<span class="literal">true</span>) ......</span><br><span class="line"></span><br><span class="line">乃止。 <span class="keyword">break</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>目前就这些了……</p><h1 id="3、编写wenyan语言程序运行"><a href="#3、编写wenyan语言程序运行" class="headerlink" title="3、编写wenyan语言程序运行"></a>3、编写wenyan语言程序运行</h1><p>本人是用洛谷 IDE 进行运行的，当然还有一种网站也可以实现 wenyan语言的编译运行，还可以实现 wenyan转 JavaScript和 Python的功能！（虽然我都不会……）<br>这个网站就是：<a href="https://wy-lang.org/ide?example=beer">戳这里</a></p><p>这里面有不少好康和好玩的东西，你也可以在这里面编译。</p><p>而且项目文件还有个脚本src/render.js，它可以把程序渲染成古代书籍的样子。</p><h1 id="4、关于wenyan语言编程"><a href="#4、关于wenyan语言编程" class="headerlink" title="4、关于wenyan语言编程"></a>4、关于wenyan语言编程</h1><blockquote><p>夫唐、虞之世，結繩而足治，屈指而足算。是時豈料百代之後，計算機械之巧，精於公輸之木鳶，善於武侯之流馬；程式語言之多，繁若《天官》之星宿，奇勝《山經》之走獸。鼠、蟹、鑽、魚，或以速稱。蛇、象、駱、犀，各爭文采。方知鬼之所以夜哭，天之所以雨粟。然以文言編程者 ，似所未有。此非文脈之所以傳，文心之所以保。嗟予小子，遂有斯志。然則數寸之烏絲猶覆於頭，萬卷之素書未破於手；一身長羁于远邦，兩耳久旷于雅言。然夫文章者吾之所宿好，程式者偶承時人之謬譽。故希孟不慚年少，莊生不望無涯。乃作斯言。未能嘔瀝長吉之心血，亦庶幾免於義山之流沫。既成之後，復學干將鑄劍而自飼，越王嚐糞而當先。自謂偶追《十書》之筆意，但恨少八家之淋漓。此子山所謂士衡抚掌而甘心，平子見陋而固宜。然則雖實覆甕之質，尚存斧正之望；雖乏呂相之金，易字之渴蓋同。此亦開源之大義，吾輩之所以勉勵也。一笑。 —-Huang Lingdong（wenyan语言作者）</p></blockquote><p>Huang Lingdong，来自卡耐基梅隆大学，如今大四，明年即将毕业。高中则毕业自上海世界外国语中学。</p><p>就是这个小伙子，做出了这个风靡 github的 wenyan语言！</p><h1 id="5、写在最后"><a href="#5、写在最后" class="headerlink" title="5、写在最后"></a>5、写在最后</h1><p>到最后，不知道大家看懂没（反正我是看懂了）。</p><p>真的是奇葩多。。。</p><h1 id="附录：奇奇怪怪的编程语言"><a href="#附录：奇奇怪怪的编程语言" class="headerlink" title="附录：奇奇怪怪的编程语言"></a>附录：奇奇怪怪的编程语言</h1><p>Esolang<br>Esoteric programming language，简称 Esolang，它们的设计被用于测试计算机语言设计的极限，作为一个概念的证明，或仅仅是一个玩笑。Esolang 创作者通常并不打算让它成为主流编程语言，他们几乎不会在意语言的可用性，甚至恰恰相反，会故意增加使用难度。（我介绍这个你们自己品）</p><p>比如 Brainfuck，它是在 1993 年被创造的编程语言，语法仅包含八种符号，没有任何单词，用它打印 Hello world 是这样的：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">++<span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="title">[</span>&gt;++<span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span>&gt;++<span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span>&gt;++<span class="literal">+</span>&gt;<span class="literal">+</span>&lt;&lt;&lt;&lt;<span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;++<span class="string">.</span>&gt;<span class="literal">+</span><span class="string">.</span>++<span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="string">.</span><span class="string">.</span>++<span class="literal">+</span><span class="string">.</span>&gt;++<span class="string">.</span>&lt;&lt;++<span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="string">.</span></span><br><span class="line">&gt;<span class="string">.</span>++<span class="literal">+</span><span class="string">.</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="string">.</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="string">.</span>&gt;<span class="literal">+</span><span class="string">.</span>&gt;<span class="string">.</span></span><br></pre></td></tr></table></figure><p>再比如 MarioLANG，它同样只能使用符号，需要使用形似马里奥关卡的语法来书写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">++++:     &gt;    &gt; +:+:+:+:+:+:+:::::</span><br><span class="line">====+    &gt;^=== &quot;&quot;&quot;=================</span><br><span class="line">    +:-):(:^= =                   !</span><br><span class="line">    =========  =                  #</span><br><span class="line">                = !         .+.,:-&lt;</span><br><span class="line">                 =###       ======&quot;</span><br></pre></td></tr></table></figure><p>Parenthesis Hell，言如其名，括号地狱，只能使用括号来书写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(()()(()()(()()()()((()()(()(()((()((()()()((()((()()()((()((((()()(()(</span><br><span class="line">)()()()()(((()(((()((()((((()(((()()(()()((()((()()()((()()(()()()()(()</span><br><span class="line">()()()(()()()()(()(())))))))))))))))))))))))))))))))))))))))))))))))))</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1、说在前面&quot;&gt;&lt;a href=&quot;#1、说在前面&quot; class=&quot;headerlink&quot; title=&quot;1、说在前面&quot;&gt;&lt;/a&gt;1、说在前面&lt;/h1&gt;&lt;p&gt;中考总分130分。其中古代诗歌默写6分，文言文阅读11分，古诗鉴赏4分。总共21分。&lt;/p&gt;
&lt;p&gt;古代文学</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>洛谷P5380鸭旗解法</title>
    <link href="https://billma.top/2021/10/05/cppluogu-p5380/"/>
    <id>https://billma.top/2021/10/05/cppluogu-p5380/</id>
    <published>2021-10-05T06:58:06.000Z</published>
    <updated>2021-10-05T07:06:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一步-初始化"><a href="#第一步-初始化" class="headerlink" title="第一步 初始化"></a>第一步 初始化</h2><div class="story post-story"><p>就按上图的格式进行初始化棋盘，注意棋盘的方向与数组下标，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">begining</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Blue</span></span><br><span class="line"><span class="comment">//underline character</span></span><br><span class="line">mapp[<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>]=<span class="number">5</span>,mapp[<span class="number">1</span>][<span class="number">2</span>][<span class="number">0</span>]=<span class="number">4</span>,mapp[<span class="number">1</span>][<span class="number">3</span>][<span class="number">0</span>]=<span class="number">3</span>,mapp[<span class="number">1</span>][<span class="number">4</span>][<span class="number">0</span>]=<span class="number">2</span>,mapp[<span class="number">1</span>][<span class="number">5</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">mapp[<span class="number">1</span>][<span class="number">6</span>][<span class="number">0</span>]=<span class="number">2</span>,mapp[<span class="number">1</span>][<span class="number">7</span>][<span class="number">0</span>]=<span class="number">3</span>,mapp[<span class="number">1</span>][<span class="number">8</span>][<span class="number">0</span>]=<span class="number">4</span>,mapp[<span class="number">1</span>][<span class="number">9</span>][<span class="number">0</span>]=<span class="number">5</span>;</span><br><span class="line"><span class="comment">//duck</span></span><br><span class="line">mapp[<span class="number">3</span>][<span class="number">1</span>][<span class="number">0</span>]=<span class="number">6</span>,mapp[<span class="number">3</span>][<span class="number">9</span>][<span class="number">0</span>]=<span class="number">6</span>;</span><br><span class="line"><span class="comment">//soldier</span></span><br><span class="line">mapp[<span class="number">4</span>][<span class="number">1</span>][<span class="number">0</span>]=<span class="number">7</span>,mapp[<span class="number">4</span>][<span class="number">3</span>][<span class="number">0</span>]=<span class="number">7</span>,mapp[<span class="number">4</span>][<span class="number">5</span>][<span class="number">0</span>]=<span class="number">7</span>,mapp[<span class="number">4</span>][<span class="number">7</span>][<span class="number">0</span>]=<span class="number">7</span>,mapp[<span class="number">4</span>][<span class="number">9</span>][<span class="number">0</span>]=<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Red</span></span><br><span class="line"><span class="comment">//underline character</span></span><br><span class="line">mapp[<span class="number">10</span>][<span class="number">1</span>][<span class="number">1</span>]=<span class="number">5</span>,mapp[<span class="number">10</span>][<span class="number">2</span>][<span class="number">1</span>]=<span class="number">4</span>,mapp[<span class="number">10</span>][<span class="number">3</span>][<span class="number">1</span>]=<span class="number">3</span>,mapp[<span class="number">10</span>][<span class="number">4</span>][<span class="number">1</span>]=<span class="number">2</span>,mapp[<span class="number">10</span>][<span class="number">5</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">mapp[<span class="number">10</span>][<span class="number">6</span>][<span class="number">1</span>]=<span class="number">2</span>,mapp[<span class="number">10</span>][<span class="number">7</span>][<span class="number">1</span>]=<span class="number">3</span>,mapp[<span class="number">10</span>][<span class="number">8</span>][<span class="number">1</span>]=<span class="number">4</span>,mapp[<span class="number">10</span>][<span class="number">9</span>][<span class="number">1</span>]=<span class="number">5</span>;</span><br><span class="line"><span class="comment">//duck</span></span><br><span class="line">mapp[<span class="number">8</span>][<span class="number">1</span>][<span class="number">1</span>]=<span class="number">6</span>,mapp[<span class="number">8</span>][<span class="number">9</span>][<span class="number">1</span>]=<span class="number">6</span>;</span><br><span class="line"><span class="comment">//soldier</span></span><br><span class="line">mapp[<span class="number">7</span>][<span class="number">1</span>][<span class="number">1</span>]=<span class="number">7</span>,mapp[<span class="number">7</span>][<span class="number">3</span>][<span class="number">1</span>]=<span class="number">7</span>,mapp[<span class="number">7</span>][<span class="number">5</span>][<span class="number">1</span>]=<span class="number">7</span>,mapp[<span class="number">7</span>][<span class="number">7</span>][<span class="number">1</span>]=<span class="number">7</span>;mapp[<span class="number">7</span>][<span class="number">9</span>][<span class="number">1</span>]=<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我调换了红蓝双方的顺序，所以就不用翻转棋盘。</p></div><h2 id="第二步-基础操作函数："><a href="#第二步-基础操作函数：" class="headerlink" title="第二步 基础操作函数："></a>第二步 基础操作函数：</h2><div class="story post-story"><h3 id="①attack-移动-攻击"><a href="#①attack-移动-攻击" class="headerlink" title="①attack 移动/攻击"></a>①attack 移动/攻击</h3><p>因为移动也是一种特殊的攻击，所以也可以把移动归入攻击一栏,通过from，to参数，考虑攻击前后的敌我关系，具体代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attack</span><span class="params">(<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y2,<span class="keyword">int</span> from,<span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line">mapp[x2][y2][from]=mapp[x1][y1][from];</span><br><span class="line">mapp[x1][y1][from]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(to!=<span class="number">-1</span>)mapp[x2][y2][to]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="②getgroup-分组"><a href="#②getgroup-分组" class="headerlink" title="②getgroup 分组"></a>②getgroup 分组</h3><p>对于一个坐标的棋子，我们肯定要知道它属于哪一方，自然要写一个函数来获取分组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getgroup</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(mapp[x][y][<span class="number">0</span>])<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(mapp[x][y][<span class="number">1</span>])<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="③getcaptain-获取主帅位置"><a href="#③getcaptain-获取主帅位置" class="headerlink" title="③getcaptain 获取主帅位置"></a>③getcaptain 获取主帅位置</h3><p>这一函数将在最后判断将军时用到。比较好理解。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Node getcaptain(int gr)&#123;</span><br><span class="line">Node t;</span><br><span class="line">for(int i=1;i&lt;=10;i++)&#123;</span><br><span class="line">for(int j=1;j&lt;=9;j++)&#123;</span><br><span class="line">if(mapp[i][j][gr]==1)&#123;</span><br><span class="line">t.x=i,t.y=j;</span><br><span class="line">return t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="第三步-判断每个棋子移动的合法性"><a href="#第三步-判断每个棋子移动的合法性" class="headerlink" title="第三步 判断每个棋子移动的合法性"></a>第三步 判断每个棋子移动的合法性</h2><div class="story post-story"><p>这是整道题的重中之重，这里将一一讲解：</p><h3 id="①captain-将的移动"><a href="#①captain-将的移动" class="headerlink" title="①captain 将的移动"></a>①captain 将的移动</h3><p>这是最为简单的移动之一，只要求移动前后的坐标差即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">captain</span><span class="params">(<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y2,<span class="keyword">int</span> from,<span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tx=<span class="built_in">abs</span>(x1-x2),ty=<span class="built_in">abs</span>(y1-y2);</span><br><span class="line"><span class="keyword">if</span>(tx==<span class="number">1</span>&amp;&amp;ty==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(tx==<span class="number">0</span>&amp;&amp;ty==<span class="number">1</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="②guard-士的移动"><a href="#②guard-士的移动" class="headerlink" title="②guard 士的移动"></a>②guard 士的移动</h3><p>这个移动与将差不多，同样求坐标差</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">guard</span><span class="params">(<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y2,<span class="keyword">int</span> from,<span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tx=<span class="built_in">abs</span>(x1-x2),ty=<span class="built_in">abs</span>(y1-y2);</span><br><span class="line"><span class="keyword">if</span>(tx==<span class="number">1</span>&amp;&amp;ty==<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="③elephant-象的移动"><a href="#③elephant-象的移动" class="headerlink" title="③elephant 象的移动"></a>③elephant 象的移动</h3><p>这个移动就有点复杂，注意要判断是否移动受阻，可以单独开一个数组判断障碍，这个思路就有点像大家初学BFS的时候模拟移动。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">elephant</span><span class="params">(<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y2,<span class="keyword">int</span> from,<span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> aimx[<span class="number">4</span>]=&#123;<span class="number">-2</span>,<span class="number">-2</span>,<span class="number">2</span>,<span class="number">2</span>&#125;,aimy[<span class="number">4</span>]=&#123;<span class="number">-2</span>,<span class="number">2</span>,<span class="number">-2</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> stx[<span class="number">4</span>]=&#123;<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">1</span>,&#125;,sty[<span class="number">4</span>]=&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> tx=x1+aimx[i],ty=y1+aimy[i];</span><br><span class="line"><span class="keyword">if</span>(tx==x2&amp;&amp;ty==y2)&#123;</span><br><span class="line"><span class="keyword">int</span> ttx=x1+stx[i],tty=y1+sty[i];</span><br><span class="line"><span class="keyword">if</span>(mapp[ttx][tty][<span class="number">0</span>]==<span class="number">0</span>&amp;&amp;mapp[ttx][tty][<span class="number">1</span>]==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="④horse-马的移动"><a href="#④horse-马的移动" class="headerlink" title="④horse 马的移动"></a>④horse 马的移动</h3><p>与象差不多，只要注意马的移动的x,y轴要一一对应，而障碍位置就是马的上下左右4个点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">horse</span><span class="params">(<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y2,<span class="keyword">int</span> from,<span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> aimx[<span class="number">8</span>]=&#123;<span class="number">-2</span>,<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;,aimy[<span class="number">8</span>]=&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> stx[<span class="number">8</span>]=&#123;<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,sty[<span class="number">8</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> tx=x1+aimx[i],ty=y1+aimy[i];</span><br><span class="line"><span class="keyword">if</span>(tx==x2&amp;&amp;ty==y2)&#123;</span><br><span class="line"><span class="keyword">int</span> ttx=x1+stx[i],tty=y1+sty[i];</span><br><span class="line"><span class="keyword">if</span>(mapp[ttx][tty][<span class="number">0</span>]==<span class="number">0</span>&amp;&amp;mapp[ttx][tty][<span class="number">1</span>]==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="⑤car-车的移动"><a href="#⑤car-车的移动" class="headerlink" title="⑤car 车的移动"></a>⑤car 车的移动</h3><p>车的移动相对简单，只要一重循环模拟即可。注意一点：要先判断两点时候同行或者同列，否则模拟是无意义的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">car</span><span class="params">(<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y2,<span class="keyword">int</span> from,<span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x1!=x2&amp;&amp;y1!=y2)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(x1==x2)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="built_in">min</span>(y1,y2)+<span class="number">1</span>;i&lt;=<span class="built_in">max</span>(y1,y2)<span class="number">-1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(mapp[x1][i][<span class="number">0</span>]||mapp[x1][i][<span class="number">1</span>])</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(y1==y2)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="built_in">min</span>(x1,x2)+<span class="number">1</span>;i&lt;=<span class="built_in">max</span>(x1,x2)<span class="number">-1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][y1][<span class="number">0</span>]||mapp[i][y1][<span class="number">1</span>])&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="⑥duck-鸭的移动"><a href="#⑥duck-鸭的移动" class="headerlink" title="⑥duck 鸭的移动"></a>⑥duck 鸭的移动</h3><p>鸭这个棋子是所有棋子中最难模拟的，但仔细分析，可以发现，鸭的障碍就是马对应方向的障碍与立足点，所以开2个数组去判断鸭的两层障碍即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">duck</span><span class="params">(<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y2,<span class="keyword">int</span> from,<span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> aimx[<span class="number">8</span>]=&#123;<span class="number">-3</span>,<span class="number">-3</span>,<span class="number">-2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">-2</span>&#125;,aimy[<span class="number">8</span>]=&#123;<span class="number">-2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">-2</span>,<span class="number">-3</span>,<span class="number">-3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> stx[<span class="number">8</span>]=&#123;<span class="number">-2</span>,<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;,sty[<span class="number">8</span>]=&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> subx[<span class="number">8</span>]=&#123;<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,suby[<span class="number">8</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> tx=x1+aimx[i],ty=y1+aimy[i];</span><br><span class="line"><span class="keyword">if</span>(tx==x2&amp;&amp;ty==y2)&#123;</span><br><span class="line"><span class="keyword">int</span> ttx=x1+stx[i],tty=y1+sty[i];</span><br><span class="line"><span class="keyword">int</span> tttx=x1+subx[i],ttty=y1+suby[i];</span><br><span class="line"><span class="keyword">if</span>(mapp[ttx][tty][<span class="number">0</span>]==<span class="number">0</span>&amp;&amp;mapp[ttx][tty][<span class="number">1</span>]==<span class="number">0</span>&amp;&amp;mapp[tttx][ttty][<span class="number">0</span>]==<span class="number">0</span>&amp;&amp;mapp[tttx][ttty][<span class="number">1</span>]==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="⑦soldier-兵的移动"><a href="#⑦soldier-兵的移动" class="headerlink" title="⑦soldier 兵的移动"></a>⑦soldier 兵的移动</h3><p>仔细观察，不难发现，兵的移动就是将的移动加上士的移动。所以直接调用上面的函数即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">soldier</span><span class="params">(<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y2,<span class="keyword">int</span> from,<span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">captain</span>(x1,y1,x2,y2,from,to))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">guard</span>(x1,y1,x2,y2,from,to))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="第三步-移动操作"><a href="#第三步-移动操作" class="headerlink" title="第三步 移动操作"></a>第三步 移动操作</h2><div class="story post-story"><p>有了之前的几个函数做铺垫，这个操作就好写很多，先判断是否符合题目中要求，比如同方，起始点无己方棋子等等，然后一一判断是哪种棋子，调用对应的函数即可。如果合法，那么就移动/对敌方棋子攻击，调用attack函数，否则输出无解，注意一点，在移动棋子前要先输出前两个信息，即移动的棋子和被攻击的棋子，因为在移动后信息会被改变。 最后输出后两个信息，在下文会讲到。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y2,<span class="keyword">int</span> from,<span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line"><span class="comment">//nowgame();</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(from!=roun)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Invalid command&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//check the size</span></span><br><span class="line"><span class="keyword">if</span>(x1&lt;<span class="number">1</span>||x2&lt;<span class="number">1</span>||x1&gt;<span class="number">10</span>||x2&gt;<span class="number">10</span>||y1&lt;<span class="number">1</span>||y2&lt;<span class="number">1</span>||y1&gt;<span class="number">9</span>||y2&gt;<span class="number">9</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Invalid command&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//check the gruops</span></span><br><span class="line"><span class="keyword">if</span>(from==to)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Invalid command&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//check the from</span></span><br><span class="line"><span class="keyword">if</span>(from==<span class="number">-1</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Invalid command&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//check if the game is over</span></span><br><span class="line"><span class="keyword">if</span>(flg==<span class="number">1</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Invalid command&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//captain</span></span><br><span class="line"><span class="keyword">if</span>(mapp[x1][y1][from]==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">captain</span>(x1,y1,x2,y2,from,to))&#123;</span><br><span class="line"><span class="keyword">int</span> ta=mapp[x1][y1][from];</span><br><span class="line"><span class="keyword">int</span> tb=mapp[x2][y2][to];</span><br><span class="line">cout&lt;&lt;group[from]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;name[ta]&lt;&lt;<span class="string">&#x27;;&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(to==<span class="number">-1</span>)cout&lt;&lt;<span class="string">&quot;NA;&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;group[to]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;name[tb]&lt;&lt;<span class="string">&#x27;;&#x27;</span>; </span><br><span class="line"><span class="built_in">attack</span>(x1,y1,x2,y2,from,to);</span><br><span class="line"><span class="built_in">print</span>(mapp[x1][y1][from],from,mapp[x2][y2][to],to,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">print</span>(mapp[x1][y1][from],from,mapp[x2][y2][to],to,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//guard</span></span><br><span class="line"><span class="keyword">if</span>(mapp[x1][y1][from]==<span class="number">2</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">guard</span>(x1,y1,x2,y2,from,to))&#123;</span><br><span class="line"><span class="keyword">int</span> ta=mapp[x1][y1][from];</span><br><span class="line"><span class="keyword">int</span> tb=mapp[x2][y2][to];</span><br><span class="line">cout&lt;&lt;group[from]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;name[ta]&lt;&lt;<span class="string">&#x27;;&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(to==<span class="number">-1</span>)cout&lt;&lt;<span class="string">&quot;NA;&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;group[to]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;name[tb]&lt;&lt;<span class="string">&#x27;;&#x27;</span>; </span><br><span class="line"><span class="built_in">attack</span>(x1,y1,x2,y2,from,to);</span><br><span class="line"><span class="built_in">print</span>(mapp[x1][y1][from],from,mapp[x2][y2][to],to,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">print</span>(mapp[x1][y1][from],from,mapp[x2][y2][to],to,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//elephant</span></span><br><span class="line"><span class="keyword">if</span>(mapp[x1][y1][from]==<span class="number">3</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">elephant</span>(x1,y1,x2,y2,from,to))&#123;</span><br><span class="line"><span class="keyword">int</span> ta=mapp[x1][y1][from];</span><br><span class="line"><span class="keyword">int</span> tb=mapp[x2][y2][to];</span><br><span class="line">cout&lt;&lt;group[from]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;name[ta]&lt;&lt;<span class="string">&#x27;;&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(to==<span class="number">-1</span>)cout&lt;&lt;<span class="string">&quot;NA;&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;group[to]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;name[tb]&lt;&lt;<span class="string">&#x27;;&#x27;</span>; </span><br><span class="line"><span class="built_in">attack</span>(x1,y1,x2,y2,from,to);</span><br><span class="line"><span class="built_in">print</span>(mapp[x1][y1][from],from,mapp[x2][y2][to],to,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">print</span>(mapp[x1][y1][from],from,mapp[x2][y2][to],to,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//horse</span></span><br><span class="line"><span class="keyword">if</span>(mapp[x1][y1][from]==<span class="number">4</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">horse</span>(x1,y1,x2,y2,from,to))&#123;</span><br><span class="line"><span class="keyword">int</span> ta=mapp[x1][y1][from];</span><br><span class="line"><span class="keyword">int</span> tb=mapp[x2][y2][to];</span><br><span class="line">cout&lt;&lt;group[from]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;name[ta]&lt;&lt;<span class="string">&#x27;;&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(to==<span class="number">-1</span>)cout&lt;&lt;<span class="string">&quot;NA;&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;group[to]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;name[tb]&lt;&lt;<span class="string">&#x27;;&#x27;</span>; </span><br><span class="line"><span class="built_in">attack</span>(x1,y1,x2,y2,from,to);</span><br><span class="line"><span class="built_in">print</span>(mapp[x1][y1][from],from,mapp[x2][y2][to],to,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">print</span>(mapp[x1][y1][from],from,mapp[x2][y2][to],to,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//car</span></span><br><span class="line"><span class="keyword">if</span>(mapp[x1][y1][from]==<span class="number">5</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">car</span>(x1,y1,x2,y2,from,to))&#123;</span><br><span class="line"><span class="keyword">int</span> ta=mapp[x1][y1][from];</span><br><span class="line"><span class="keyword">int</span> tb=mapp[x2][y2][to];</span><br><span class="line">cout&lt;&lt;group[from]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;name[ta]&lt;&lt;<span class="string">&#x27;;&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(to==<span class="number">-1</span>)cout&lt;&lt;<span class="string">&quot;NA;&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;group[to]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;name[tb]&lt;&lt;<span class="string">&#x27;;&#x27;</span>; </span><br><span class="line"><span class="built_in">attack</span>(x1,y1,x2,y2,from,to);</span><br><span class="line"><span class="built_in">print</span>(mapp[x1][y1][from],from,mapp[x2][y2][to],to,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">print</span>(mapp[x1][y1][from],from,mapp[x2][y2][to],to,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//duck</span></span><br><span class="line"><span class="keyword">if</span>(mapp[x1][y1][from]==<span class="number">6</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">duck</span>(x1,y1,x2,y2,from,to))&#123;</span><br><span class="line"><span class="keyword">int</span> ta=mapp[x1][y1][from];</span><br><span class="line"><span class="keyword">int</span> tb=mapp[x2][y2][to];</span><br><span class="line">cout&lt;&lt;group[from]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;name[ta]&lt;&lt;<span class="string">&#x27;;&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(to==<span class="number">-1</span>)cout&lt;&lt;<span class="string">&quot;NA;&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;group[to]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;name[tb]&lt;&lt;<span class="string">&#x27;;&#x27;</span>; </span><br><span class="line"><span class="built_in">attack</span>(x1,y1,x2,y2,from,to);</span><br><span class="line"><span class="built_in">print</span>(mapp[x1][y1][from],from,mapp[x2][y2][to],to,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">print</span>(mapp[x1][y1][from],from,mapp[x2][y2][to],to,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//soldier</span></span><br><span class="line"><span class="keyword">if</span>(mapp[x1][y1][from]==<span class="number">7</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">soldier</span>(x1,y1,x2,y2,from,to))&#123; </span><br><span class="line"><span class="keyword">int</span> ta=mapp[x1][y1][from];</span><br><span class="line"><span class="keyword">int</span> tb=mapp[x2][y2][to];</span><br><span class="line">cout&lt;&lt;group[from]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;name[ta]&lt;&lt;<span class="string">&#x27;;&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(to==<span class="number">-1</span>)cout&lt;&lt;<span class="string">&quot;NA;&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;group[to]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;name[tb]&lt;&lt;<span class="string">&#x27;;&#x27;</span>; </span><br><span class="line"><span class="built_in">attack</span>(x1,y1,x2,y2,from,to);</span><br><span class="line"><span class="built_in">print</span>(mapp[x1][y1][from],from,mapp[x2][y2][to],to,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">print</span>(mapp[x1][y1][from],from,mapp[x2][y2][to],to,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="第四步-判断将军"><a href="#第四步-判断将军" class="headerlink" title="第四步 判断将军"></a>第四步 判断将军</h2><div class="story post-story"><p>将军这个问题看似很难解决，其实换一种思路即可，假设每个敌方棋子都可以将军，然后调用之前的函数，判断假设是否成立，如果成立，说明存在将军，否则则不存在将军。</p><p>这样一来，代码就非常好写了：遍历每个点，对于有敌方棋子的点，就做出假设，然后判断假设。并且这里要用到之前的getcaptain函数来获取两方将的位置。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cankill</span><span class="params">()</span></span>&#123;</span><br><span class="line">Node blue,red;</span><br><span class="line">blue=<span class="built_in">getcaptain</span>(<span class="number">0</span>),red=<span class="built_in">getcaptain</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">9</span>;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][<span class="number">0</span>])&#123;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][<span class="number">0</span>]==<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">captain</span>(i,j,red.x,red.y,<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][<span class="number">0</span>]==<span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">guard</span>(i,j,red.x,red.y,<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][<span class="number">0</span>]==<span class="number">3</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">elephant</span>(i,j,red.x,red.y,<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][<span class="number">0</span>]==<span class="number">4</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">horse</span>(i,j,red.x,red.y,<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][<span class="number">0</span>]==<span class="number">5</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">car</span>(i,j,red.x,red.y,<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][<span class="number">0</span>]==<span class="number">6</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">duck</span>(i,j,red.x,red.y,<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][<span class="number">0</span>]==<span class="number">7</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">soldier</span>(i,j,red.x,red.y,<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][<span class="number">1</span>])&#123;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][<span class="number">1</span>]==<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">captain</span>(i,j,blue.x,blue.y,<span class="number">1</span>,<span class="number">0</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][<span class="number">1</span>]==<span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">guard</span>(i,j,blue.x,blue.y,<span class="number">1</span>,<span class="number">0</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][<span class="number">1</span>]==<span class="number">3</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">elephant</span>(i,j,blue.x,blue.y,<span class="number">1</span>,<span class="number">0</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][<span class="number">1</span>]==<span class="number">4</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">horse</span>(i,j,blue.x,blue.y,<span class="number">1</span>,<span class="number">0</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][<span class="number">1</span>]==<span class="number">5</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">car</span>(i,j,blue.x,blue.y,<span class="number">1</span>,<span class="number">0</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][<span class="number">1</span>]==<span class="number">6</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">duck</span>(i,j,blue.x,blue.y,<span class="number">1</span>,<span class="number">0</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][<span class="number">1</span>]==<span class="number">7</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">soldier</span>(i,j,blue.x,blue.y,<span class="number">1</span>,<span class="number">0</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="第五步-判断游戏是否结束"><a href="#第五步-判断游戏是否结束" class="headerlink" title="第五步 判断游戏是否结束"></a>第五步 判断游戏是否结束</h2><div class="story post-story"><p>这个问题非常好解决，跑一遍二重循环，统计将的个数，如果小于2，游戏一定结束，注意游戏结束后要设置一个flg，使对接下来命令的处理都是无解。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isend</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=<span class="number">1</span>;k++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">9</span>;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][k]==<span class="number">1</span>)t++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(t&lt;<span class="number">2</span>)&#123;</span><br><span class="line">flg=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="第六步-输出"><a href="#第六步-输出" class="headerlink" title="第六步 输出"></a>第六步 输出</h2><div class="story post-story"><p>因为在move函数中已经将前两个信息输出，所以这里只要输出后两个信息即可，直接调用上面的函数，同时在输出的时候更新当前应当走棋的阵营。 对于不合法的调用，输出无解即可。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> M_C,<span class="keyword">int</span> M_G,<span class="keyword">int</span> K_C,<span class="keyword">int</span> K_G,<span class="keyword">int</span> canmove)</span></span>&#123;</span><br><span class="line"><span class="comment">//canmove?</span></span><br><span class="line"><span class="keyword">if</span>(canmove==<span class="number">1</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Invalid command&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">roun=<span class="number">1</span>-roun;</span><br><span class="line"></span><br><span class="line"><span class="comment">//End?</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">isend</span>())&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;no;yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">cankill</span>())cout&lt;&lt;<span class="string">&quot;yes;&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;no;&quot;</span>;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;no&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tip：主程序中对于每条指令，调用move函数即可。</p></div><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><div class="story post-story"><p>献上完整代码，10K,396行:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//begining words</span></span><br><span class="line"><span class="keyword">int</span> Q;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> mapp[<span class="number">20</span>][<span class="number">20</span>][<span class="number">2</span>];</span><br><span class="line">string name[<span class="number">10</span>]=&#123;<span class="string">&quot;&quot;</span>,<span class="string">&quot;captain&quot;</span>,<span class="string">&quot;guard&quot;</span>,<span class="string">&quot;elephant&quot;</span>,<span class="string">&quot;horse&quot;</span>,<span class="string">&quot;car&quot;</span>,<span class="string">&quot;duck&quot;</span>,<span class="string">&quot;soldier&quot;</span>&#125;;</span><br><span class="line">string group[<span class="number">3</span>]=&#123;<span class="string">&quot;red&quot;</span>,<span class="string">&quot;blue&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">bool</span> flg=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> roun=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">begining</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Blue</span></span><br><span class="line"><span class="comment">//underline character</span></span><br><span class="line">mapp[<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>]=<span class="number">5</span>,mapp[<span class="number">1</span>][<span class="number">2</span>][<span class="number">0</span>]=<span class="number">4</span>,mapp[<span class="number">1</span>][<span class="number">3</span>][<span class="number">0</span>]=<span class="number">3</span>,mapp[<span class="number">1</span>][<span class="number">4</span>][<span class="number">0</span>]=<span class="number">2</span>,mapp[<span class="number">1</span>][<span class="number">5</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">mapp[<span class="number">1</span>][<span class="number">6</span>][<span class="number">0</span>]=<span class="number">2</span>,mapp[<span class="number">1</span>][<span class="number">7</span>][<span class="number">0</span>]=<span class="number">3</span>,mapp[<span class="number">1</span>][<span class="number">8</span>][<span class="number">0</span>]=<span class="number">4</span>,mapp[<span class="number">1</span>][<span class="number">9</span>][<span class="number">0</span>]=<span class="number">5</span>;</span><br><span class="line"><span class="comment">//duck</span></span><br><span class="line">mapp[<span class="number">3</span>][<span class="number">1</span>][<span class="number">0</span>]=<span class="number">6</span>,mapp[<span class="number">3</span>][<span class="number">9</span>][<span class="number">0</span>]=<span class="number">6</span>;</span><br><span class="line"><span class="comment">//soldier</span></span><br><span class="line">mapp[<span class="number">4</span>][<span class="number">1</span>][<span class="number">0</span>]=<span class="number">7</span>,mapp[<span class="number">4</span>][<span class="number">3</span>][<span class="number">0</span>]=<span class="number">7</span>,mapp[<span class="number">4</span>][<span class="number">5</span>][<span class="number">0</span>]=<span class="number">7</span>,mapp[<span class="number">4</span>][<span class="number">7</span>][<span class="number">0</span>]=<span class="number">7</span>,mapp[<span class="number">4</span>][<span class="number">9</span>][<span class="number">0</span>]=<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Red</span></span><br><span class="line"><span class="comment">//underline character</span></span><br><span class="line">mapp[<span class="number">10</span>][<span class="number">1</span>][<span class="number">1</span>]=<span class="number">5</span>,mapp[<span class="number">10</span>][<span class="number">2</span>][<span class="number">1</span>]=<span class="number">4</span>,mapp[<span class="number">10</span>][<span class="number">3</span>][<span class="number">1</span>]=<span class="number">3</span>,mapp[<span class="number">10</span>][<span class="number">4</span>][<span class="number">1</span>]=<span class="number">2</span>,mapp[<span class="number">10</span>][<span class="number">5</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">mapp[<span class="number">10</span>][<span class="number">6</span>][<span class="number">1</span>]=<span class="number">2</span>,mapp[<span class="number">10</span>][<span class="number">7</span>][<span class="number">1</span>]=<span class="number">3</span>,mapp[<span class="number">10</span>][<span class="number">8</span>][<span class="number">1</span>]=<span class="number">4</span>,mapp[<span class="number">10</span>][<span class="number">9</span>][<span class="number">1</span>]=<span class="number">5</span>;</span><br><span class="line"><span class="comment">//duck</span></span><br><span class="line">mapp[<span class="number">8</span>][<span class="number">1</span>][<span class="number">1</span>]=<span class="number">6</span>,mapp[<span class="number">8</span>][<span class="number">9</span>][<span class="number">1</span>]=<span class="number">6</span>;</span><br><span class="line"><span class="comment">//soldier</span></span><br><span class="line">mapp[<span class="number">7</span>][<span class="number">1</span>][<span class="number">1</span>]=<span class="number">7</span>,mapp[<span class="number">7</span>][<span class="number">3</span>][<span class="number">1</span>]=<span class="number">7</span>,mapp[<span class="number">7</span>][<span class="number">5</span>][<span class="number">1</span>]=<span class="number">7</span>,mapp[<span class="number">7</span>][<span class="number">7</span>][<span class="number">1</span>]=<span class="number">7</span>;mapp[<span class="number">7</span>][<span class="number">9</span>][<span class="number">1</span>]=<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attack</span><span class="params">(<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y2,<span class="keyword">int</span> from,<span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line">mapp[x2][y2][from]=mapp[x1][y1][from];</span><br><span class="line">mapp[x1][y1][from]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(to!=<span class="number">-1</span>)mapp[x2][y2][to]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getgroup</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(mapp[x][y][<span class="number">0</span>])<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(mapp[x][y][<span class="number">1</span>])<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node <span class="title">getcaptain</span><span class="params">(<span class="keyword">int</span> gr)</span></span>&#123;</span><br><span class="line">Node t;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">9</span>;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][gr]==<span class="number">1</span>)&#123;</span><br><span class="line">t.x=i,t.y=j;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">captain</span><span class="params">(<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y2,<span class="keyword">int</span> from,<span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tx=<span class="built_in">abs</span>(x1-x2),ty=<span class="built_in">abs</span>(y1-y2);</span><br><span class="line"><span class="keyword">if</span>(tx==<span class="number">1</span>&amp;&amp;ty==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(tx==<span class="number">0</span>&amp;&amp;ty==<span class="number">1</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">guard</span><span class="params">(<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y2,<span class="keyword">int</span> from,<span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tx=<span class="built_in">abs</span>(x1-x2),ty=<span class="built_in">abs</span>(y1-y2);</span><br><span class="line"><span class="keyword">if</span>(tx==<span class="number">1</span>&amp;&amp;ty==<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">elephant</span><span class="params">(<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y2,<span class="keyword">int</span> from,<span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> aimx[<span class="number">4</span>]=&#123;<span class="number">-2</span>,<span class="number">-2</span>,<span class="number">2</span>,<span class="number">2</span>&#125;,aimy[<span class="number">4</span>]=&#123;<span class="number">-2</span>,<span class="number">2</span>,<span class="number">-2</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> stx[<span class="number">4</span>]=&#123;<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">1</span>,&#125;,sty[<span class="number">4</span>]=&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> tx=x1+aimx[i],ty=y1+aimy[i];</span><br><span class="line"><span class="keyword">if</span>(tx==x2&amp;&amp;ty==y2)&#123;</span><br><span class="line"><span class="keyword">int</span> ttx=x1+stx[i],tty=y1+sty[i];</span><br><span class="line"><span class="keyword">if</span>(mapp[ttx][tty][<span class="number">0</span>]==<span class="number">0</span>&amp;&amp;mapp[ttx][tty][<span class="number">1</span>]==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">horse</span><span class="params">(<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y2,<span class="keyword">int</span> from,<span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> aimx[<span class="number">8</span>]=&#123;<span class="number">-2</span>,<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;,aimy[<span class="number">8</span>]=&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> stx[<span class="number">8</span>]=&#123;<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,sty[<span class="number">8</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> tx=x1+aimx[i],ty=y1+aimy[i];</span><br><span class="line"><span class="keyword">if</span>(tx==x2&amp;&amp;ty==y2)&#123;</span><br><span class="line"><span class="keyword">int</span> ttx=x1+stx[i],tty=y1+sty[i];</span><br><span class="line"><span class="keyword">if</span>(mapp[ttx][tty][<span class="number">0</span>]==<span class="number">0</span>&amp;&amp;mapp[ttx][tty][<span class="number">1</span>]==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">car</span><span class="params">(<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y2,<span class="keyword">int</span> from,<span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x1!=x2&amp;&amp;y1!=y2)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(x1==x2)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="built_in">min</span>(y1,y2)+<span class="number">1</span>;i&lt;=<span class="built_in">max</span>(y1,y2)<span class="number">-1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(mapp[x1][i][<span class="number">0</span>]||mapp[x1][i][<span class="number">1</span>])</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(y1==y2)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="built_in">min</span>(x1,x2)+<span class="number">1</span>;i&lt;=<span class="built_in">max</span>(x1,x2)<span class="number">-1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][y1][<span class="number">0</span>]||mapp[i][y1][<span class="number">1</span>])&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">duck</span><span class="params">(<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y2,<span class="keyword">int</span> from,<span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> aimx[<span class="number">8</span>]=&#123;<span class="number">-3</span>,<span class="number">-3</span>,<span class="number">-2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">-2</span>&#125;,aimy[<span class="number">8</span>]=&#123;<span class="number">-2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">-2</span>,<span class="number">-3</span>,<span class="number">-3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> stx[<span class="number">8</span>]=&#123;<span class="number">-2</span>,<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;,sty[<span class="number">8</span>]=&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> subx[<span class="number">8</span>]=&#123;<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,suby[<span class="number">8</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> tx=x1+aimx[i],ty=y1+aimy[i];</span><br><span class="line"><span class="keyword">if</span>(tx==x2&amp;&amp;ty==y2)&#123;</span><br><span class="line"><span class="keyword">int</span> ttx=x1+stx[i],tty=y1+sty[i];</span><br><span class="line"><span class="keyword">int</span> tttx=x1+subx[i],ttty=y1+suby[i];</span><br><span class="line"><span class="keyword">if</span>(mapp[ttx][tty][<span class="number">0</span>]==<span class="number">0</span>&amp;&amp;mapp[ttx][tty][<span class="number">1</span>]==<span class="number">0</span>&amp;&amp;mapp[tttx][ttty][<span class="number">0</span>]==<span class="number">0</span>&amp;&amp;mapp[tttx][ttty][<span class="number">1</span>]==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">soldier</span><span class="params">(<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y2,<span class="keyword">int</span> from,<span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">captain</span>(x1,y1,x2,y2,from,to))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">guard</span>(x1,y1,x2,y2,from,to))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cankill</span><span class="params">()</span></span>&#123;</span><br><span class="line">Node blue,red;</span><br><span class="line">blue=<span class="built_in">getcaptain</span>(<span class="number">0</span>),red=<span class="built_in">getcaptain</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">9</span>;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][<span class="number">0</span>])&#123;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][<span class="number">0</span>]==<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">captain</span>(i,j,red.x,red.y,<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][<span class="number">0</span>]==<span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">guard</span>(i,j,red.x,red.y,<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][<span class="number">0</span>]==<span class="number">3</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">elephant</span>(i,j,red.x,red.y,<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][<span class="number">0</span>]==<span class="number">4</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">horse</span>(i,j,red.x,red.y,<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][<span class="number">0</span>]==<span class="number">5</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">car</span>(i,j,red.x,red.y,<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][<span class="number">0</span>]==<span class="number">6</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">duck</span>(i,j,red.x,red.y,<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][<span class="number">0</span>]==<span class="number">7</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">soldier</span>(i,j,red.x,red.y,<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][<span class="number">1</span>])&#123;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][<span class="number">1</span>]==<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">captain</span>(i,j,blue.x,blue.y,<span class="number">1</span>,<span class="number">0</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][<span class="number">1</span>]==<span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">guard</span>(i,j,blue.x,blue.y,<span class="number">1</span>,<span class="number">0</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][<span class="number">1</span>]==<span class="number">3</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">elephant</span>(i,j,blue.x,blue.y,<span class="number">1</span>,<span class="number">0</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][<span class="number">1</span>]==<span class="number">4</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">horse</span>(i,j,blue.x,blue.y,<span class="number">1</span>,<span class="number">0</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][<span class="number">1</span>]==<span class="number">5</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">car</span>(i,j,blue.x,blue.y,<span class="number">1</span>,<span class="number">0</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][<span class="number">1</span>]==<span class="number">6</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">duck</span>(i,j,blue.x,blue.y,<span class="number">1</span>,<span class="number">0</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][<span class="number">1</span>]==<span class="number">7</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">soldier</span>(i,j,blue.x,blue.y,<span class="number">1</span>,<span class="number">0</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isend</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=<span class="number">1</span>;k++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">9</span>;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][k]==<span class="number">1</span>)t++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(t&lt;<span class="number">2</span>)&#123;</span><br><span class="line">flg=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> M_C,<span class="keyword">int</span> M_G,<span class="keyword">int</span> K_C,<span class="keyword">int</span> K_G,<span class="keyword">int</span> canmove)</span></span>&#123;</span><br><span class="line"><span class="comment">//canmove?</span></span><br><span class="line"><span class="keyword">if</span>(canmove==<span class="number">1</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Invalid command&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">roun=<span class="number">1</span>-roun;</span><br><span class="line"></span><br><span class="line"><span class="comment">//End?</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">isend</span>())&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;no;yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">cankill</span>())cout&lt;&lt;<span class="string">&quot;yes;&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;no;&quot;</span>;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;no&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y2,<span class="keyword">int</span> from,<span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line"><span class="comment">//nowgame();</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(from!=roun)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Invalid command&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//check the size</span></span><br><span class="line"><span class="keyword">if</span>(x1&lt;<span class="number">1</span>||x2&lt;<span class="number">1</span>||x1&gt;<span class="number">10</span>||x2&gt;<span class="number">10</span>||y1&lt;<span class="number">1</span>||y2&lt;<span class="number">1</span>||y1&gt;<span class="number">9</span>||y2&gt;<span class="number">9</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Invalid command&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//check the gruops</span></span><br><span class="line"><span class="keyword">if</span>(from==to)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Invalid command&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//check the from</span></span><br><span class="line"><span class="keyword">if</span>(from==<span class="number">-1</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Invalid command&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//check if the game is over</span></span><br><span class="line"><span class="keyword">if</span>(flg==<span class="number">1</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Invalid command&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//captain</span></span><br><span class="line"><span class="keyword">if</span>(mapp[x1][y1][from]==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">captain</span>(x1,y1,x2,y2,from,to))&#123;</span><br><span class="line"><span class="keyword">int</span> ta=mapp[x1][y1][from];</span><br><span class="line"><span class="keyword">int</span> tb=mapp[x2][y2][to];</span><br><span class="line">cout&lt;&lt;group[from]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;name[ta]&lt;&lt;<span class="string">&#x27;;&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(to==<span class="number">-1</span>)cout&lt;&lt;<span class="string">&quot;NA;&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;group[to]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;name[tb]&lt;&lt;<span class="string">&#x27;;&#x27;</span>; </span><br><span class="line"><span class="built_in">attack</span>(x1,y1,x2,y2,from,to);</span><br><span class="line"><span class="built_in">print</span>(mapp[x1][y1][from],from,mapp[x2][y2][to],to,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">print</span>(mapp[x1][y1][from],from,mapp[x2][y2][to],to,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//guard</span></span><br><span class="line"><span class="keyword">if</span>(mapp[x1][y1][from]==<span class="number">2</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">guard</span>(x1,y1,x2,y2,from,to))&#123;</span><br><span class="line"><span class="keyword">int</span> ta=mapp[x1][y1][from];</span><br><span class="line"><span class="keyword">int</span> tb=mapp[x2][y2][to];</span><br><span class="line">cout&lt;&lt;group[from]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;name[ta]&lt;&lt;<span class="string">&#x27;;&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(to==<span class="number">-1</span>)cout&lt;&lt;<span class="string">&quot;NA;&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;group[to]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;name[tb]&lt;&lt;<span class="string">&#x27;;&#x27;</span>; </span><br><span class="line"><span class="built_in">attack</span>(x1,y1,x2,y2,from,to);</span><br><span class="line"><span class="built_in">print</span>(mapp[x1][y1][from],from,mapp[x2][y2][to],to,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">print</span>(mapp[x1][y1][from],from,mapp[x2][y2][to],to,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//elephant</span></span><br><span class="line"><span class="keyword">if</span>(mapp[x1][y1][from]==<span class="number">3</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">elephant</span>(x1,y1,x2,y2,from,to))&#123;</span><br><span class="line"><span class="keyword">int</span> ta=mapp[x1][y1][from];</span><br><span class="line"><span class="keyword">int</span> tb=mapp[x2][y2][to];</span><br><span class="line">cout&lt;&lt;group[from]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;name[ta]&lt;&lt;<span class="string">&#x27;;&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(to==<span class="number">-1</span>)cout&lt;&lt;<span class="string">&quot;NA;&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;group[to]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;name[tb]&lt;&lt;<span class="string">&#x27;;&#x27;</span>; </span><br><span class="line"><span class="built_in">attack</span>(x1,y1,x2,y2,from,to);</span><br><span class="line"><span class="built_in">print</span>(mapp[x1][y1][from],from,mapp[x2][y2][to],to,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">print</span>(mapp[x1][y1][from],from,mapp[x2][y2][to],to,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//horse</span></span><br><span class="line"><span class="keyword">if</span>(mapp[x1][y1][from]==<span class="number">4</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">horse</span>(x1,y1,x2,y2,from,to))&#123;</span><br><span class="line"><span class="keyword">int</span> ta=mapp[x1][y1][from];</span><br><span class="line"><span class="keyword">int</span> tb=mapp[x2][y2][to];</span><br><span class="line">cout&lt;&lt;group[from]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;name[ta]&lt;&lt;<span class="string">&#x27;;&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(to==<span class="number">-1</span>)cout&lt;&lt;<span class="string">&quot;NA;&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;group[to]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;name[tb]&lt;&lt;<span class="string">&#x27;;&#x27;</span>; </span><br><span class="line"><span class="built_in">attack</span>(x1,y1,x2,y2,from,to);</span><br><span class="line"><span class="built_in">print</span>(mapp[x1][y1][from],from,mapp[x2][y2][to],to,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">print</span>(mapp[x1][y1][from],from,mapp[x2][y2][to],to,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//car</span></span><br><span class="line"><span class="keyword">if</span>(mapp[x1][y1][from]==<span class="number">5</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">car</span>(x1,y1,x2,y2,from,to))&#123;</span><br><span class="line"><span class="keyword">int</span> ta=mapp[x1][y1][from];</span><br><span class="line"><span class="keyword">int</span> tb=mapp[x2][y2][to];</span><br><span class="line">cout&lt;&lt;group[from]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;name[ta]&lt;&lt;<span class="string">&#x27;;&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(to==<span class="number">-1</span>)cout&lt;&lt;<span class="string">&quot;NA;&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;group[to]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;name[tb]&lt;&lt;<span class="string">&#x27;;&#x27;</span>; </span><br><span class="line"><span class="built_in">attack</span>(x1,y1,x2,y2,from,to);</span><br><span class="line"><span class="built_in">print</span>(mapp[x1][y1][from],from,mapp[x2][y2][to],to,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">print</span>(mapp[x1][y1][from],from,mapp[x2][y2][to],to,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//duck</span></span><br><span class="line"><span class="keyword">if</span>(mapp[x1][y1][from]==<span class="number">6</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">duck</span>(x1,y1,x2,y2,from,to))&#123;</span><br><span class="line"><span class="keyword">int</span> ta=mapp[x1][y1][from];</span><br><span class="line"><span class="keyword">int</span> tb=mapp[x2][y2][to];</span><br><span class="line">cout&lt;&lt;group[from]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;name[ta]&lt;&lt;<span class="string">&#x27;;&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(to==<span class="number">-1</span>)cout&lt;&lt;<span class="string">&quot;NA;&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;group[to]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;name[tb]&lt;&lt;<span class="string">&#x27;;&#x27;</span>; </span><br><span class="line"><span class="built_in">attack</span>(x1,y1,x2,y2,from,to);</span><br><span class="line"><span class="built_in">print</span>(mapp[x1][y1][from],from,mapp[x2][y2][to],to,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">print</span>(mapp[x1][y1][from],from,mapp[x2][y2][to],to,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//soldier</span></span><br><span class="line"><span class="keyword">if</span>(mapp[x1][y1][from]==<span class="number">7</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">soldier</span>(x1,y1,x2,y2,from,to))&#123; </span><br><span class="line"><span class="keyword">int</span> ta=mapp[x1][y1][from];</span><br><span class="line"><span class="keyword">int</span> tb=mapp[x2][y2][to];</span><br><span class="line">cout&lt;&lt;group[from]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;name[ta]&lt;&lt;<span class="string">&#x27;;&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(to==<span class="number">-1</span>)cout&lt;&lt;<span class="string">&quot;NA;&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;group[to]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;name[tb]&lt;&lt;<span class="string">&#x27;;&#x27;</span>; </span><br><span class="line"><span class="built_in">attack</span>(x1,y1,x2,y2,from,to);</span><br><span class="line"><span class="built_in">print</span>(mapp[x1][y1][from],from,mapp[x2][y2][to],to,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">print</span>(mapp[x1][y1][from],from,mapp[x2][y2][to],to,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">begining</span>();</span><br><span class="line">cin&gt;&gt;Q;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Q;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> x1,y1,x2,y2;</span><br><span class="line">cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;</span><br><span class="line">x1++,y1++,x2++,y2++;</span><br><span class="line"><span class="built_in">move</span>(x1,y1,x2,y2,<span class="built_in">getgroup</span>(x1,y1),<span class="built_in">getgroup</span>(x2,y2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第一步-初始化&quot;&gt;&lt;a href=&quot;#第一步-初始化&quot; class=&quot;headerlink&quot; title=&quot;第一步 初始化&quot;&gt;&lt;/a&gt;第一步 初始化&lt;/h2&gt;&lt;div class=&quot;story post-story&quot;&gt;&lt;p&gt;就按上图的格式进行初始化棋盘，注意棋盘的</summary>
      
    
    
    
    <category term="竞赛解法" scheme="https://billma.top/categories/%E7%AB%9E%E8%B5%9B%E8%A7%A3%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>2021南航苏州附中第45届校运会</title>
    <link href="https://billma.top/2021/10/01/21sportsmeet/"/>
    <id>https://billma.top/2021/10/01/21sportsmeet/</id>
    <published>2021-10-01T10:51:06.000Z</published>
    <updated>2021-10-05T03:21:30.000Z</updated>
    
    <content type="html"><![CDATA[<iframe src="//player.bilibili.com/player.html?aid=463274950&bvid=BV1GL411s7AL&cid=417630302&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><p>原地址：<a href="https://www.bilibili.com/video/BV1GL411s7AL?share_source=copy_web">ClickHere</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;iframe src=&quot;//player.bilibili.com/player.html?aid=463274950&amp;bvid=BV1GL411s7AL&amp;cid=417630302&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;</summary>
      
    
    
    
    <category term="南航苏州附中校园活动" scheme="https://billma.top/categories/%E5%8D%97%E8%88%AA%E8%8B%8F%E5%B7%9E%E9%99%84%E4%B8%AD%E6%A0%A1%E5%9B%AD%E6%B4%BB%E5%8A%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>cxynb</title>
    <link href="https://billma.top/2021/09/13/cxynb/"/>
    <id>https://billma.top/2021/09/13/cxynb/</id>
    <published>2021-09-13T12:51:27.000Z</published>
    <updated>2021-09-13T12:53:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="陈星宇牛逼"><a href="#陈星宇牛逼" class="headerlink" title="陈星宇牛逼"></a>陈星宇牛逼</h1><h2 id="陈星宇牛逼-1"><a href="#陈星宇牛逼-1" class="headerlink" title="陈星宇牛逼"></a>陈星宇牛逼</h2><div class="story post-story"><h3 id="陈星宇牛逼-2"><a href="#陈星宇牛逼-2" class="headerlink" title="陈星宇牛逼"></a>陈星宇牛逼</h3><p><strong>陈星宇牛逼</strong></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;陈星宇牛逼&quot;&gt;&lt;a href=&quot;#陈星宇牛逼&quot; class=&quot;headerlink&quot; title=&quot;陈星宇牛逼&quot;&gt;&lt;/a&gt;陈星宇牛逼&lt;/h1&gt;&lt;h2 id=&quot;陈星宇牛逼-1&quot;&gt;&lt;a href=&quot;#陈星宇牛逼-1&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="陈星宇牛逼" scheme="https://billma.top/categories/%E9%99%88%E6%98%9F%E5%AE%87%E7%89%9B%E9%80%BC/"/>
    
    
  </entry>
  
  <entry>
    <title>南航苏州附中建党百年朗诵活动</title>
    <link href="https://billma.top/2021/09/12/2109poemsay/"/>
    <id>https://billma.top/2021/09/12/2109poemsay/</id>
    <published>2021-09-12T10:51:37.000Z</published>
    <updated>2021-10-04T10:54:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-十人集体诗歌朗诵"><a href="#1-十人集体诗歌朗诵" class="headerlink" title="1.十人集体诗歌朗诵"></a>1.十人集体诗歌朗诵</h2><div class="story post-story"><p>感谢以下参与人员参与录制：</p><p>汤骏懿   姚远  顾天欣 崔可欣 曹艺舟 祝中翔</p><p>杨海佳   沈思遥 王韬越 张翌晨</p><p>导演：马泊宁 姚远</p><p>拍摄+后期剪辑：马泊宁 陈星宇</p><p>特别感谢后勤小组：何昊   金弈  蒯翔   顾俊贤   陈星宇</p><h3 id="视频播放"><a href="#视频播放" class="headerlink" title="视频播放"></a>视频播放</h3><iframe src="//player.bilibili.com/player.html?aid=717999103&bvid=BV1iQ4y1y74b&cid=405971667&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h3 id="三连地址"><a href="#三连地址" class="headerlink" title="三连地址"></a>三连地址</h3><p>点击这里给作者给予支持：<a href="https://www.bilibili.com/video/BV1iQ4y1y74b?share_source=copy_web">点击这里</a></p></div><h2 id="2-陈星宇讲故事"><a href="#2-陈星宇讲故事" class="headerlink" title="2.陈星宇讲故事"></a>2.陈星宇讲故事</h2><div class="story post-story"><p>主讲：陈星宇</p><p>导演：马泊宁</p><p>拍摄+后期剪辑：马泊宁 陈星宇</p><p>特别感谢后勤小组： 张祉珺</p><h3 id="视频播放-1"><a href="#视频播放-1" class="headerlink" title="视频播放"></a>视频播放</h3><iframe src="//player.bilibili.com/player.html?aid=590416676&bvid=BV12q4y1Z7t2&cid=405973727&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h3 id="三连地址-1"><a href="#三连地址-1" class="headerlink" title="三连地址"></a>三连地址</h3><p>点击这里给作者给予支持：<a href="https://www.bilibili.com/video/BV12q4y1Z7t2?share_source=copy_web">点击这里</a></p></div><h2 id="3-张祉珺讲故事"><a href="#3-张祉珺讲故事" class="headerlink" title="3.张祉珺讲故事"></a>3.张祉珺讲故事</h2><div class="story post-story"><p>主讲：张祉珺</p><p>导演：马泊宁</p><p>拍摄+后期剪辑：马泊宁 陈星宇</p><p>特别感谢后勤小组： 陈星宇</p><h3 id="视频播放-2"><a href="#视频播放-2" class="headerlink" title="视频播放"></a>视频播放</h3><iframe src="//player.bilibili.com/player.html?aid=420461484&bvid=BV1y3411q7Rx&cid=406000152&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h3 id="三连地址-2"><a href="#三连地址-2" class="headerlink" title="三连地址"></a>三连地址</h3><p>点击这里给作者给予支持：<a href="https://www.bilibili.com/video/BV12q4y1Z7t2?share_source=copy_web">点击这里</a></p></div><h2 id="4-幕后花絮"><a href="#4-幕后花絮" class="headerlink" title="4.幕后花絮"></a>4.幕后花絮</h2><div class="story post-story"><iframe src="//player.bilibili.com/player.html?aid=932957777&bvid=BV1SM4y1G74z&cid=406551816&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><p>点击这里给作者给予支持：<a href="https://www.bilibili.com/video/BV1SM4y1G74z?share_source=copy_web">点击这里</a></p><p>感谢观看！</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-十人集体诗歌朗诵&quot;&gt;&lt;a href=&quot;#1-十人集体诗歌朗诵&quot; class=&quot;headerlink&quot; title=&quot;1.十人集体诗歌朗诵&quot;&gt;&lt;/a&gt;1.十人集体诗歌朗诵&lt;/h2&gt;&lt;div class=&quot;story post-story&quot;&gt;&lt;p&gt;感谢以下参与人员</summary>
      
    
    
    
    <category term="南航苏州附中校园活动" scheme="https://billma.top/categories/%E5%8D%97%E8%88%AA%E8%8B%8F%E5%B7%9E%E9%99%84%E4%B8%AD%E6%A0%A1%E5%9B%AD%E6%B4%BB%E5%8A%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>如何科学上网？</title>
    <link href="https://billma.top/2021/09/04/vpn-how-to-open/"/>
    <id>https://billma.top/2021/09/04/vpn-how-to-open/</id>
    <published>2021-09-04T12:32:35.000Z</published>
    <updated>2021-09-04T13:42:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>相信很多同学都想科学上网，但是由于工 信 部的限制，很少有人能真正科学上网。我今天就介绍几个我长期摸索出来的科学上网工具。</p><h2 id="1-Windows"><a href="#1-Windows" class="headerlink" title="1.Windows"></a>1.Windows</h2><div class="story post-story"><h4 id="1-安装-Microsoft-edge"><a href="#1-安装-Microsoft-edge" class="headerlink" title="1.安装 Microsoft edge"></a>1.安装 Microsoft edge</h4><p>其实理论上Google Chrome更加适合，但是你想接下来的操作本身需要科学上网才能访问Google play，所以在这里使用Microsoft edge。</p><p><a href="https://dl.softmgr.qq.com/original/Browser/MicrosoftEdgeSetup-win7-92.0.902.84.exe">Windows7点这里下载</a></p><p><a href="https://dl.softmgr.qq.com/original/Browser/MicrosoftEdgeSetup-win10-92.0.902.84.exe">Windows10点这里下载</a></p><h4 id="2-安装扩展"><a href="#2-安装扩展" class="headerlink" title="2.安装扩展"></a>2.安装扩展</h4><p>打开edge，<a href="https://microsoftedge.microsoft.com/addons/detail/setupvpn-lifetime-free-/okhjkpgblgdjappgfgakbcecdblgffcl?hl=zh-CN">打开这个网页</a>,点击安装即可。</p><h4 id="3-配置"><a href="#3-配置" class="headerlink" title="3.配置"></a>3.配置</h4><p>点开这个科学上网工具，选择汉语，会跳出一个输入邀请码的东西，不要管他，下面有一个create new account，点击，然后三个协议全选择，跳出一个页面，选择美国即可。</p></div><h2 id="2-iOS-iphone-or-ipad"><a href="#2-iOS-iphone-or-ipad" class="headerlink" title="2.iOS(iphone or ipad)"></a>2.iOS(iphone or ipad)</h2><div class="story post-story"><h4 id="1-获取Apple-ID"><a href="#1-获取Apple-ID" class="headerlink" title="1.获取Apple ID"></a>1.获取Apple ID</h4><p>由于上述国家部门的要求，Apple Inc中国区下架了所有科学上网工具。所以，现在手机上<a href="apple.com">点击这里</a>注册<strong>一个新的</strong>Apple ID。</p><p>注意，在注册时会让你选择国家与地区，选择美国即可。</p><h4 id="2-登录"><a href="#2-登录" class="headerlink" title="2.登录"></a>2.登录</h4><p>随后，点开App Store，登出后登陆你新注册的Apple ID，随后自动跳转到美国区，搜索V P N 3 6 0即可。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;相信很多同学都想科学上网，但是由于工 信 部的限制，很少有人能真正科学上网。我今天就介绍几个我长期摸索出来的科学上网工具。&lt;/p&gt;
&lt;h2 id=&quot;1-Windows&quot;&gt;&lt;a href=&quot;#1-Windows&quot; class=&quot;headerlink&quot; title=&quot;1.Win</summary>
      
    
    
    
    <category term="日常经验" scheme="https://billma.top/categories/%E6%97%A5%E5%B8%B8%E7%BB%8F%E9%AA%8C/"/>
    
    
  </entry>
  
  <entry>
    <title>今日编程发现--缩进问题</title>
    <link href="https://billma.top/2021/08/29/cpp-if-else-question-1/"/>
    <id>https://billma.top/2021/08/29/cpp-if-else-question-1/</id>
    <published>2021-08-29T08:11:52.000Z</published>
    <updated>2021-08-29T08:17:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天偶然看到一段代码是这么写的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(...)</span><br><span class="line">    <span class="keyword">if</span>(...)</span><br><span class="line">        ...</span><br><span class="line">  <span class="keyword">else</span> ...</span><br></pre></td></tr></table></figure><p>那么问题来了，这么缩进这个else跟的是谁呢？</p><p>其实根据C++原则，else跟的是离他更近的那个if。但是，如果别欣赏这段代码的时候，那可真的难为人家了。</p><p>所以，严格按照语法编代码，保持KISS(Keep it simple,stupid)是最基本的原则。不要写容易混淆的代码。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天偶然看到一段代码是这么写的：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>GitHub下载速度太慢怎么办？</title>
    <link href="https://billma.top/2021/08/29/github-speed-up-download/"/>
    <id>https://billma.top/2021/08/29/github-speed-up-download/</id>
    <published>2021-08-29T07:17:38.000Z</published>
    <updated>2021-09-04T13:42:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>在本站中，有一些下载项目是我通过GitHub仓库上传的（下载地址：<a href="billmarepo.github.io">billmarepo.github.io</a>）,但是GitHub在中国大陆地区访问较慢，下载速度更是令人感慨（但是亲测速度比百度网盘快）。那么，在下载本站资源时遇到GitHub下载太慢该如何处置？</p><h2 id="1-复制"><a href="#1-复制" class="headerlink" title="1.复制"></a>1.复制</h2><div class="story post-story"><p>找到下载的资源，右击选择：复制目标链接（反正就这个意思，不同浏览器显示不同）。</p></div><h2 id="2-GitHub文件加速"><a href="#2-GitHub文件加速" class="headerlink" title="2.GitHub文件加速"></a>2.GitHub文件加速</h2><div class="story post-story"><p>利用 Cloudflare Workers 对 github release 、archive 以及项目文件进行加速，部署无需服务器且自带CDN.<br><a href="https://gh.api.99988866.xyz/">https://gh.api.99988866.xyz</a><br><a href="https://ghproxy.com/">https://ghproxy.com/</a><br>以上网站为演示站点，如无法打开可以查看开源项目：gh-proxy-GitHub 文件加速自行部署。</p></div><h2 id="3-Github-加速下载"><a href="#3-Github-加速下载" class="headerlink" title="3.Github 加速下载"></a>3.Github 加速下载</h2><div class="story post-story"><p>将你复制的链接到以下网址就可以加速下载了！</p><p>地址：<a href="http://toolwa.com/github/">http://toolwa.com/github/</a></p></div><h2 id="4-其他友情链接"><a href="#4-其他友情链接" class="headerlink" title="4.其他友情链接"></a>4.其他友情链接</h2><div class="story post-story"><h3 id="官网镜像（可以用来clone-push等-但是不能登录）"><a href="#官网镜像（可以用来clone-push等-但是不能登录）" class="headerlink" title="官网镜像（可以用来clone push等,但是不能登录）"></a>官网镜像（可以用来clone push等,但是不能登录）</h3><p><a href="https://github.com.cnpmjs.org/">https://github.com.cnpmjs.org/</a></p><p><a href="https://hub.fastgit.org/">https://hub.fastgit.org/</a> <strong>（速度最快）</strong></p><p><a href="https://github.wuyanzheshui.workers.dev/">https://github.wuyanzheshui.workers.dev/</a></p><h3 id="API镜像（用来api操作）"><a href="#API镜像（用来api操作）" class="headerlink" title="API镜像（用来api操作）"></a>API镜像（用来api操作）</h3><p><a href="https://api.git.sdut.me/">https://api.git.sdut.me/</a></p><p><a href="https://v2.kkpp.cc/">https://v2.kkpp.cc/</a></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在本站中，有一些下载项目是我通过GitHub仓库上传的（下载地址：&lt;a href=&quot;billmarepo.github.io&quot;&gt;billmarepo.github.io&lt;/a&gt;）,但是GitHub在中国大陆地区访问较慢，下载速度更是令人感慨（但是亲测速度比百度网盘快）。那么</summary>
      
    
    
    
    <category term="日常经验" scheme="https://billma.top/categories/%E6%97%A5%E5%B8%B8%E7%BB%8F%E9%AA%8C/"/>
    
    
    <category term="github" scheme="https://billma.top/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>python之matplotlib详细教程</title>
    <link href="https://billma.top/2021/08/26/python-matplotlib/"/>
    <id>https://billma.top/2021/08/26/python-matplotlib/</id>
    <published>2021-08-26T11:44:55.000Z</published>
    <updated>2021-08-29T07:46:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><strong>前提：你已经安装了python并且在安装时勾选了Add Python to PATH</strong></p><p>打开cmd，输入如下指令：（不要复制粘贴）</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install matplotlib</span><br><span class="line">pip install numpy</span><br></pre></td></tr></table></figure><p>安装完后打开python，就可以开始了！</p><h1 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><h1 id="1请求一个新的figure对象"><a href="#1请求一个新的figure对象" class="headerlink" title="1请求一个新的figure对象"></a>1请求一个新的figure对象</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.figure()</span><br></pre></td></tr></table></figure><h2 id="1-2Axes"><a href="#1-2Axes" class="headerlink" title="1.2Axes"></a>1.2Axes</h2><div class="story post-story"><p>在拥有Figure对象之后，在作画前我们还需要轴，没有轴的话就没有绘图基准，所以需要添加Axes。也可以理解成为真正可以作画的纸。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fig = plt.figure()</span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line">ax.<span class="built_in">set</span>(xlim=[<span class="number">0.5</span>, <span class="number">4.5</span>], ylim=[-<span class="number">2</span>, <span class="number">8</span>], title=<span class="string">&#x27;An Example Axes&#x27;</span>,</span><br><span class="line">       ylabel=<span class="string">&#x27;Y-Axis&#x27;</span>, xlabel=<span class="string">&#x27;X-Axis&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>上的代码，在一幅图上添加了一个Axes，然后设置了这个Axes的X轴以及Y轴的取值范围（这些设置并不是强制的，后面会再谈到关于这些设置）</p><p>对于上面的fig.add_subplot(111)就是添加Axes的，参数的解释的在画板的第1行第1列的第一个位置生成一个Axes对象来准备作画。也可以通过fig.add_subplot(2, 2, 1)的方式生成Axes，前面两个参数确定了面板的划分，例如 2， 2会将整个面板划分成 2 * 2 的方格，第三个参数取值范围是 [1, 2*2] 表示第几个Axes。如下面的例子：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fig = plt.figure()</span><br><span class="line">ax1 = fig.add_subplot(<span class="number">221</span>)</span><br><span class="line">ax2 = fig.add_subplot(<span class="number">222</span>)</span><br><span class="line">ax3 = fig.add_subplot(<span class="number">224</span>)</span><br></pre></td></tr></table></figure></div><h2 id="1-3-Multiple-Axes"><a href="#1-3-Multiple-Axes" class="headerlink" title="1.3 Multiple Axes"></a>1.3 Multiple Axes</h2><div class="story post-story"><p>可以发现我们上面添加 Axes 似乎有点弱鸡，所以提供了下面的方式一次性生成所有 Axes：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fig, axes = plt.subplots(nrows=<span class="number">2</span>, ncols=<span class="number">2</span>)</span><br><span class="line">axes[<span class="number">0</span>,<span class="number">0</span>].<span class="built_in">set</span>(title=<span class="string">&#x27;Upper Left&#x27;</span>)</span><br><span class="line">axes[<span class="number">0</span>,<span class="number">1</span>].<span class="built_in">set</span>(title=<span class="string">&#x27;Upper Right&#x27;</span>)</span><br><span class="line">axes[<span class="number">1</span>,<span class="number">0</span>].<span class="built_in">set</span>(title=<span class="string">&#x27;Lower Left&#x27;</span>)</span><br><span class="line">axes[<span class="number">1</span>,<span class="number">1</span>].<span class="built_in">set</span>(title=<span class="string">&#x27;Lower Right&#x27;</span>)</span><br></pre></td></tr></table></figure><p>fig 还是我们熟悉的画板， axes 成了我们常用二维数组的形式访问，这在循环绘图时，额外好用。</p></div><h2 id="1-4-Axes-Vs-pyplot"><a href="#1-4-Axes-Vs-pyplot" class="headerlink" title="1.4 Axes Vs .pyplot"></a>1.4 Axes Vs .pyplot</h2><div class="story post-story"><p>相信不少人看过下面的代码，很简单并易懂，但是下面的作画方式只适合简单的绘图，快速的将图绘出。在处理复杂的绘图工作时，我们还是需要使用 Axes 来完成作画的。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plt.plot([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">10</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">30</span>], color=<span class="string">&#x27;lightblue&#x27;</span>, linewidth=<span class="number">3</span>)</span><br><span class="line">plt.xlim(<span class="number">0.5</span>, <span class="number">4.5</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h1 id="2-基本绘图2D"><a href="#2-基本绘图2D" class="headerlink" title="2. 基本绘图2D"></a>2. 基本绘图2D</h1></div><h2 id="2-1-线"><a href="#2-1-线" class="headerlink" title="2.1 线"></a>2.1 线</h2><div class="story post-story"><p>plot()函数画出一系列的点，并且用线将它们连接起来。看下例子：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = np.linspace(<span class="number">0</span>, np.pi)</span><br><span class="line">y_sin = np.sin(x)</span><br><span class="line">y_cos = np.cos(x)</span><br><span class="line"></span><br><span class="line">ax1.plot(x, y_sin)</span><br><span class="line">ax2.plot(x, y_sin, <span class="string">&#x27;go--&#x27;</span>, linewidth=<span class="number">2</span>, markersize=<span class="number">12</span>)</span><br><span class="line">ax3.plot(x, y_cos, color=<span class="string">&#x27;red&#x27;</span>, marker=<span class="string">&#x27;+&#x27;</span>, linestyle=<span class="string">&#x27;dashed&#x27;</span>)</span><br></pre></td></tr></table></figure><p>在上面的三个Axes上作画。plot，前面两个参数为x轴、y轴数据。ax2的第三个参数是 MATLAB风格的绘图，对应ax3上的颜色，marker，线型。</p><p>另外，我们可以通过关键字参数的方式绘图，如下例：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">10</span>, <span class="number">200</span>)</span><br><span class="line">data_obj = &#123;<span class="string">&#x27;x&#x27;</span>: x,</span><br><span class="line">            <span class="string">&#x27;y1&#x27;</span>: <span class="number">2</span> * x + <span class="number">1</span>,</span><br><span class="line">            <span class="string">&#x27;y2&#x27;</span>: <span class="number">3</span> * x + <span class="number">1.2</span>,</span><br><span class="line">            <span class="string">&#x27;mean&#x27;</span>: <span class="number">0.5</span> * x * np.cos(<span class="number">2</span>*x) + <span class="number">2.5</span> * x + <span class="number">1.1</span>&#125;</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line"></span><br><span class="line"><span class="comment">#填充两条线之间的颜色</span></span><br><span class="line">ax.fill_between(<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y1&#x27;</span>, <span class="string">&#x27;y2&#x27;</span>, color=<span class="string">&#x27;yellow&#x27;</span>, data=data_obj)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot the &quot;centerline&quot; with `plot`</span></span><br><span class="line">ax.plot(<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;mean&#x27;</span>, color=<span class="string">&#x27;black&#x27;</span>, data=data_obj)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>发现上面的作图，在数据部分只传入了字符串，这些字符串对一个这 data_obj 中的关键字，当以这种方式作画时，将会在传入给 data 中寻找对应关键字的数据来绘图。</p></div><h2 id="2-2-散点图"><a href="#2-2-散点图" class="headerlink" title="2.2 散点图"></a>2.2 散点图</h2><div class="story post-story"><p>只画点，但是不用线连接起来。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = np.arange(<span class="number">10</span>)</span><br><span class="line">y = np.random.randn(<span class="number">10</span>)</span><br><span class="line">plt.scatter(x, y, color=<span class="string">&#x27;red&#x27;</span>, marker=<span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div><h2 id="2-3-条形图"><a href="#2-3-条形图" class="headerlink" title="2.3 条形图"></a>2.3 条形图</h2><div class="story post-story"><p>条形图分两种，一种是水平的，一种是垂直的，见下例子：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">1</span>)</span><br><span class="line">x = np.arange(<span class="number">5</span>)</span><br><span class="line">y = np.random.randn(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">fig, axes = plt.subplots(ncols=<span class="number">2</span>, figsize=plt.figaspect(<span class="number">1.</span>/<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">vert_bars = axes[<span class="number">0</span>].bar(x, y, color=<span class="string">&#x27;lightblue&#x27;</span>, align=<span class="string">&#x27;center&#x27;</span>)</span><br><span class="line">horiz_bars = axes[<span class="number">1</span>].barh(x, y, color=<span class="string">&#x27;lightblue&#x27;</span>, align=<span class="string">&#x27;center&#x27;</span>)</span><br><span class="line"><span class="comment">#在水平或者垂直方向上画线</span></span><br><span class="line">axes[<span class="number">0</span>].axhline(<span class="number">0</span>, color=<span class="string">&#x27;gray&#x27;</span>, linewidth=<span class="number">2</span>)</span><br><span class="line">axes[<span class="number">1</span>].axvline(<span class="number">0</span>, color=<span class="string">&#x27;gray&#x27;</span>, linewidth=<span class="number">2</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>条形图还返回了一个Artists 数组，对应着每个条形，例如上图 Artists 数组的大小为5，我们可以通过这些 Artists 对条形图的样式进行更改，如下例：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots()</span><br><span class="line">vert_bars = ax.bar(x, y, color=<span class="string">&#x27;lightblue&#x27;</span>, align=<span class="string">&#x27;center&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># We could have also done this with two separate calls to `ax.bar` and numpy boolean indexing.</span></span><br><span class="line"><span class="keyword">for</span> bar, height <span class="keyword">in</span> <span class="built_in">zip</span>(vert_bars, y):</span><br><span class="line">    <span class="keyword">if</span> height &lt; <span class="number">0</span>:</span><br><span class="line">        bar.<span class="built_in">set</span>(edgecolor=<span class="string">&#x27;darkred&#x27;</span>, color=<span class="string">&#x27;salmon&#x27;</span>, linewidth=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div><h2 id="2-4-直方图"><a href="#2-4-直方图" class="headerlink" title="2.4 直方图"></a>2.4 直方图</h2><div class="story post-story"><p>直方图用于统计数据出现的次数或者频率，有多种参数可以调整，见下例：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">19680801</span>)</span><br><span class="line"></span><br><span class="line">n_bins = <span class="number">10</span></span><br><span class="line">x = np.random.randn(<span class="number">1000</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">fig, axes = plt.subplots(nrows=<span class="number">2</span>, ncols=<span class="number">2</span>)</span><br><span class="line">ax0, ax1, ax2, ax3 = axes.flatten()</span><br><span class="line"></span><br><span class="line">colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;tan&#x27;</span>, <span class="string">&#x27;lime&#x27;</span>]</span><br><span class="line">ax0.hist(x, n_bins, density=<span class="literal">True</span>, histtype=<span class="string">&#x27;bar&#x27;</span>, color=colors, label=colors)</span><br><span class="line">ax0.legend(prop=&#123;<span class="string">&#x27;size&#x27;</span>: <span class="number">10</span>&#125;)</span><br><span class="line">ax0.set_title(<span class="string">&#x27;bars with legend&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ax1.hist(x, n_bins, density=<span class="literal">True</span>, histtype=<span class="string">&#x27;barstacked&#x27;</span>)</span><br><span class="line">ax1.set_title(<span class="string">&#x27;stacked bar&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ax2.hist(x,  histtype=<span class="string">&#x27;barstacked&#x27;</span>, rwidth=<span class="number">0.9</span>)</span><br><span class="line"></span><br><span class="line">ax3.hist(x[:, <span class="number">0</span>], rwidth=<span class="number">0.9</span>)</span><br><span class="line">ax3.set_title(<span class="string">&#x27;different sample sizes&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fig.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>参数中density控制Y轴是概率还是数量，与返回的第一个的变量对应。histtype控制着直方图的样式，默认是 ‘bar’，对于多个条形时就相邻的方式呈现如子图1， ‘barstacked’ 就是叠在一起，如子图2、3。 rwidth 控制着宽度，这样可以空出一些间隙，比较图2、3. 图4是只有一条数据时。</p></div><h2 id="2-5-饼图"><a href="#2-5-饼图" class="headerlink" title="2.5 饼图"></a>2.5 饼图</h2><div class="story post-story"><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">labels = <span class="string">&#x27;Frogs&#x27;</span>, <span class="string">&#x27;Hogs&#x27;</span>, <span class="string">&#x27;Dogs&#x27;</span>, <span class="string">&#x27;Logs&#x27;</span></span><br><span class="line">sizes = [<span class="number">15</span>, <span class="number">30</span>, <span class="number">45</span>, <span class="number">10</span>]</span><br><span class="line">explode = (<span class="number">0</span>, <span class="number">0.1</span>, <span class="number">0</span>, <span class="number">0</span>)  <span class="comment"># only &quot;explode&quot; the 2nd slice (i.e. &#x27;Hogs&#x27;)</span></span><br><span class="line"></span><br><span class="line">fig1, (ax1, ax2) = plt.subplots(<span class="number">2</span>)</span><br><span class="line">ax1.pie(sizes, labels=labels, autopct=<span class="string">&#x27;%1.1f%%&#x27;</span>, shadow=<span class="literal">True</span>)</span><br><span class="line">ax1.axis(<span class="string">&#x27;equal&#x27;</span>)</span><br><span class="line">ax2.pie(sizes, autopct=<span class="string">&#x27;%1.2f%%&#x27;</span>, shadow=<span class="literal">True</span>, startangle=<span class="number">90</span>, explode=explode,</span><br><span class="line">    pctdistance=<span class="number">1.12</span>)</span><br><span class="line">ax2.axis(<span class="string">&#x27;equal&#x27;</span>)</span><br><span class="line">ax2.legend(labels=labels, loc=<span class="string">&#x27;upper right&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>饼图自动根据数据的百分比画饼.。labels是各个块的标签，如子图一。autopct=%1.1f%%表示格式化百分比精确输出，explode，突出某些块，不同的值突出的效果不一样。pctdistance=1.12百分比距离圆心的距离，默认是0.6.</p></div><h2 id="2-6-箱形图"><a href="#2-6-箱形图" class="headerlink" title="2.6 箱形图"></a>2.6 箱形图</h2><div class="story post-story"><p>为了专注于如何画图，省去数据的处理部分。 data 的 shape 为 (n, )， data2 的 shape 为 (n, 3)。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fig, (ax1, ax2) = plt.subplots(<span class="number">2</span>)</span><br><span class="line">ax1.boxplot(data)</span><br><span class="line">ax2.boxplot(data2, vert=<span class="literal">False</span>) <span class="comment">#控制方向</span></span><br></pre></td></tr></table></figure><p>2.7 泡泡图<br>散点图的一种，加入了第三个值 s 可以理解成普通散点，画的是二维，泡泡图体现了Z的大小，如下例：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">19680801</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">N = <span class="number">50</span></span><br><span class="line">x = np.random.rand(N)</span><br><span class="line">y = np.random.rand(N)</span><br><span class="line">colors = np.random.rand(N)</span><br><span class="line">area = (<span class="number">30</span> * np.random.rand(N))**<span class="number">2</span>  <span class="comment"># 0 to 15 point radii</span></span><br><span class="line"></span><br><span class="line">plt.scatter(x, y, s=area, c=colors, alpha=<span class="number">0.5</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div><h2 id="2-8-等高线（轮廓图）"><a href="#2-8-等高线（轮廓图）" class="headerlink" title="2.8 等高线（轮廓图）"></a>2.8 等高线（轮廓图）</h2><div class="story post-story"><p>有时候需要描绘边界的时候，就会用到轮廓图，机器学习用的决策边界也常用轮廓图来绘画，见下例：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fig, (ax1, ax2) = plt.subplots(<span class="number">2</span>)</span><br><span class="line">x = np.arange(-<span class="number">5</span>, <span class="number">5</span>, <span class="number">0.1</span>)</span><br><span class="line">y = np.arange(-<span class="number">5</span>, <span class="number">5</span>, <span class="number">0.1</span>)</span><br><span class="line">xx, yy = np.meshgrid(x, y, sparse=<span class="literal">True</span>)</span><br><span class="line">z = np.sin(xx**<span class="number">2</span> + yy**<span class="number">2</span>) / (xx**<span class="number">2</span> + yy**<span class="number">2</span>)</span><br><span class="line">ax1.contourf(x, y, z)</span><br><span class="line">ax2.contour(x, y, z)</span><br></pre></td></tr></table></figure><p>上面画了两个一样的轮廓图，contourf会填充轮廓线之间的颜色。数据x, y, z通常是具有相同 shape 的二维矩阵。x, y 可以为一维向量，但是必需有 z.shape = (y.n, x.n) ，这里 y.n 和 x.n 分别表示x、y的长度。Z通常表示的是距离X-Y平面的距离，传入X、Y则是控制了绘制等高线的范围。</p><h1 id="3-布局、图例说明、边界等"><a href="#3-布局、图例说明、边界等" class="headerlink" title="3 布局、图例说明、边界等"></a>3 布局、图例说明、边界等</h1></div><h2 id="3-1区间上下限"><a href="#3-1区间上下限" class="headerlink" title="3.1区间上下限"></a>3.1区间上下限</h2><div class="story post-story"><p>当绘画完成后，会发现X、Y轴的区间是会自动调整的，并不是跟我们传入的X、Y轴数据中的最值相同。为了调整区间我们使用下面的方式：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ax.set_xlim([xmin, xmax])   <span class="comment">#设置X轴的区间</span></span><br><span class="line">ax.set_ylim([ymin, ymax])   <span class="comment">#Y轴区间</span></span><br><span class="line">ax.axis([xmin, xmax, ymin, ymax])   <span class="comment">#X、Y轴区间</span></span><br><span class="line">ax.set_ylim(bottom=-<span class="number">10</span>)     <span class="comment">#Y轴下限</span></span><br><span class="line">ax.set_xlim(right=<span class="number">25</span>)       <span class="comment">#X轴上限</span></span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">2</span>*np.pi)</span><br><span class="line">y = np.sin(x)</span><br><span class="line">fig, (ax1, ax2) = plt.subplots(<span class="number">2</span>)</span><br><span class="line">ax1.plot(x, y)</span><br><span class="line">ax2.plot(x, y)</span><br><span class="line">ax2.set_xlim([-<span class="number">1</span>, <span class="number">6</span>])</span><br><span class="line">ax2.set_ylim([-<span class="number">1</span>, <span class="number">3</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>可以看出修改了区间之后影响了图片显示的效果。</p></div><h2 id="3-2-图例说明"><a href="#3-2-图例说明" class="headerlink" title="3.2 图例说明"></a>3.2 图例说明</h2><div class="story post-story"><p>我们如果我们在一个Axes上做多次绘画，那么可能出现分不清哪条线或点所代表的意思。这个时间添加图例说明，就可以解决这个问题了，见下例：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots()</span><br><span class="line">ax.plot([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">10</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">30</span>], label=<span class="string">&#x27;Philadelphia&#x27;</span>)</span><br><span class="line">ax.plot([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">30</span>, <span class="number">23</span>, <span class="number">13</span>, <span class="number">4</span>], label=<span class="string">&#x27;Boston&#x27;</span>)</span><br><span class="line">ax.scatter([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">20</span>, <span class="number">10</span>, <span class="number">30</span>, <span class="number">15</span>], label=<span class="string">&#x27;Point&#x27;</span>)</span><br><span class="line">ax.<span class="built_in">set</span>(ylabel=<span class="string">&#x27;Temperature (deg C)&#x27;</span>, xlabel=<span class="string">&#x27;Time&#x27;</span>, title=<span class="string">&#x27;A tale of two cities&#x27;</span>)</span><br><span class="line">ax.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>在绘图时传入 label 参数，并最后调用ax.legend()显示体力说明，对于 legend 还是传入参数，控制图例说明显示的位置：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Location StringLocation Code</span><br><span class="line">‘best’<span class="number">0</span></span><br><span class="line">‘upper right’<span class="number">1</span></span><br><span class="line">‘upper left’<span class="number">2</span></span><br><span class="line">‘lower left’<span class="number">3</span></span><br><span class="line">‘lower right’<span class="number">4</span></span><br><span class="line">‘right’<span class="number">5</span></span><br><span class="line">‘center left’<span class="number">6</span></span><br><span class="line">‘center right’<span class="number">7</span></span><br><span class="line">‘lower center’<span class="number">8</span></span><br><span class="line">‘upper center’<span class="number">9</span></span><br><span class="line">‘center’<span class="number">10</span></span><br></pre></td></tr></table></figure></div><h2 id="3-3-区间分段"><a href="#3-3-区间分段" class="headerlink" title="3.3 区间分段"></a>3.3 区间分段</h2><div class="story post-story"><p>默认情况下，绘图结束之后，Axes 会自动的控制区间的分段。见下例：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">data = [(<span class="string">&#x27;apples&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;oranges&#x27;</span>, <span class="number">3</span>), (<span class="string">&#x27;peaches&#x27;</span>, <span class="number">1</span>)]</span><br><span class="line">fruit, value = <span class="built_in">zip</span>(*data)</span><br><span class="line"></span><br><span class="line">fig, (ax1, ax2) = plt.subplots(<span class="number">2</span>)</span><br><span class="line">x = np.arange(<span class="built_in">len</span>(fruit))</span><br><span class="line">ax1.bar(x, value, align=<span class="string">&#x27;center&#x27;</span>, color=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">ax2.bar(x, value, align=<span class="string">&#x27;center&#x27;</span>, color=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ax2.<span class="built_in">set</span>(xticks=x, xticklabels=fruit)</span><br><span class="line"></span><br><span class="line"><span class="comment">#ax.tick_params(axis=&#x27;y&#x27;, direction=&#x27;inout&#x27;, length=10) #修改 ticks 的方向以及长度</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>上面不仅修改了X轴的区间段，并且修改了显示的信息为文本。</p></div><h2 id="3-4-布局"><a href="#3-4-布局" class="headerlink" title="3.4 布局"></a>3.4 布局</h2><div class="story post-story"><p>当我们绘画多个子图时，就会有一些美观的问题存在，例如子图之间的间隔，子图与画板的外边间距以及子图的内边距，下面说明这个问题：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fig, axes = plt.subplots(<span class="number">2</span>, <span class="number">2</span>, figsize=(<span class="number">9</span>, <span class="number">9</span>))</span><br><span class="line">fig.subplots_adjust(wspace=<span class="number">0.5</span>, hspace=<span class="number">0.3</span>,</span><br><span class="line">                    left=<span class="number">0.125</span>, right=<span class="number">0.9</span>,</span><br><span class="line">                    top=<span class="number">0.9</span>,    bottom=<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#fig.tight_layout() #自动调整布局，使标题之间不重叠</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>通过fig.subplots_adjust()我们修改了子图水平之间的间隔wspace=0.5，垂直方向上的间距hspace=0.3，左边距left=0.125 等等，这里数值都是百分比的。以 [0, 1] 为区间，选择left、right、bottom、top 注意 top 和 right 是 0.9 表示上、右边距为百分之10。不确定如果调整的时候，fig.tight_layout()是一个很好的选择。之前说到了内边距，内边距是子图的，也就是 Axes 对象，所以这样使用 ax.margins(x=0.1, y=0.1)，当值传入一个值时，表示同时修改水平和垂直方向的内边距。</p><p>调整使他们使用一样的X、Y轴：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fig, (ax1, ax2) = plt.subplots(<span class="number">1</span>, <span class="number">2</span>, sharex=<span class="literal">True</span>, sharey=<span class="literal">True</span>)</span><br><span class="line">ax1.plot([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">ax2.plot([<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div><h2 id="3-5-轴相关"><a href="#3-5-轴相关" class="headerlink" title="3.5 轴相关"></a>3.5 轴相关</h2><div class="story post-story"><p>改变边界的位置，去掉四周的边框：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots()</span><br><span class="line">ax.plot([-<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [-<span class="number">10</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">5</span>])</span><br><span class="line">ax.spines[<span class="string">&#x27;top&#x27;</span>].set_visible(<span class="literal">False</span>)     <span class="comment">#顶边界不可见</span></span><br><span class="line">ax.xaxis.set_ticks_position(<span class="string">&#x27;bottom&#x27;</span>)  <span class="comment"># ticks 的位置为下方，分上下的。</span></span><br><span class="line">ax.spines[<span class="string">&#x27;right&#x27;</span>].set_visible(<span class="literal">False</span>)   <span class="comment">#右边界不可见</span></span><br><span class="line">ax.yaxis.set_ticks_position(<span class="string">&#x27;left&#x27;</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># &quot;outward&quot;</span></span><br><span class="line"><span class="comment"># 移动左、下边界离 Axes 10 个距离</span></span><br><span class="line"><span class="comment">#ax.spines[&#x27;bottom&#x27;].set_position((&#x27;outward&#x27;, 10))</span></span><br><span class="line"><span class="comment">#ax.spines[&#x27;left&#x27;].set_position((&#x27;outward&#x27;, 10))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># &quot;data&quot;</span></span><br><span class="line"><span class="comment"># 移动左、下边界到 (0, 0) 处相交</span></span><br><span class="line">ax.spines[<span class="string">&#x27;bottom&#x27;</span>].set_position((<span class="string">&#x27;data&#x27;</span>, <span class="number">0</span>))</span><br><span class="line">ax.spines[<span class="string">&#x27;left&#x27;</span>].set_position((<span class="string">&#x27;data&#x27;</span>, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># &quot;axes&quot;</span></span><br><span class="line"><span class="comment"># 移动边界，按 Axes 的百分比位置</span></span><br><span class="line"><span class="comment">#ax.spines[&#x27;bottom&#x27;].set_position((&#x27;axes&#x27;, 0.75))</span></span><br><span class="line"><span class="comment">#ax.spines[&#x27;left&#x27;].set_position((&#x27;axes&#x27;, 0.3))</span></span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;前提：你已经安装了python并且在安装时勾选了Add Python to PATH&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;打开c</summary>
      
    
    
    
    
    <category term="python" scheme="https://billma.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>从零开始C++——1</title>
    <link href="https://billma.top/2021/08/26/cpp-begin-1/"/>
    <id>https://billma.top/2021/08/26/cpp-begin-1/</id>
    <published>2021-08-26T08:23:43.000Z</published>
    <updated>2021-10-01T06:52:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文为原创文章，请转载时一定要注明作者：Bill Ma，网址<a href="https://billma.top/">https://billma.top</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This blog is licensed under CC BY-NC-SA 4.0 unless stating additionally.</span><br></pre></td></tr></table></figure><h1 id="一-准备工作"><a href="#一-准备工作" class="headerlink" title="一.准备工作"></a>一.准备工作</h1><p>看到这篇文章，说明你已经有了这个想法。那么，想要编程，总得要一个软件吧。如果你已经有一定的其他的语言基础，知道了编程软件的基本架构，建议你使用Microsoft的Visual Studio Code。如果你对编程一无所知，你可以使用小白软件Dev C++。</p><p><a href="https://sm.myapp.com/original/Development/Dev-Cpp_5.11_TDM-GCC_4.9.2_Setup.exe">点此下载DevC++</a></p><p><a href="https://dl.softmgr.qq.com/original/Development/VSCodeUserSetup-x64-1.58.2.exe">点此下载MicrosoftVisualStudioCode</a></p><p>本教程就以Dev C++为实例。</p><h2 id="1-启动界面"><a href="#1-启动界面" class="headerlink" title="1.启动界面"></a>1.启动界面</h2><div class="story post-story"><p>启动界面，发现该界面分为四部分。上面是菜单栏和一堆按钮，右侧是一块大空白，左侧是“项目管理，查看类和调试”，下面是调试。</p><p><img src="https://billmarepo.github.io/cpp-begin-1-image/1.JPG" class="lazyload" data-srcset="https://billmarepo.github.io/cpp-begin-1-image/1.JPG" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="启动界面"></p><p>接下来，按Ctrl+N，新建一个源代码。</p><p><img src="https://billmarepo.github.io/cpp-begin-1-image/2.JPG" class="lazyload" data-srcset="https://billmarepo.github.io/cpp-begin-1-image/2.JPG" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div><h2 id="2-了解C-基本构造"><a href="#2-了解C-基本构造" class="headerlink" title="2.了解C++基本构造"></a>2.了解C++基本构造</h2><div class="story post-story"><h3 id="a-头文件"><a href="#a-头文件" class="headerlink" title="a.头文件"></a>a.头文件</h3><p>头文件以 <code>#include</code> 开头。你在C++中所用到的所有函数都包含在各种各样的头文件中。比如说，最常见的输出函数printf()就在cstdio头文件中。再比如说，输入输出流cin和cout就在iostream中。如果你懒得记哪个函数在哪个函数库头文件里，你可以偷懒，只写一个：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>这个头文件包含了C++大多数常用头文件。你写了这个就不用再写其它头文件了。但是注意，bits/stdc++.h不包含所有头文件。比如说，比较常用的<code>#include&lt;conio.h&gt;</code>和<code>#include &lt;windows.h&gt;</code>就不在其中。</p><h3 id="b-函数"><a href="#b-函数" class="headerlink" title="b.函数"></a>b.函数</h3><p>函数有很多种，现在讲为时过早，日后再议。现在要知道的是主函数。主函数是C++代码的核心部分。C++所有代码都包含在主函数内。在主函数的最后，需要以<code>return 0;</code>为结尾。</p><h3 id="c-变量"><a href="#c-变量" class="headerlink" title="c.变量"></a>c.变量</h3><p>C++提供了许多变量。其中包含</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//整形变量(存放整数)</span></span><br><span class="line"><span class="keyword">int</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">//浮点型函数</span></span><br><span class="line"><span class="keyword">float</span><span class="comment">//单精度</span></span><br><span class="line"><span class="keyword">double</span><span class="comment">//双精度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符/字符串</span></span><br><span class="line"><span class="keyword">char</span><span class="comment">//单个字符</span></span><br><span class="line">string<span class="comment">//字符串</span></span><br><span class="line"><span class="keyword">wchar_t</span><span class="comment">//单个宽字符，即非英文或数字</span></span><br><span class="line">wstring<span class="comment">//宽字符串</span></span><br></pre></td></tr></table></figure><p>注意，上图的//代表注释，不参与主要运算。</p><p>变量声明方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">char</span> b;</span><br><span class="line">string c;</span><br></pre></td></tr></table></figure><p>哦，差点忘了，你想要运行你的程序，只需要按F11或者选择编译即可。</p><h1 id="2-你的第一个程序"><a href="#2-你的第一个程序" class="headerlink" title="2.你的第一个程序"></a>2.你的第一个程序</h1><p>先从一个例子开始：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Hello World!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="1-标准输入输出"><a href="#1-标准输入输出" class="headerlink" title="1.标准输入输出"></a>1.标准输入输出</h2><div class="story post-story"><figure class="highlight plaintext"><figcaption><span><iostream>```包含了cout,cin,endl等。cout表示输出，cin表示输入，endl是换行符。C++将键盘作为输入设备，屏幕等为输出设备。而且，C++将你输入的和输出的当作一个流，比如说以下两句话是等价的：</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```C++</span><br><span class="line">cout&lt;&lt;&quot;helloworld!&quot;&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&quot;hello&quot;&lt;&lt;&quot;world!&quot;&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>因为C++是输出流，所以先把hello流出来再把world流出来，和流出来helloworld是一样的。<br>下面是cout和cin的具体用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a,b,c,d</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;<span class="comment">//这里没有endl</span></span><br><span class="line">cout&lt;&lt;a&lt;&lt;b&lt;&lt;c&lt;&lt;endl&lt;&lt;d&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>输入： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">32 44 23 23</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">324423</span><br><span class="line">23</span><br></pre></td></tr></table></figure><p>为什么a和b和c中间没有空格呢？很简单，因为你没有加空格啊。a和b都是数字，没有空格。</p><p>那么，下面代码会输出什么呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;<span class="number">12</span>&lt;&lt;<span class="number">34</span>&lt;&lt;<span class="number">56</span>&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;  <span class="number">12</span>  &lt;&lt;  <span class="number">34</span>  &lt;&lt;  <span class="number">56</span>  &lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;12&quot;</span>&lt;&lt;<span class="string">&quot;34&quot;</span>&lt;&lt;<span class="string">&quot;56&quot;</span>&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;  12  &quot;</span>&lt;&lt;<span class="string">&quot;  34  &quot;</span>&lt;&lt;<span class="string">&quot;  56  &quot;</span>&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123456</span></span><br><span class="line"><span class="number">123456</span></span><br><span class="line"><span class="number">123456</span></span><br><span class="line"><span class="number">12</span>    <span class="number">34</span>    <span class="number">56</span>  </span><br></pre></td></tr></table></figure><p>有人会问，为什么2也是123456？因为在每两个 &lt;&lt; 中，只能有一个量（变量和常量），你用双引号引起来的叫字符串，只有在变量或者字符串里的才能被输出。</p><h1 id="3-你的第二个程序"><a href="#3-你的第二个程序" class="headerlink" title="3.你的第二个程序"></a>3.你的第二个程序</h1><p>这个程序要稍微复杂一点了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    cin&gt;&gt;a;</span><br><span class="line">    a=a+<span class="number">1</span>;</span><br><span class="line">    cout&lt;&lt;a;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入：1，输出：2</p><p>这个a=a+1不是非法语句，而是正确的。这句话翻译成中文就是：a在你原来a的基础上再+1</p><h1 id="4-你的第三个程序"><a href="#4-你的第三个程序" class="headerlink" title="4.你的第三个程序"></a>4.你的第三个程序</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> a=<span class="number">1</span>;a&lt;=<span class="number">7</span>;a++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a==<span class="number">1</span>||a&gt;=<span class="number">6</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;1&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a&lt;=<span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;2&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a&lt;<span class="number">5</span>&amp;&amp;a&gt;<span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;3&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;4&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">3</span><br><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>什么意思呢？首先来看<code>for(int a=1;a&lt;=7;a++)</code>,这句话意思是a从1开始技术</p><h1 id="未完待续……"><a href="#未完待续……" class="headerlink" title="未完待续……"></a>未完待续……</h1></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文为原创文章，请转载时一定要注明作者：Bill Ma，网址&lt;a href=&quot;https://billma.top/&quot;&gt;https://billma.top&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td</summary>
      
    
    
    
    
    <category term="teach，computer，cpp" scheme="https://billma.top/tags/teach%EF%BC%8Ccomputer%EF%BC%8Ccpp/"/>
    
  </entry>
  
  <entry>
    <title>C++ 中如何处理错误和异常？</title>
    <link href="https://billma.top/2021/08/26/cpp-constructor-exception/"/>
    <id>https://billma.top/2021/08/26/cpp-constructor-exception/</id>
    <published>2021-08-26T08:13:08.000Z</published>
    <updated>2021-09-04T13:03:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><div class="story post-story"><p>用C++写代码的时候总是避免不了处理错误，一般来说有两种方式，通过函数的返回值或者抛出异常。C语言的错误处理一律是通过函数的返回值来判断的，一般是返回0、NULL或者-1表示错误，或者直接返回错误代码，具体是哪种方式没有统一的规定，各种API也各有各的偏好。譬如fopen函数，当成功时返回文件指针，失败时返回NULL，而POSIX标准的open函数则在成功时返回0或者正数，失败时返回-1，然后需要再通过全局变量errno来判断具体错误是什么，配套的还有一系列perror、strerror这样的函数。</p></div><h2 id="2-C-的错误处理方式"><a href="#2-C-的错误处理方式" class="headerlink" title="2.C++的错误处理方式"></a>2.C++的错误处理方式</h2><div class="story post-story"><p>C++号称向下兼容C语言，于是就将C语言通过返回值的错误处理方式也搬了进来。但C++最大的不同是引入了异常机制，可以用throw产生一个异常，并通过try和catch来捕获。于是就混乱了，到底是什么时候使用返回值表示错误，什么时候使用异常呢？首先简单谈论一下异常和返回值的特点。</p><h3 id="异常的优点"><a href="#异常的优点" class="headerlink" title="异常的优点"></a>异常的优点</h3><p>错误信息丰富，便于获得错误现场</p><p>代码相对简短，不需要判断每个函数的返回值</p><h3 id="异常的缺点"><a href="#异常的缺点" class="headerlink" title="异常的缺点"></a>异常的缺点</h3><p>使控制流变得复杂，难以追踪</p><p>开销相对较大</p><h3 id="返回值的优点"><a href="#返回值的优点" class="headerlink" title="返回值的优点"></a>返回值的优点</h3><p>性能开销相对小</p><p>避免定义异常类</p><h3 id="返回值的缺点"><a href="#返回值的缺点" class="headerlink" title="返回值的缺点"></a>返回值的缺点</h3><p>程序员经常「忘记」处理错误返回值</p><p>每个可能产生错误的函数在调用后都需要判断是否有错误</p><p>与「真正的」返回值混用，需要规定一个错误代码（通常是0、-1或NULL）<br>使用异常还是返回值</p><p>我的观点是，用异常来表示真正的、而且不太可能发生的错误。所谓不太可能发生的错误，指的是真正难以预料，但发生了却又不得不单独处理的，譬如内存耗尽、读文件发生故障。而在一个字符串中查找一个子串，如果没有找到显然应该是用一个特殊的返回值（如-1），而不应该抛出一个异常。</p><p>一句话来概况就是不要用异常代替正常的控制流，只有当程序真的「不正常」的时候，才使用异常。反过来说，当程序真正发生错误了，一定要使用异常而不是返回一个错误代码，因为错误代码总是倾向于被忽略。如果要保证一个以返回值来表示错误代码的函数的错误正确地向上传递，需要在每个调用了可能产生错误的函数后面都判断一下是否发生了错误，一旦发生了不可解决的错误，就要终止当前函数（并释放当前函数申请的资源），然后向上传递错误。这样一来错误处理代码会被重复地写好几遍，十分冗杂，譬如下面代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;path/to/file&quot;</span>, O_RDONLY);</span><br><span class="line">  <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> ERROR_OPEN;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span>* array = <span class="keyword">new</span>[n];</span><br><span class="line">  <span class="keyword">int</span> err;</span><br><span class="line">  err = <span class="built_in">do_something</span>(fd, array);</span><br><span class="line">  <span class="keyword">if</span> (err != SUCCESS) &#123;</span><br><span class="line">     <span class="keyword">delete</span>[] array;</span><br><span class="line">     <span class="keyword">return</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">  err = <span class="built_in">do_other_thing</span>();</span><br><span class="line">  <span class="keyword">if</span> (err != SUCCESS) &#123;</span><br><span class="line">     <span class="keyword">delete</span>[] array;</span><br><span class="line">     <span class="keyword">return</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">  err = <span class="built_in">do_more_thing</span>();</span><br><span class="line">  <span class="keyword">if</span> (err != SUCCESS) &#123;</span><br><span class="line">     <span class="keyword">delete</span>[] array;</span><br><span class="line">     <span class="keyword">return</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span>[] array;</span><br><span class="line">  <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对使用异常容易增加函数出口的指控其实是不成立的，因为即使使用返回值，这些出口也是免不了的，除非程序员有意或无意忽略掉，但异常是不可忽略的。如果你认为可以把判断错误的if语句缩写到一行使代码变得「更清晰」，那么我只能说是自欺欺人。</p><p>有些错误几乎总是可以被立即恢复（譬如前面所说的查找一个字符串不存在的子串，甚至都不能说这是一个「错误」），而且返回值本身就传递一定信息，就不需要使用异常了。</p><p>鉴于C++没有统一的ABI，并不建议在模块的接口上使用异常。如果要使用，就要把可能曝露给用户的异常全部声明出来，不要把其他类型的异常丢给用户去处理，尤其是内部状态——模块的使用者通常也不会关心模块内部具体是哪条语句发生错误了。</p></div><h2 id="3-构造函数中的错误"><a href="#3-构造函数中的错误" class="headerlink" title="3.构造函数中的错误"></a>3.构造函数中的错误</h2><div class="story post-story"><p>有一个相当实际的问题是，如何处理构造函数的错误？我们都知道构造函数是没有返回值的，怎么办呢？通常有三种常见的处理方法，标记错误状态、使用一个额外的initialize函数来初始化，或者直接抛出异常。</p><p>合格的C++程序员都知道C++的析构函数中不应该抛出异常，一旦析构函数中的异常没有被捕获，整个程序都要被中止掉。于是许多人就对在构造函数中抛出异常也产生了对等的恐惧，宁可使用一个额外的初始化函数在里面初始化对象的状态并抛出异常（或者返回错误代码）。这样做违背了对象产生和初始化要在一起的原则，强迫用户记住调用一个额外的初始化函数，一旦没有调用直接使用了其他函数，其行为很可能是未定义的。</p><p>使用初始化函数的惟一好处可能是避免了手动释放资源（释放资源的操作交给析构函数来做），因为C++的一个特点是构造函数抛出异常以后析构函数是不会被调用的，所以如果你在构造函数里面申请了内存或者打开了资源，需要在异常产生时关闭。但想想看其实并不能完全避免，因为有些资源可能是要在可能产生错误的函数调用过后才被申请的，还是无法完全避免手工的释放。</p><p>标记错误状态也是一种常见的形式，譬如STL中的ifstream类，当构造时传入一个无法访问的文件作为参数，它不会返回任何错误，而是标记的内部状态为不可用，用户需要手工通过is_open()函数来判断是否打开成功了。同时它还有good()、fail()两个函数，同时也重载了bool类型转换运算符用于在if语句中判断。标记状态的方法在实践中相当丑陋，因为在使用前总是需要判断它是否「真的创建成功了」。</p><p>最直接的方法还是在构造函数中抛出异常，它并不会向析构函数中抛出异常那样有严重的后果，只是需要注意的是抛出异常以后对象没有被创建成功，析构函数也不会被调用，所以应该自行把申请的资源全部都释放掉。</p></div><h2 id="4-如何在构造函数中捕获异常"><a href="#4-如何在构造函数中捕获异常" class="headerlink" title="4.如何在构造函数中捕获异常"></a>4.如何在构造函数中捕获异常</h2><div class="story post-story"><p>构造函数与普通函数有一个很不一样特性，就是构造函数可以有初始化列表，例如下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">B</span>(<span class="keyword">int</span> val) : <span class="built_in">val_</span>(val * val) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> val_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>(<span class="keyword">int</span> val) : <span class="built_in">b_</span>(val) &#123;</span><br><span class="line">    a_ = val;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> a_;</span><br><span class="line">  B b_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上的代码中A的构造函数的函数体的语句在执行之前会先调用B的构造函数，这时候问题在于，如果B的构造函数抛出了异常，A该如何捕获呢？一个迂回的做法是在A中把B的实例声明为指针，在构造函数和析构函数中分别创建和删除，这样就能捕获到异常了。不过，实际上是有更简单的做法的。下面我要介绍一个C++的很不常见的语法：函数作用域级别的异常捕获。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">B</span>(<span class="keyword">int</span> val) : <span class="built_in">val_</span>(val * val) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;wtf from B&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> val_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>(<span class="keyword">int</span> val) <span class="keyword">try</span> : <span class="built_in">b_</span>(val) &#123;</span><br><span class="line">    a_ = val;</span><br><span class="line">  &#125; <span class="built_in"><span class="keyword">catch</span></span> (runtime_error&amp; e) &#123;</span><br><span class="line">    cerr &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;wtf from A&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> a_;</span><br><span class="line">  B b_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意上面A的构造函数，在参数列表后和初始化列表前增加了try关键字，然后构造函数就被分割为了两部分，前面是初始化，后面是初始化时的错误处理。需要指出的是，catch块里面捕获到的异常不能被忽略，即catch块中必须有一个throw语句重新抛出异常，如果没有，则默认会将原来捕获到的异常重新抛出，这和一般的行为是不同的。例如下面代码运行可以发现A会将捕获到的异常原封不动抛出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>(<span class="keyword">int</span> val) <span class="keyword">try</span> : <span class="built_in">b_</span>(val) &#123;</span><br><span class="line">    a_ = val;</span><br><span class="line">  &#125; <span class="built_in"><span class="keyword">catch</span></span> (runtime_error&amp; e) &#123;</span><br><span class="line">    cerr &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> a_;</span><br><span class="line">  B b_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种语法是C++的标准，而且目前已经被所有的主流C++编译器支持（VS2010、g++ 4.2、clang 3.1），所以几乎不存在兼容性问题，大可放心使用。</p></div><h2 id="5-其他语言中的错误处理"><a href="#5-其他语言中的错误处理" class="headerlink" title="5.其他语言中的错误处理"></a>5.其他语言中的错误处理</h2><div class="story post-story"><p>Java倾向于大量使用异常，而且还把异常分为了两类分别是检查型异常(Checked Exception)和非检查型异常(Unchecked Exception)，检查型异常就是java.lang.Exception的子类，用于报告需要检查的错误，也就是正常的业务逻辑，错误主要是由用户产生的，方便恢复或给出提示，譬如打开不存在的文件。而非检查型异常则是真正的系统异常，通常由软件缺陷导致，如数组下标越界、错误的类型转换等，这类异常继承于java.lang.RuntimeException或java.lang.Error。</p><p>Python和Java一样也倾向于使用异常，并不一定真的发生故障才抛出异常，譬如字符串转换为整数，如果字符串不合法，Python会抛出一个ValueError异常。甚至Python的迭代器在调用next()时没有更多的结果时会抛出StopIteration 异常。这是典型的用异常来处理正常控制流的方法，在Python中被广泛使用。按照优秀C++代码的标准来看，这是典型的对异常的滥用，既复杂又有额外开销，不推荐使用，但在Python中这是一个广泛遵循的约定。</p><p>相较于Java和Python，Go的错误处理是另一个极端，Go语言则根本没有异常的概念，而是普遍采用返回值的方式来表示错误，同时还提供了panic和recover语法。由于Go有多返回值的特性，避免了错误代码占用返回结果的弊端，所以你可以经常看到函数的最后一个返回值是error类型。由于总是用返回值传递错误，你可以看到Go代码中耦合了大量的错误处理，几乎再每条函数调用语句之后都有一个判断错误是否发生的语句。panic和recover机制十分类似于异常，程序在遇到panic时会一层一层退出调用栈，直到遇到recover。不过recover只在defer中定义，相当于一个函数只有一个recover，而且被recover恢复后会回到错误发生处继续向下执行代码。Go语言倾向于把一般错误都作为返回值传递，除非是非常可怕的、除了重置状态几乎无法恢复错误才会被panic语句抛出。</p><p>Go语言的recover机制和异常比起来，反倒更像Visual Basic语言中的On Error GoTo label及Resume语法。这是一种非结构化的错误处理方式，具体是当声明有On Error GoTo label的函数发生错误以后，会调转到对应的行号，如果再遇到了Resume语句就会返回发生错误的语句后面的一条继续执行，例如下面这段代码：</p><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Sub</span> ErrorDemo</span><br><span class="line">    <span class="keyword">On</span> <span class="keyword">Error</span> <span class="keyword">GoTo</span> ErrorHandler</span><br><span class="line">    <span class="keyword">Dim</span> a <span class="keyword">as</span> <span class="type">Integer</span></span><br><span class="line">    a = <span class="number">1</span>/<span class="number">0</span> <span class="comment">&#x27; An error occurs.</span></span><br><span class="line">    Print a <span class="comment">&#x27; Go back here</span></span><br><span class="line">    <span class="keyword">Exit</span> <span class="keyword">Sub</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">ErrorHandler:</span></span><br><span class="line">    <span class="comment">&#x27; Code that handles errors.</span></span><br><span class="line">    <span class="keyword">Resume</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br></pre></td></tr></table></figure><p>Visual Basic中还有On Error Resume Next这样的万能错误处理语句，即遇到错误以后直接忽略并继续执行，这是一种非常危险而且不负责任的做法，但却可以在早期的Visual Basic代码中到处看到。事实上用返回值传递错误代码的时候许多人也并不处理而是直接忽略，这跟On Error Resume Next本质上没有什么区别，却比On Error Resume Next危害更大——因为On Error Resume Next至少还有个标记说明「老子就是这么不负责任」，但忽略错误返回值就难以被一眼发现了。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1.前言&quot;&gt;&lt;/a&gt;1.前言&lt;/h2&gt;&lt;div class=&quot;story post-story&quot;&gt;&lt;p&gt;用C++写代码的时候总是避免不了处理错误，一般来说有两种方式，通</summary>
      
    
    
    
    <category term="编程算法" scheme="https://billma.top/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>最长公共子串问题的后缀数组</title>
    <link href="https://billma.top/2021/08/26/lcs-suffix-array/"/>
    <id>https://billma.top/2021/08/26/lcs-suffix-array/</id>
    <published>2021-08-26T07:57:30.000Z</published>
    <updated>2021-09-04T13:04:14.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="最长公共子串"><a href="#最长公共子串" class="headerlink" title="最长公共子串"></a>最长公共子串</h3><p>最长公共子串(Longest Common Substring ,简称LCS)问题，是指求给定的一组字符串长度最大的共有的子串的问题。例如字符串”abcb”,“bca”,“acbc”的LCS就是”bc”。</p><p>求多串的LCS，显然穷举法是极端低效的算法。改进一些的算法是用一个串的每个后缀对其他所有串进行部分匹配，用KMP算法，时间复杂度为O(NL^2)，其中N为字符串个数，L为每个串的长度。更优秀的有广义后缀树的方法，时间可以达到 O(NL)。本文介绍一种基于后缀数组的LCS解法，利用二分查找技术，时间复杂度可以达到O(NLlogL)。</p><h3 id="最长公共子串问题的后缀数组解法"><a href="#最长公共子串问题的后缀数组解法" class="headerlink" title="最长公共子串问题的后缀数组解法"></a>最长公共子串问题的后缀数组解法</h3><p>关于后缀数组的构建方法以及Height数组的性质，本文不再具体介绍，可以参阅IOI国家集训队2004年论文《后缀数组》(许智磊)和IOI国家集训队2009年论文《后缀数组——处理字符串的有力工具》(罗穗骞)。</p><p>回顾一下后缀数组，SA[i]表示排名第i的后缀的位置，Height[i]表示后缀SA[i]和SA[i-1]的最长公共前缀(Longest Common Prefix,LCP)，简记为Height[i]=LCP(SA[i],SA[i-1])。连续的一段后缀SA[i..j]的最长公共前缀，就是H[i-1..j]的最小值，即LCP(SA[i..j])=Min(H[i-1..j])。</p><p>求N个串的最长公共子串，可以转化为求一些后缀的最长公共前缀的最大值，这些后缀应分属于N个串。具体方法如下：</p><p>设N个串分别为S1,S2,S3,…,SN，首先建立一个串S，把这N个串用不同的分隔符连接起来。S=S1[P1]S2[P2]S3…SN-1[PN-1]SN，P1,P2,…PN-1应为不同的N-1个不在字符集中的字符，作为分隔符(后面会解释为什么)。</p><p>接下来，求出字符串S的后缀数组和Height数组，可以用倍增算法，或DC3算法。</p><p>然后二分枚举答案A，假设N个串可以有长度为A的公共字串，并对A的可行性进行验证。如果验证A可行，A’(A’&lt; A)也一定可行，尝试增大A，反之尝试缩小A。最终可以取得A的最大可行值，就是这N个串的最长公共子串的长度。可以证明，尝试次数是O(logL)的。</p><p>于是问题就集中到了，如何验证给定的长度A是否为可行解。方法是，找出在Height数组中找出连续的一段Height[i..j]，使得i&lt;=k&lt;=j均满足Height[k]&gt;=A，并且i-1&lt;=k&lt;=j中，SA[k]分属于原有N个串S1..SN。如果能找到这样的一段，那么A就是可行解，否则A不是可行解。</p><p>具体查找i..j时，可以先从前到后枚举i的位置，如果发现Height[i]&gt;=A，则开始从i向后枚举j的位置，直到找到了Height[j+1] &lt; A，判断[i..j]这个区间内SA是否分属于S1..SN。如果满足，则A为可行解，然后直接返回，否则令i=j+1继续向后枚举。S中每个字符被访问了O(1)次，S的长度为NL+N-1，所以验证的时间复杂度为O(NL)。</p><p>到这里，我们就可以理解为什么分隔符P1..PN-1必须是不同的N-1个不在字符集中的字符了，因为这样才能保证S的后缀的公共前缀不会跨出一个原有串的范围。</p><p>后缀数组是一种处理字符串的强大的数据结构，配合LCP函数与Height数组的性质，后缀数组更是如虎添翼。利用后缀数组，容易地求出了多个串的LCS，而且时空复杂度也相当优秀了。虽然比起后缀树的解法有所不如，但其简明的思路和容易编程的特点却在实际的应用中并不输于后缀树。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;最长公共子串&quot;&gt;&lt;a href=&quot;#最长公共子串&quot; class=&quot;headerlink&quot; title=&quot;最长公共子串&quot;&gt;&lt;/a&gt;最长公共子串&lt;/h3&gt;&lt;p&gt;最长公共子串(Longest Common Substring ,简称LCS)问题，是指求给定的一组字符串长</summary>
      
    
    
    
    <category term="编程算法" scheme="https://billma.top/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>C语言中跨文件的全局变量</title>
    <link href="https://billma.top/2021/08/19/c-global-variables-in-multiple-files/"/>
    <id>https://billma.top/2021/08/19/c-global-variables-in-multiple-files/</id>
    <published>2021-08-19T08:07:04.000Z</published>
    <updated>2021-09-04T13:03:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>首先看一段代码</p><p><strong>func.c</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> buf = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  buf = <span class="number">2</span>;</span><br><span class="line">  <span class="comment">/*Do something else*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>main.c</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> buf;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  buf = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">func</span>();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, buf);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译两个文件，输出的结果是怎样的呢？一眼看上去，可能会输出1，因为两个全局变量buf在不同文件中，又没有extern声明，显然是两个嘛。然而实际上它的运行结果却是2，这说明了这两个文件中引用到的其实是一个变量！</p><p>这是为什么呢？原因是在编译时，C语言编译器将全局符号标记为strong和weak两类：</p><p>函数和初始化的全局符号被标记为strong<br>未初始化的全局符号被标记为weak<br>连接时，连接器对多重定义的全局符号的解析原则如下：</p><p>同一个符号不允许有多个strong定义；<br>假如一个符号有一个strong定义和多个weak定义，那么采用该符号的strong定义；<br>假如一个符号有多个weak定义，那么选取任意一个weak定义<br>由于两个变量一个初始化了，一个没有初始化，所以一个是strong，一个是weak，所以连接器在符号解析时会把他们当成一个。</p><p>如果我们把main.c中的buf也初始化了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> buf = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  buf = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">func</span>();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, buf);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次编译就会发现</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">duplicate symbol _buf in:</span><br><span class="line">    /var/folders/44/_cc501qx1jd1p5bfrjbk6b100000gn/T//ccZ87C6g.o</span><br><span class="line">    /var/folders/44/_cc501qx1jd1p5bfrjbk6b100000gn/T//ccZlES8n.o</span><br><span class="line">ld: 1 duplicate symbol for architecture x86_64</span><br><span class="line">collect2: ld returned 1 exit status</span><br></pre></td></tr></table></figure><p>这是因为两个全局变量都是strong的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;首先看一段代码&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;func.c&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;b</summary>
      
    
    
    
    <category term="编程算法" scheme="https://billma.top/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="computer,cpp" scheme="https://billma.top/tags/computer-cpp/"/>
    
  </entry>
  
  <entry>
    <title>世界最大同性交友网站七夕再搞事————remote  ：Support for password authentication was removed on August 13, 2021.</title>
    <link href="https://billma.top/2021/08/15/github-tokenerror/"/>
    <id>https://billma.top/2021/08/15/github-tokenerror/</id>
    <published>2021-08-15T07:39:00.000Z</published>
    <updated>2021-09-04T13:42:14.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>原创文章，转载注明出处！</strong></p><h3 id="1-问题背景-background"><a href="#1-问题背景-background" class="headerlink" title="1.问题背景-background"></a>1.问题背景-background</h3><p>如果你在七夕（没错就是2021年8月14日）<strong>的这一天去访问了全球最大的同性交友网站</strong>，<strong>又刚好去更新提交代码</strong>，<strong>或者你创建了一个新的仓库送给自己</strong>，<strong>又刚好想把这个仓库送给github</strong>，你就刚好会遇到这个问题：remote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead.<br>大概意思就是你原先的密码凭证从2021年8月13日开始就不能用了，必须使用个人访问令牌（personal access token），就是把你的密码替换成token！</p><p><strong>滚！我tm懒得弄！</strong></p><p><img src="https://i.postimg.cc/zG2L02b1/Q-R9-VOLZG-DIN2-V0-HF-S8.png" class="lazyload" data-srcset="https://i.postimg.cc/zG2L02b1/Q-R9-VOLZG-DIN2-V0-HF-S8.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="> </p><p> <strong>Github <a href="https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/">官方解释</a></strong></p><blockquote><p>We described our motivation as we announced similar changes to authenticating with the API as follows:</p></blockquote><blockquote><p>In recent years, GitHub customers have benefited from a number of security enhancements to GitHub.com, such as two-factor authentication, sign-in alerts, verified devices, preventing the use of compromised passwords, and WebAuthn support. These features make it more difficult for an attacker to take a password that’s been reused across multiple websites and use it to try to gain access to your GitHub account. Despite these improvements, for historical reasons customers without two-factor authentication enabled have been able to continue to authenticate Git and API operations using only their GitHub username and password.</p></blockquote><blockquote><p>Beginning August 13, 2021, we will no longer accept account passwords when authenticating Git operations and will require the use of token-based authentication, such as a personal access token (for developers) or an OAuth or GitHub App installation token (for integrators) for all authenticated Git operations on GitHub.com. You may also continue using SSH keys where you prefer.</p></blockquote><blockquote><p>Tokens offer a number of security benefits over password-based authentication:</p></blockquote><blockquote><p>1.Unique – tokens are specific to GitHub and can be generated per use or per device</p></blockquote><blockquote><p>2.Revocable – tokens can can be individually revoked at any time without needing to update unaffected credentials</p></blockquote><blockquote><p>3.Limited – tokens can be narrowly scoped to allow only the access necessary for the use case</p></blockquote><blockquote><p>4.Random – tokens are not subject to the types of dictionary or brute force attempts that simpler passwords that you need to remember or enter regularly might be</p></blockquote><p>大概意思就是：<strong>为了保证各位程序员的账户安全，我们已于2021年7月14日禁止大家在git及第三方应用上通过密码授权GitHub。以后将使用token令牌代替密码。</strong><br>（话说能活跃在全球最大同性交友网站的程序猿能有什么秘密值得如此加密。。。）</p><h3 id="2-什么是token令牌？"><a href="#2-什么是token令牌？" class="headerlink" title="2.什么是token令牌？"></a>2.什么是token令牌？</h3><p>token令牌相当于在第三方接口代替你密码的一个玩意，有点像强密码。但是，token令牌并不是只能有唯一一个的。你可以拥有多个令牌，给不同的第三方接口不同的令牌，而每个令牌都被赋予了不同的权限和使用期限。也就是说，在令牌没赋予的权利将不会给第三方接口和git。当然，token令牌在你设定的期限之后，对应的第三方接口和git就需要你重新给一个令牌，否则也无法使用。令牌也可以随时更改权限和删除。</p><h3 id="3-如何申请token令牌？"><a href="#3-如何申请token令牌？" class="headerlink" title="3.如何申请token令牌？"></a>3.如何申请token令牌？</h3><p>登陆你的GitHub（<strong>注意，在github.com登录你的账户时还是用你的密码，不是令牌</strong>) 点击头像。随后点击settings。</p><p><img src="https://i.postimg.cc/VLBLHGhV/2.png!/scale/50" class="lazyload" data-srcset="https://i.postimg.cc/VLBLHGhV/2.png!/scale/50" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>往下拉，你会在左侧看到一个Developer settings。点击它。</p><p><img src="https://i.postimg.cc/1tqy0J6M/31.png" class="lazyload" data-srcset="https://i.postimg.cc/1tqy0J6M/31.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>左侧有Personal access tokens。点击它。</p><p><img src="https://i.postimg.cc/RZgCv341/4.png" class="lazyload" data-srcset="https://i.postimg.cc/RZgCv341/4.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>点击右侧generate new token。</p><p><img src="https://i.postimg.cc/sD20t1HC/5.png" class="lazyload" data-srcset="https://i.postimg.cc/sD20t1HC/5.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>Note是你令牌的名称（不是令牌密码），随便填一个。</p><p>expiration是令牌有效期限。No expiration代表永久令牌。</p><p>下面是选择相应的权限。一般就选择repo 和delete_repo，其他按需勾选。</p><p>拉到最下面，点击generate token，随后跳出来一个界面，有一串绿底字符串即为你的token令牌。</p><p><img src="https://i.postimg.cc/NQk5NFqj/6.png" class="lazyload" data-srcset="https://i.postimg.cc/NQk5NFqj/6.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><strong>警告！！在这里你一定要将其复制并保存好！建议新建一个txt文件将令牌放入其中！因为这个令牌只会出现一次，你关闭了这个网页，以后GitHub就再也不会告诉你这个令牌了！妥善保管！</strong>（妥善保管！两情若是久长时，又岂在朝朝暮暮？）</p><p>返回刚才的界面，你可以查看已经创建的token和给予的权限与有效期。你可以随时更改，管理，删除它们（<strong>但是不会显示该令牌</strong>）。</p><p><img src="https://i.postimg.cc/XvhVyTZp/7.png" class="lazyload" data-srcset="https://i.postimg.cc/XvhVyTZp/7.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>随后回到你的git或第三方接口，账号还是输入你的username(用户名)，password就输入你复制的令牌。随后登陆就成功了。</p><h3 id="果然，全球最大的同性交流网站不是吹的，大七夕节非得找个伴侣，它要过七夕谁也拦不住呀！"><a href="#果然，全球最大的同性交流网站不是吹的，大七夕节非得找个伴侣，它要过七夕谁也拦不住呀！" class="headerlink" title="果然，全球最大的同性交流网站不是吹的，大七夕节非得找个伴侣，它要过七夕谁也拦不住呀！"></a>果然，全球最大的同性交流网站不是吹的，大七夕节非得找个伴侣，它要过七夕谁也拦不住呀！</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;原创文章，转载注明出处！&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;1-问题背景-background&quot;&gt;&lt;a href=&quot;#1-问题背景-background&quot; class=&quot;headerlink&quot; title=&quot;1.问题背景-background&quot;&gt;&lt;/</summary>
      
    
    
    
    <category term="日常经验" scheme="https://billma.top/categories/%E6%97%A5%E5%B8%B8%E7%BB%8F%E9%AA%8C/"/>
    
    
  </entry>
  
  <entry>
    <title>不同的C++中求解A+B的方法</title>
    <link href="https://billma.top/2021/08/12/a-b-problem/"/>
    <id>https://billma.top/2021/08/12/a-b-problem/</id>
    <published>2021-08-12T11:59:56.000Z</published>
    <updated>2021-09-04T13:03:02.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-基础算法"><a href="#1-基础算法" class="headerlink" title="1.基础算法"></a>1.基础算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> a,b;</span><br><span class="line"> cin&gt;&gt;a;</span><br><span class="line"> cin&gt;&gt;b;</span><br><span class="line"> cout&lt;&lt;a+b&lt;&lt;endl;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a+b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-Link-Cut-Tree"><a href="#2-Link-Cut-Tree" class="headerlink" title="2.Link-Cut Tree"></a>2.Link-Cut Tree</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data,rev,sum;</span><br><span class="line">    node *son[<span class="number">2</span>],*pre;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isroot</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setson</span><span class="params">(node *child,<span class="keyword">int</span> lr)</span></span>;</span><br><span class="line">&#125;lct[<span class="number">233</span>];</span><br><span class="line"><span class="keyword">int</span> top,a,b;</span><br><span class="line"><span class="function">node *<span class="title">getnew</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node *now=lct+ ++top;</span><br><span class="line">    now-&gt;data=x;</span><br><span class="line">    now-&gt;pre=now-&gt;son[<span class="number">1</span>]=now-&gt;son[<span class="number">0</span>]=lct;</span><br><span class="line">    now-&gt;sum=<span class="number">0</span>;</span><br><span class="line">    now-&gt;rev=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">node::judge</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> pre-&gt;son[<span class="number">1</span>]==<span class="keyword">this</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">node::isroot</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pre==lct)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> !(pre-&gt;son[<span class="number">1</span>]==<span class="keyword">this</span>||pre-&gt;son[<span class="number">0</span>]==<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">node::pushdown</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>==lct||!rev)<span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">swap</span>(son[<span class="number">0</span>],son[<span class="number">1</span>]);</span><br><span class="line">    son[<span class="number">0</span>]-&gt;rev^=<span class="number">1</span>;</span><br><span class="line">    son[<span class="number">1</span>]-&gt;rev^=<span class="number">1</span>;</span><br><span class="line">    rev=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">node::update</span><span class="params">()</span></span>&#123;sum=son[<span class="number">1</span>]-&gt;sum+son[<span class="number">0</span>]-&gt;sum+data;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">node::setson</span><span class="params">(node *child,<span class="keyword">int</span> lr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">pushdown</span>();</span><br><span class="line">    child-&gt;pre=<span class="keyword">this</span>;</span><br><span class="line">    son[lr]=child;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">update</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(node *now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node *father=now-&gt;pre,*grandfa=father-&gt;pre;</span><br><span class="line">    <span class="keyword">if</span>(!father-&gt;<span class="built_in">isroot</span>()) grandfa-&gt;<span class="built_in">pushdown</span>();</span><br><span class="line">    father-&gt;<span class="built_in">pushdown</span>();now-&gt;<span class="built_in">pushdown</span>();</span><br><span class="line">    <span class="keyword">int</span> lr=now-&gt;<span class="built_in">judge</span>();</span><br><span class="line">    father-&gt;<span class="built_in">setson</span>(now-&gt;son[lr^<span class="number">1</span>],lr);</span><br><span class="line">    <span class="keyword">if</span>(father-&gt;<span class="built_in">isroot</span>()) now-&gt;pre=grandfa;</span><br><span class="line">    <span class="keyword">else</span> grandfa-&gt;<span class="built_in">setson</span>(now,father-&gt;<span class="built_in">judge</span>());</span><br><span class="line">    now-&gt;<span class="built_in">setson</span>(father,lr^<span class="number">1</span>);</span><br><span class="line">    father-&gt;<span class="built_in">update</span>();now-&gt;<span class="built_in">update</span>();</span><br><span class="line">    <span class="keyword">if</span>(grandfa!=lct) grandfa-&gt;<span class="built_in">update</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(node *now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(now-&gt;<span class="built_in">isroot</span>())<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(;!now-&gt;<span class="built_in">isroot</span>();<span class="built_in">rotate</span>(now))</span><br><span class="line">    <span class="keyword">if</span>(!now-&gt;pre-&gt;<span class="built_in">isroot</span>())</span><br><span class="line">    now-&gt;<span class="built_in">judge</span>()==now-&gt;pre-&gt;<span class="built_in">judge</span>()?<span class="built_in">rotate</span>(now-&gt;pre):<span class="built_in">rotate</span>(now);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node *<span class="title">access</span><span class="params">(node *now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node *last=lct;</span><br><span class="line">    <span class="keyword">for</span>(;now!=lct;last=now,now=now-&gt;pre)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">splay</span>(now);</span><br><span class="line">        now-&gt;<span class="built_in">setson</span>(last,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">changeroot</span><span class="params">(node *now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">access</span>(now)-&gt;rev^=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">splay</span>(now);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(node *x,node *y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">changeroot</span>(x);</span><br><span class="line">    x-&gt;pre=y;</span><br><span class="line">    <span class="built_in">access</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cut</span><span class="params">(node *x,node *y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">changeroot</span>(x);</span><br><span class="line">    <span class="built_in">access</span>(y);</span><br><span class="line">    <span class="built_in">splay</span>(x);</span><br><span class="line">    x-&gt;<span class="built_in">pushdown</span>();</span><br><span class="line">    x-&gt;son[<span class="number">1</span>]=y-&gt;pre=lct;</span><br><span class="line">    x-&gt;<span class="built_in">update</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(node *x,node *y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">changeroot</span>(x);</span><br><span class="line">    node *now=<span class="built_in">access</span>(y);</span><br><span class="line">    <span class="keyword">return</span> now-&gt;sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">    node *A=<span class="built_in">getnew</span>(a);</span><br><span class="line">    node *B=<span class="built_in">getnew</span>(b);</span><br><span class="line">        <span class="built_in">connect</span>(A,B);</span><br><span class="line">        <span class="built_in">cut</span>(A,B);</span><br><span class="line">        <span class="built_in">connect</span>(A,B);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">query</span>(A,B)); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-SFPA"><a href="#3-SFPA" class="headerlink" title="3.SFPA"></a>3.SFPA</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m,a,b,op,head[<span class="number">200009</span>],next[<span class="number">200009</span>],dis[<span class="number">200009</span>],len[<span class="number">200009</span>],v[<span class="number">200009</span>],l,r,team[<span class="number">200009</span>],pd[<span class="number">100009</span>],u,v1,e;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lt</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    op++,v[op]=y;</span><br><span class="line">    next[op]=head[x],head[x]=op,len[op]=z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> f)</span><span class="comment">//SPFA……</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">200009</span>;i++)&#123;dis[i]=<span class="number">999999999</span>;&#125;</span><br><span class="line">    l=<span class="number">0</span>,r=<span class="number">1</span>,team[<span class="number">1</span>]=s,pd[s]=<span class="number">1</span>,dis[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l!=r)</span><br><span class="line">    &#123;</span><br><span class="line">        l=(l+<span class="number">1</span>)%<span class="number">90000</span>,u=team[l],pd[u]=<span class="number">0</span>,e=head[u];</span><br><span class="line">        <span class="keyword">while</span>(e!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            v1=v[e];</span><br><span class="line">            <span class="keyword">if</span>(dis[v1]&gt;dis[u]+len[e])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v1]=dis[u]+len[e];</span><br><span class="line">                <span class="keyword">if</span>(!pd[v1])</span><br><span class="line">                &#123;</span><br><span class="line">                    r=(r+<span class="number">1</span>)%<span class="number">90000</span>,</span><br><span class="line">                    team[r]=v1,</span><br><span class="line">                    pd[v1]=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            e=next[e];</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[f];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">    <span class="built_in">lt</span>(<span class="number">1</span>,<span class="number">2</span>,a);<span class="built_in">lt</span>(<span class="number">2</span>,<span class="number">3</span>,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in">SPFA</span>(<span class="number">1</span>,<span class="number">3</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-Floyed"><a href="#4-Floyed" class="headerlink" title="4.Floyed"></a>4.Floyed</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n=<span class="number">3</span>,a,b,dis[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dis[i][j]=<span class="number">2147483647</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dis[<span class="number">1</span>][<span class="number">2</span>]=a,dis[<span class="number">2</span>][<span class="number">3</span>]=b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[i][j]=<span class="built_in">min</span>(dis[i][j],dis[i][k]+dis[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dis[<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-递归算法"><a href="#5-递归算法" class="headerlink" title="5.递归算法"></a>5.递归算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a,b,c;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">dg</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a&lt;=<span class="number">5</span>)&#123;<span class="keyword">return</span> a;&#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">dg</span>(a/<span class="number">2</span>)+<span class="built_in">dg</span>(a-a/<span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    c=<span class="built_in">dg</span>(a)+<span class="built_in">dg</span>(b);</span><br><span class="line">    cout&lt;&lt;c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-高精度计算"><a href="#6-高精度计算" class="headerlink" title="6.高精度计算"></a>6.高精度计算</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a1[<span class="number">1000</span>],b1[<span class="number">1000</span>];</span><br><span class="line">      <span class="keyword">int</span> a[<span class="number">1000</span>]=&#123;<span class="number">0</span>&#125;,b[<span class="number">1000</span>]=&#123;<span class="number">0</span>&#125;,c[<span class="number">1000</span>]=&#123;<span class="number">0</span>&#125;,la,lb,lc,i,x;</span><br><span class="line">      cin&gt;&gt;a1&gt;&gt;b1;</span><br><span class="line">      la=<span class="built_in">strlen</span>(a1);</span><br><span class="line">      lb=<span class="built_in">strlen</span>(b1);</span><br><span class="line">      <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=la<span class="number">-1</span>;i++)&#123;a[la-i]=a1[i]<span class="number">-48</span>;&#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=lb<span class="number">-1</span>;i++)&#123;b[lb-i]=b1[i]<span class="number">-48</span>;&#125;</span><br><span class="line">      lc=<span class="number">1</span>,x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(lc&lt;=la||lc&lt;=lb)&#123;c[lc]=a[lc]+b[lc]+x,x=c[lc]/<span class="number">10</span>,c[lc]%=<span class="number">10</span>,lc++;&#125;</span><br><span class="line">    c[lc]=x;</span><br><span class="line">    <span class="keyword">if</span>(c[lc]==<span class="number">0</span>)&#123;lc--;&#125;</span><br><span class="line">    <span class="keyword">for</span>(i=lc;i&gt;=<span class="number">1</span>;i--)&#123;cout&lt;&lt;c[i];&#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-压位高精"><a href="#7-压位高精" class="headerlink" title="7.压位高精"></a>7.压位高精</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p 8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> carry 100000000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn=<span class="number">50001</span>;  </span><br><span class="line"><span class="keyword">char</span> s1[Maxn],s2[Maxn];  </span><br><span class="line"><span class="keyword">int</span> a[Maxn],b[Maxn],ans[Maxn];  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">char</span> s[],<span class="keyword">int</span> n[])</span>   </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">char</span> temp[Maxn];   </span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(s+<span class="number">1</span>),cur=<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span>(len/p)</span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">strncpy</span>(temp,s+len-p+<span class="number">1</span>,p);</span><br><span class="line">        n[++cur]=<span class="built_in">atoi</span>(temp); </span><br><span class="line">        len-=p;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span>(len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(temp,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(temp));  </span><br><span class="line">        <span class="built_in">strncpy</span>(temp,s+<span class="number">1</span>,len);  </span><br><span class="line">        n[++cur]=<span class="built_in">atoi</span>(temp);   </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> b[],<span class="keyword">int</span> c[],<span class="keyword">int</span> l1,<span class="keyword">int</span> l2)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,l3=<span class="built_in">max</span>(l1,l2);  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=l3;i++)</span><br><span class="line">    &#123;  </span><br><span class="line">        c[i]=a[i]+b[i]+x;  </span><br><span class="line">        x=c[i]/carry;</span><br><span class="line">        c[i]%=carry;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">while</span>(x&gt;<span class="number">0</span>)&#123;c[++l3]=x%<span class="number">10</span>;x/=<span class="number">10</span>;&#125;  </span><br><span class="line">    <span class="keyword">return</span> l3;</span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> len)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a[len]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=len<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)<span class="built_in">printf</span>(<span class="string">&quot;%0*d&quot;</span>,p,a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>,s1+<span class="number">1</span>,s2+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> la=<span class="built_in">change</span>(s1,a);</span><br><span class="line">    <span class="keyword">int</span> lb=<span class="built_in">change</span>(s2,b);</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">add</span>(a,b,ans,la,lb);    </span><br><span class="line">    <span class="built_in">print</span>(ans,len);</span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="8-树状数组"><a href="#8-树状数组" class="headerlink" title="8.树状数组"></a>8.树状数组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&amp;(-a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">2</span>,m=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ans[m+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> a[n+<span class="number">1</span>],c[n+<span class="number">1</span>],s[n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> o=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(c));</span><br><span class="line">    s[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        s[i]=s[i<span class="number">-1</span>]+a[i];</span><br><span class="line">        c[i]=s[i]-s[i-<span class="built_in">lowbit</span>(i)];<span class="comment">//树状数组创建前缀和优化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> q=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(q==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="keyword">int</span> x,y;</span><br><span class="line">           cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">           <span class="keyword">int</span> j=x;</span><br><span class="line">           <span class="keyword">while</span>(j&lt;=n)</span><br><span class="line">           &#123;</span><br><span class="line">               c[j]+=y;</span><br><span class="line">               j+=<span class="built_in">lowbit</span>(j);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x=<span class="number">1</span>,y=<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> s1=<span class="number">0</span>,s2=<span class="number">0</span>,p=x<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(p&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                s1+=c[p];</span><br><span class="line">                p-=<span class="built_in">lowbit</span>(p);</span><br><span class="line">            &#125;</span><br><span class="line">            p=y;</span><br><span class="line">            <span class="keyword">while</span>(p&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                s2+=c[p];</span><br><span class="line">                p-=<span class="built_in">lowbit</span>(p);</span><br><span class="line">            &#125;    </span><br><span class="line">            o++;</span><br><span class="line">            ans[o]=s2-s1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=o;i++)</span><br><span class="line">        cout&lt;&lt;ans[i]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-粗暴模拟人工运算"><a href="#9-粗暴模拟人工运算" class="headerlink" title="9.粗暴模拟人工运算"></a>9.粗暴模拟人工运算</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> fu=<span class="number">1</span>,f=<span class="number">1</span>,a,b,c=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="keyword">if</span>(a&lt;<span class="number">0</span>&amp;&amp;b&gt;<span class="number">0</span>)fu=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;<span class="number">0</span>&amp;&amp;b&lt;<span class="number">0</span>)fu=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span>(a&lt;<span class="number">0</span>&amp;&amp;b&lt;<span class="number">0</span>)f=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="number">0</span>)&#123;cout&lt;&lt;b;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)&#123;cout&lt;&lt;a;<span class="keyword">return</span> <span class="number">0</span>;&#125; </span><br><span class="line">    a=<span class="built_in">abs</span>(a);</span><br><span class="line">    b=<span class="built_in">abs</span>(b);</span><br><span class="line">    <span class="keyword">if</span>(a&gt;b&amp;&amp;fu==<span class="number">3</span>)f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(b&gt;a&amp;&amp;fu==<span class="number">3</span>)f=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(b&gt;a&amp;&amp;fu==<span class="number">2</span>)f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(b&lt;a&amp;&amp;fu==<span class="number">2</span>)f=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(fu==<span class="number">1</span>)c=a+b;</span><br><span class="line">    <span class="keyword">if</span>(fu&gt;<span class="number">1</span>)c=<span class="built_in">max</span>(a,b)-<span class="built_in">min</span>(a,b);</span><br><span class="line">    c*=f;</span><br><span class="line">    cout&lt;&lt;c;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-Dijkstra-STL的优先队列优化"><a href="#10-Dijkstra-STL的优先队列优化" class="headerlink" title="10.Dijkstra+STL的优先队列优化"></a>10.Dijkstra+STL的优先队列优化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">405</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,w;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edge[N*N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> dis[N*N];</span><br><span class="line"><span class="keyword">bool</span> vis[N*N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dis[a]&gt;dis[b];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;,cmp&gt; dijQue;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    dijQue.<span class="built_in">push</span>(start);</span><br><span class="line">    dis[start]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!dijQue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u=dijQue.<span class="built_in">top</span>();</span><br><span class="line">        dijQue.<span class="built_in">pop</span>();</span><br><span class="line">        vis[u]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(u==end)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;edge[u].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> v=edge[u][i].v;</span><br><span class="line">            <span class="keyword">if</span>(dis[v]==<span class="number">-1</span> || dis[v]&gt;dis[u]+edge[u][i].w) &#123;</span><br><span class="line">                dis[v]=dis[u]+edge[u][i].w;</span><br><span class="line">                <span class="keyword">if</span>(!vis[v]) &#123;</span><br><span class="line">                    vis[v]=<span class="literal">true</span>;</span><br><span class="line">                    dijQue.<span class="built_in">push</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[end];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">    Edge Qpush;</span><br><span class="line">    </span><br><span class="line">    Qpush.v=<span class="number">1</span>;</span><br><span class="line">    Qpush.w=a;</span><br><span class="line">    edge[<span class="number">0</span>].<span class="built_in">push_back</span>(Qpush);</span><br><span class="line">    </span><br><span class="line">    Qpush.v=<span class="number">2</span>;</span><br><span class="line">    Qpush.w=b;</span><br><span class="line">    edge[<span class="number">1</span>].<span class="built_in">push_back</span>(Qpush);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in">Dijkstra</span>(<span class="number">0</span>,<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-分治算法（二分法）"><a href="#11-分治算法（二分法）" class="headerlink" title="11.分治算法（二分法）"></a>11.分治算法（二分法）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a,b,c;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;<span class="keyword">long</span> <span class="keyword">long</span> l=-<span class="built_in"><span class="keyword">int</span></span>(<span class="number">1e9</span>)&lt;&lt;<span class="number">1</span>,r=<span class="built_in"><span class="keyword">int</span></span>(<span class="number">1e9</span>)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">     <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">     <span class="keyword">while</span>(r-l&gt;<span class="number">1</span>)&#123;c=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">         <span class="keyword">if</span>(c-b&lt;a)l=c;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span>(c-b&gt;a)r=c;</span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,c),<span class="number">0</span>;</span><br><span class="line">     &#125;<span class="keyword">if</span>(l!=r)<span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,r),<span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="12-位运算"><a href="#12-位运算" class="headerlink" title="12.位运算"></a>12.位运算</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> m, n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;m, &amp;n);</span><br><span class="line">    <span class="keyword">int</span> u = m &amp; n;</span><br><span class="line">    <span class="keyword">int</span> v = m ^ n;</span><br><span class="line">    <span class="keyword">while</span> (u) &#123;</span><br><span class="line">        <span class="keyword">int</span> s = v;</span><br><span class="line">        <span class="keyword">int</span> t = u &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        u = s &amp; t;</span><br><span class="line">        v = s ^ t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-线段树"><a href="#13-线段树" class="headerlink" title="13.线段树"></a>13.线段树</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val,l,r;</span><br><span class="line">&#125;;</span><br><span class="line">node t[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>],f[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> node)</span></span>&#123;</span><br><span class="line">    t[node].l=l;t[node].r=r;t[node].val=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        f[l]=node;</span><br><span class="line">        t[node].val=a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(l,mid,node*<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">build</span>(mid+<span class="number">1</span>,r,node*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">    t[node].val=t[node*<span class="number">2</span>].val+t[node*<span class="number">2</span>+<span class="number">1</span>].val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node==<span class="number">1</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> fa=node&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    t[fa].val=t[fa*<span class="number">2</span>].val+t[fa*<span class="number">2</span>+<span class="number">1</span>].val;</span><br><span class="line">    <span class="built_in">update</span>(fa);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[node].l==l&amp;&amp;t[node].r==r)&#123;</span><br><span class="line">        <span class="keyword">return</span> t[node].val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> lc=node*<span class="number">2</span>;<span class="keyword">int</span> rc=lc+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(t[lc].r&gt;=l)&#123;</span><br><span class="line">        <span class="keyword">if</span>(t[lc].r&gt;=r)&#123;</span><br><span class="line">            sum+=<span class="built_in">find</span>(l,r,lc);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            sum+=<span class="built_in">find</span>(l,t[lc].r,lc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t[rc].l&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(t[rc].l&lt;=l)&#123;</span><br><span class="line">            sum+=<span class="built_in">find</span>(l,r,rc);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            sum+=<span class="built_in">find</span>(t[rc].l,r,rc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in">find</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14-快读"><a href="#14-快读" class="headerlink" title="14.快读"></a>14.快读</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f=<span class="number">1</span>,x=<span class="number">0</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in">read</span>()+<span class="built_in">read</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-基础算法&quot;&gt;&lt;a href=&quot;#1-基础算法&quot; class=&quot;headerlink&quot; title=&quot;1.基础算法&quot;&gt;&lt;/a&gt;1.基础算法&lt;/h3&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutte</summary>
      
    
    
    
    <category term="编程算法" scheme="https://billma.top/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="computer,cpp" scheme="https://billma.top/tags/computer-cpp/"/>
    
  </entry>
  
  <entry>
    <title>C++中fstream的用法</title>
    <link href="https://billma.top/2021/08/04/cpp-fstream/"/>
    <id>https://billma.top/2021/08/04/cpp-fstream/</id>
    <published>2021-08-04T06:48:06.000Z</published>
    <updated>2021-09-04T13:03:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面：啥是fstream"><a href="#写在前面：啥是fstream" class="headerlink" title="写在前面：啥是fstream"></a>写在前面：啥是fstream</h2><div class="story post-story"><p>ofstream是从内存到硬盘，ifstream是从硬盘到内存，其实所谓的流缓冲就是内存空间;</p><p>在C++中，有一个stream这个类，所有的I/O都以这个“流”类为基础的，包括我们要认识的文件I/O，stream这个类有两个重要的运算符：</p><h3 id="1、插入器-lt-lt-向流输出数据"><a href="#1、插入器-lt-lt-向流输出数据" class="headerlink" title="1、插入器(&lt;&lt;) 向流输出数据"></a>1、插入器(&lt;&lt;) 向流输出数据</h3><p>比如说系统有一个默认的标准输出流(cout)，一般情况下就是指的显示器，所以，cout&lt;&lt;“Write Stdout”&lt;&lt;’\n’;就表示把字符串”Write Stdout”和换行字符(‘\n’)输出到标准输出流。</p><h3 id="2、析取器-gt-gt-从流中输入数据"><a href="#2、析取器-gt-gt-从流中输入数据" class="headerlink" title="2、析取器(&gt;&gt;) 从流中输入数据"></a>2、析取器(&gt;&gt;) 从流中输入数据</h3><p>比如说系统有一个默认的标准输入流(cin)，一般情况下就是指的键盘，所以，cin&gt;&gt;x;就表示从标准输入流中读取一个指定类型(即变量x的类型)的数据。</p><p>在C++中，对文件的操作是通过stream的子类fstream(file stream)来实现的，所以，要用这种方式操作文件，就必须加入头文件fstream.h。下面就把此类的文件操作过程一一道来。</p></div><h2 id="一、打开文件"><a href="#一、打开文件" class="headerlink" title="一、打开文件"></a>一、打开文件</h2><div class="story post-story"><p>在fstream类中，有一个成员函数open()，就是用来打开文件的，其原型是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* filename,<span class="keyword">int</span> mode,<span class="keyword">int</span> access)</span></span>;</span><br></pre></td></tr></table></figure><p>参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">filename：　　要打开的文件名</span><br><span class="line">mode：　　　　要打开文件的方式</span><br><span class="line">access：　　　打开文件的属性</span><br><span class="line"></span><br><span class="line">打开文件的方式在类<span class="built_in">ios</span>(是所有流式I/O类的基类)中定义，常用的值如下：</span><br><span class="line">ios::app：　　　以追加的方式打开文件</span><br><span class="line">ios::ate：　　　文件打开后定位到文件尾，ios:app就包含有此属性</span><br><span class="line">ios::binary：　以二进制方式打开文件，缺省的方式是文本方式。两种方式的区别见前文</span><br><span class="line">ios::in：　　　 文件以输入方式打开（文件数据输入到内存）</span><br><span class="line">ios::out：　　　文件以输出方式打开（内存数据输出到文件）</span><br><span class="line">ios::nocreate： 不建立文件，所以文件不存在时打开失败</span><br><span class="line">ios::noreplace：不覆盖文件，所以打开文件时如果文件存在失败</span><br><span class="line">ios::trunc：　　如果文件存在，把文件长度设为<span class="number">0</span> 可以用“或”把以上属性连接起来，如ios::out|ios::binary</span><br></pre></td></tr></table></figure><p>打开文件的属性取值是：</p><p>0：普通文件，打开访问</p><p>1：只读文件</p><p>2：隐含文件</p><p>4：系统文件</p><p>可以用“或”或者“+”把以上属性连接起来，如3或1|2就是以只读和隐含属性打开文件。</p><p>例如：以二进制输入方式打开文件c:\config.sys</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fstream file1; file1.<span class="built_in">open</span>(“c:\config.sys”,ios::binary|ios::in,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>如果open函数只有文件名一个参数，则是以读/写普通文件打开，即：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file1.<span class="built_in">open</span>(“c:\config.sys”);</span><br><span class="line"><span class="comment">/*等价于*/</span></span><br><span class="line">file1.<span class="built_in">open</span>(“c:\config.sys”,ios::in|ios::out,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>另外，fstream还有和<code>open()</code>一样的构造函数，对于上例，在定义的时侯就可以打开文件了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fstream <span class="title">file1</span><span class="params">(“c:\config.sys”)</span></span>;</span><br></pre></td></tr></table></figure><p>特别提出的是，fstream有两个子类：<code>ifstream(input file stream)</code>和<code>ofstream(outpu file stream)</code>，ifstream默认以输入方式打开文件，而ofstream默认以输出方式打开文件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">file2</span><span class="params">(“c:\pdos.def”)</span></span>;<span class="comment">//以输入方式打开文件 </span></span><br><span class="line"><span class="function">ofstream <span class="title">file3</span><span class="params">(“c:\x<span class="number">.123</span>”)</span></span>;<span class="comment">//以输出方式打开文件</span></span><br></pre></td></tr></table></figure><p>所以，在实际应用中，根据需要的不同，选择不同的类来定义：如果想以输入方式打开，就用ifstream来定义；如果想以输出方式打开，就用ofstream来定义；如果想以输入/输出方式来打开，就用fstream来定义。</p></div><h2 id="二、关闭文件"><a href="#二、关闭文件" class="headerlink" title="二、关闭文件"></a>二、关闭文件</h2><div class="story post-story"><p>打开的文件使用完成后一定要关闭，fstream提供了成员函数<code>close()</code>来完成此操作，如：<code>file1.close();</code>就把file1相连的文件关闭。</p></div><h2 id="三、读写文件"><a href="#三、读写文件" class="headerlink" title="三、读写文件"></a>三、读写文件</h2><div class="story post-story"><p> 读写文件分为文本文件和二进制文件的读取，对于文本文件的读取比较简单，用插入器和析取器就可以了；而对于二进制的读取就要复杂些，下要就详细的介绍这两种方式</p><h3 id="1、文本文件的读写"><a href="#1、文本文件的读写" class="headerlink" title="1、文本文件的读写"></a>1、文本文件的读写</h3><p> 文本文件的读写很简单：用插入器(&lt;&lt;)向文件输出；用析取器(&gt;&gt;)从文件输入。假设file1是以输入方式打开，file2以输出打开。示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file2&lt;&lt;“I Love You”;<span class="comment">//向文件写入字符串&quot;I Love You&quot; </span></span><br><span class="line"><span class="keyword">int</span> i; file1&gt;&gt;i;<span class="comment">//从文件输入一个整数值。</span></span><br></pre></td></tr></table></figure><p>这种方式还有一种简单的格式化能力，比如可以指定输出为16进制等等，具体的格式有以下一些</p><p>操纵符 功能 输入/输出 dec 格式化为十进制数值数据 输入和输出 endl 输出一个换行符并刷新此流 输出 ends 输出一个空字符 输出 hex 格式化为十六进制数值数据 输入和输出 oct 格式化为八进制数值数据 输入和输出 setpxecision(int p) 设置浮点数的精度位数 输出</p><p>比如要把123当作十六进制输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file1&lt;&lt;hex&lt;&lt;<span class="number">123</span>;</span><br></pre></td></tr></table></figure><p>要把3.1415926以5位精度输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file1&lt;&lt;<span class="built_in">setpxecision</span>(<span class="number">5</span>)&lt;&lt;<span class="number">3.1415926</span>。</span><br></pre></td></tr></table></figure><h3 id="2、二进制文件的读写"><a href="#2、二进制文件的读写" class="headerlink" title="2、二进制文件的读写"></a>2、二进制文件的读写</h3><h4 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h4><p>put()函数向流写入一个字符，其原型是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ofstream &amp;<span class="title">put</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br></pre></td></tr></table></figure><p>使用也比较简单，如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file1.<span class="built_in">put</span>(‘c’);</span><br></pre></td></tr></table></figure><p>就是向流写一个字符’c’。</p><h4 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h4><p>get()函数比较灵活，有3种常用的重载形式：</p><p>一种就是和put()对应的形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream &amp;<span class="title">get</span><span class="params">(<span class="keyword">char</span> &amp;ch)</span></span>;</span><br></pre></td></tr></table></figure><p>功能是从流中读取一个字符，结果保存在引用ch中，如果到文件尾，返回空字符。如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file2.<span class="built_in">get</span>(x);</span><br></pre></td></tr></table></figure><p>表示从文件中读取一个字符，并把读取的字符保存在x中。</p><p>另一种重载形式的原型是：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>这种形式是从流中返回一个字符，如果到达文件尾，返回EOF，如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x=file2.<span class="built_in">get</span>();</span><br></pre></td></tr></table></figure><p>和上例功能是一样的。</p><p>还有一种形式的原型是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream &amp;<span class="title">get</span><span class="params">(<span class="keyword">char</span> *buf,<span class="keyword">int</span> num,<span class="keyword">char</span> delim=<span class="string">&#x27;\n&#x27;</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>这种形式把字符读入由 buf 指向的数组，直到读入了 num 个字符或遇到了由 delim 指定的字符，如果没使用 delim 这个参数，将使用缺省值换行符’\n’。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file2.<span class="built_in">get</span>(str1,<span class="number">127</span>,‘A’); <span class="comment">//从文件中读取字符到字符串str1，当遇到字符’A’或读取了127个字符时终止。</span></span><br></pre></td></tr></table></figure><h4 id="读写数据块"><a href="#读写数据块" class="headerlink" title="读写数据块"></a>读写数据块</h4><p>要读写二进制数据块，使用成员函数<code>read()</code>和<code>write()</code>成员函数，它们原型如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span>(<span class="keyword">unsigned</span> <span class="keyword">char</span> *buf,<span class="keyword">int</span> num); <span class="built_in">write</span>(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>*buf,<span class="keyword">int</span> num);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>num 个字符到 buf 指向的缓存中，如果在还未读入 num 个字符时就到了文件尾，可以用成员函数 int gcount();来取得实际读取的字符数；而``` write() ```从buf 指向的缓存写 num 个字符到文件中，值得注意的是缓存的类型是 ```unsigned char *```，有时可能需要类型转换。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">例：</span><br><span class="line"></span><br><span class="line">```C++</span><br><span class="line">unsigned char str1[]=“I Love You”;</span><br><span class="line">int n[5];</span><br><span class="line">ifstream in(“xxx.xxx”); </span><br><span class="line">ofstream out(“yyy.yyy”);</span><br><span class="line">out.write(str1,strlen(str1));//把字符串str1全部写到yyy.yyy中 </span><br><span class="line">in.read((unsigned char*)n,sizeof(n));//从xxx.xxx中读取指定个整数，注意类型转换 </span><br><span class="line">in.close();</span><br><span class="line">out.close();</span><br></pre></td></tr></table></figure></div><h2 id="四、检测EOF"><a href="#四、检测EOF" class="headerlink" title="四、检测EOF"></a>四、检测EOF</h2><div class="story post-story"><p>成员函数eof()用来检测是否到达文件尾，如果到达文件尾返回非0值，否则返回0。原型是int eof();</p><p>例：　　</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(in.<span class="built_in">eof</span>()) <span class="built_in">ShowMessage</span>(<span class="string">&quot;已经到达文件尾！&quot;</span>);</span><br></pre></td></tr></table></figure></div><h2 id="五、文件定位"><a href="#五、文件定位" class="headerlink" title="五、文件定位"></a>五、文件定位</h2><div class="story post-story"><p>和C的文件操作方式不同的是，C++ I/O系统管理两个与一个文件相联系的指针。一个是读指针，它说明输入操作在文件中的位置；另一个是写指针，它下次写操作的位置。每次执行输入或输出时，相应的指针自动变化。所以，C++的文件定位分为读位置和写位置的定位，对应的成员函数是seekg()和seekp()。seekg()是设置读位置， seekp是设置写位置。它们最通用的形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream &amp;<span class="title">seekg</span><span class="params">(streamoff offset,seek_dir origin)</span></span>; <span class="function">ostream &amp;<span class="title">seekp</span><span class="params">(streamoff offset,seek_dir origin)</span></span>;</span><br></pre></td></tr></table></figure><p>streamoff定义于 iostream.h 中，定义有偏移量 offset 所能取得的最大值，seek_dir 表示移动的基准位置，是一个有以下值的枚举：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ios::beg　　<span class="comment">//文件开头</span></span><br><span class="line">ios::cur　　<span class="comment">//文件当前位置 </span></span><br><span class="line">ios::end　　<span class="comment">//文件结尾</span></span><br></pre></td></tr></table></figure><p>这两个函数一般用于二进制文件，因为文本文件会因为系统对字符的解释而可能与预想的值不同。例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file1.<span class="built_in">seekg</span>(<span class="number">1234</span>,ios::cur); <span class="comment">//把文件的读指针从当前位置向后移1234个字节 file2.seekp(1234,ios::beg); //把文件的写指针从文件开头向后移1234个字节</span></span><br></pre></td></tr></table></figure></div><h2 id="六-fstream的用法"><a href="#六-fstream的用法" class="headerlink" title="六.fstream的用法"></a>六.fstream的用法</h2><div class="story post-story"><h3 id="开一个文件"><a href="#开一个文件" class="headerlink" title="开一个文件"></a>开一个文件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fstream f; </span><br><span class="line">f.<span class="built_in">open</span>(“<span class="number">1.</span>txt”, ios::in | ios::binary); </span><br><span class="line"><span class="keyword">if</span> (!f.<span class="built_in">is_open</span>()) <span class="comment">// 检查文件是否成功打开 </span></span><br><span class="line">cout &lt;&lt; “cannot open file.” &lt;&lt; endl; </span><br></pre></td></tr></table></figure><p>ios::in与ios::bianry均为int型，定义文件打开的方式。<br>ios::in – 打开文件用于读。<br>ios::out – 打开文件用于写，如果文件不存在，则新建一个；存在则清空其内容。<br>ios::binary – 以二进制bit流方式进行读写，默认是ios::text，但最好指定这种读写方式，即使要读写的是文本。因为在ios::text模式下，在写入时’\ n’字符将转换成两个字符：回车+换行（HEX: 0D 0A) 写入，读入时作逆转换，这容易引起不必要的麻烦。<br>ios::app – 打开文件在文件尾进行写入，即使使用了seekp改变了写入位置，仍将在文件尾写入。<br>ios::ate – 打开文件在文件尾进行写入，但seekp有效。</p><h3 id="读写位置的改变"><a href="#读写位置的改变" class="headerlink" title="读写位置的改变"></a>读写位置的改变</h3><p>f.seekg(0, ios::beg); // 改变读入位置<br>g mean Get f.seekp(0, ios::end); // 改变写入位置 p mean Put 第一个参数是偏移量offset(long)，第二个参数是offset相对的位置，三个值： ios::beg – 文件头 ios::end – 文件尾 ios::cur – 当前位置</p><h3 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s[<span class="number">50</span>]; f.<span class="built_in">read</span>(s, <span class="number">49</span>); s[<span class="number">50</span>] = ‘\<span class="number">0</span>’; <span class="comment">// 注意要自己加上字符串结束符</span></span><br><span class="line"><span class="keyword">char</span> *s = “hello”; f.<span class="built_in">write</span>(s, <span class="built_in">strlen</span>(s));</span><br></pre></td></tr></table></figure></div><h2 id="七、补充"><a href="#七、补充" class="headerlink" title="七、补充"></a>七、补充</h2><div class="story post-story"><p>记得读写完成后用f.close()关闭文件。</p><p>例子 下面的程序用于删除带有行号的源程序中的行号。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义要删除的行号格式，下面定义的是型如: #0001 的行号</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> LINE_NUM_LENGTH = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> LINE_NUM_START = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fstream f;</span><br><span class="line">    <span class="keyword">char</span> *s = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; argc; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Processing file &quot;</span> &lt;&lt; argv[i] &lt;&lt; <span class="string">&quot;......&quot;</span>;</span><br><span class="line">        f.<span class="built_in">open</span>(argv[i], ios::in | ios::binary);</span><br><span class="line">        <span class="keyword">if</span> (!f.<span class="built_in">is_open</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;CANNOT OPEN&quot;</span>&lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        f.<span class="built_in">seekg</span>(<span class="number">0</span>, ios::end);</span><br><span class="line">        n = f.<span class="built_in">tellg</span>(); <span class="comment">// 文件大小</span></span><br><span class="line">        s = <span class="keyword">new</span> <span class="keyword">char</span>[n+<span class="number">1</span>];</span><br><span class="line">        f.<span class="built_in">seekg</span>(<span class="number">0</span>, ios::beg);</span><br><span class="line">        f.<span class="built_in">read</span>(s, n);</span><br><span class="line">        s[n] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        f.<span class="built_in">close</span>();</span><br><span class="line">        <span class="comment">// 采用一种简单的判断，遇到LINE_NUM_START后接一个数字，</span></span><br><span class="line">        <span class="comment">// 则认为它是一个行号.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[j] == LINE_NUM_START &amp;&amp;</span><br><span class="line">            (s[j+<span class="number">1</span>] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[j+<span class="number">1</span>] &lt;= <span class="string">&#x27;9&#x27;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt; j + LINE_NUM_LENGTH; k++)</span><br><span class="line">                    s[k] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        f.<span class="built_in">open</span>(argv[i], ios::out | ios::binary);</span><br><span class="line">        <span class="keyword">if</span> (!f.<span class="built_in">is_open</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;CANNOT OPEN&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">delete</span>[] s;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        f.<span class="built_in">write</span>(s, n);</span><br><span class="line">        f.<span class="built_in">close</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;OK&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span>[] s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;写在前面：啥是fstream&quot;&gt;&lt;a href=&quot;#写在前面：啥是fstream&quot; class=&quot;headerlink&quot; title=&quot;写在前面：啥是fstream&quot;&gt;&lt;/a&gt;写在前面：啥是fstream&lt;/h2&gt;&lt;div class=&quot;story post-st</summary>
      
    
    
    
    <category term="编程算法" scheme="https://billma.top/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>C++ 中string用法详解</title>
    <link href="https://billma.top/2021/08/01/cpp-string/"/>
    <id>https://billma.top/2021/08/01/cpp-string/</id>
    <published>2021-07-31T23:26:08.000Z</published>
    <updated>2021-09-04T13:03:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>本文根据 CC BY-NC-SA 4.0 许可协议参考Nicolai M.Josuttis的文章并进行小部分转载</em></p><hr><p>C++ 语言是个十分优秀的语言，但优秀并不表示完美。还是有许多人不愿意使用C或者C++，为什么？原因众多，其中之一就是C/C++的文本处理功能太麻烦，用起来很不方便。</p><p>举例来说，如果文本格式是：用户名 电话号码，文件名name.txt</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Tom <span class="number">23245332</span> </span><br><span class="line">Jenny <span class="number">22231231</span> </span><br><span class="line">Heny <span class="number">22183942</span> </span><br><span class="line">Tom <span class="number">23245332</span> </span><br><span class="line">…</span><br></pre></td></tr></table></figure><p>现在我们需要对用户名排序，且只输出不同的姓名。</p><p>那么在shell 编程中，可以这样用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;&#123;print $1&#125;&#x27; name.txt | sort | uniq</span><br></pre></td></tr></table></figure><p>如果使用C/C++ 就麻烦了，他需要做以下工作： 先打开文件，检测文件是否打开，如果失败，则退出。 声明一个足够大得二维字符数组或者一个字符指针数组 读入一行到字符空间 然后分析一行的结构，找到空格，存入字符数组中。 关闭文件 写一个排序函数，或者使用写一个比较函数，使用sort()排序 遍历数组，比较是否有相同的，如果有，则要删除，copy… 输出信息</p><p>你可以用C++或者C语言去实现这个流程。如果一个人的主要工作就是处理这种类似的文本(例如做apache的日志统计和分析),你说他会喜欢C/C++么？</p><p>当然，有了STL，这些处理会得到很大的简化。我们可以使用 fstream来代替麻烦的fopen fread fclose, 用vector来代替数组。最重要的是用 string来代替char * 数组，使用sort排序算法来排序，用unique 函数来去重。听起来好像很不错。看看下面代码(例程1）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">&quot;name.txt&quot;</span>)</span></span>;</span><br><span class="line">    string strtmp;</span><br><span class="line">    vector&lt;string&gt; vect;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">getline</span>(in, strtmp, <span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line">    vect.<span class="built_in">push_back</span>(strtmp.<span class="built_in">substr</span>(<span class="number">0</span>, strtmp.<span class="built_in">find</span>(<span class="string">&#x27; &#x27;</span>)));</span><br><span class="line">    <span class="built_in">sort</span>(vect.<span class="built_in">begin</span>(), vect.<span class="built_in">end</span>());</span><br><span class="line">    vector&lt;string&gt;::iterator it=<span class="built_in">unique</span>(vect.<span class="built_in">begin</span>(), vect.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">copy</span>(vect.<span class="built_in">begin</span>(), it, ostream_iterator&lt;string&gt;(cout, <span class="string">&quot;\n&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也还不错吧，至少会比想象得要简单得多！（代码里面没有对错误进行处理，只是为了说明问题，不要效仿).</p><p>当然，在这个文本格式中，不用vector而使用map会更有扩充性，例如，还可通过人名找电话号码等等，但是使用了map就不那么好用sort了。你可以用map试一试。</p><p>这里string的作用不只是可以存储字符串，还可以提供字符串的比较，查找等。在sort和unique函数中就默认使用了less 和equal_to函数, 上面的一段代码，其实使用了string的以下功能： 存储功能，在getline() 函数中 查找功能，在find() 函数中 子串功能，在substr() 函数中 string operator &lt; , 默认在sort() 函数中调用 string operator == , 默认在unique() 函数中调用</p><p>总之，有了string 后，C++的字符文本处理功能总算得到了一定补充，加上配合STL其他容器使用，其在文本处理上的功能已经与perl, shell, php的距离缩小很多了。 因此掌握string 会让你的工作事半功倍。</p><h3 id="1-string使用"><a href="#1-string使用" class="headerlink" title="1.string使用"></a>1.string使用</h3><p>其实，string并不是一个单独的容器，只是basic_string 模板类的一个typedef 而已，相对应的还有wstring, 你在string 头文件中你会发现下面的代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C++&quot;</span> &#123;</span><br><span class="line"><span class="keyword">typedef</span> basic_string &lt;<span class="keyword">char</span>&gt; string;</span><br><span class="line"><span class="keyword">typedef</span> basic_string &lt;<span class="keyword">wchar_t</span>&gt; wstring;</span><br><span class="line">&#125; <span class="comment">// extern &quot;C++&quot;</span></span><br></pre></td></tr></table></figure><p>由于只是解释string的用法，如果没有特殊的说明，本文并不区分string 和 basic_string的区别。</p><p>string 其实相当于一个保存字符的序列容器，因此除了有字符串的一些常用操作以外，还有包含了所有的序列容器的操作。字符串的常用操作包括：增加、删除、修改、查找比较、链接、输入、输出等。详细函数列表参看附录。不要害怕这么多函数，其实有许多是序列容器带有的，平时不一定用的上。</p><p>如果你要想了解所有函数的详细用法，你需要查看basic_string，或者下载STL编程手册。这里通过实例介绍一些常用函数。</p><h4 id="1-1-充分使用string-操作符"><a href="#1-1-充分使用string-操作符" class="headerlink" title="1.1 充分使用string 操作符"></a>1.1 充分使用string 操作符</h4><p>string 重载了许多操作符，包括 +, +=, &lt;, =, , [], «, »等，正式这些操作符，对字符串操作非常方便。先看看下面这个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string strinfo=<span class="string">&quot;Please input your name:&quot;</span>;</span><br><span class="line">    cout &lt;&lt; strinfo ;</span><br><span class="line">    cin &gt;&gt; strinfo;</span><br><span class="line">    <span class="keyword">if</span>( strinfo == <span class="string">&quot;winter&quot;</span> )</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;you are winter!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( strinfo != <span class="string">&quot;wende&quot;</span> )</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;you are not wende!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( strinfo &lt; <span class="string">&quot;winter&quot;</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;your name should be ahead of winter&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;your name should be after of winter&quot;</span>&lt;&lt;endl;</span><br><span class="line">    strinfo += <span class="string">&quot; , Welcome to China!&quot;</span>;</span><br><span class="line">    cout &lt;&lt; strinfo&lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;Your name is :&quot;</span>&lt;&lt;endl;</span><br><span class="line">    string strtmp = <span class="string">&quot;How are you? &quot;</span> + strinfo;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; strtmp.<span class="built_in">size</span>(); i ++)</span><br><span class="line">        cout&lt;&lt;strtmp[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*下面是程序的输出</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Please input your name:Hero</span></span><br><span class="line"><span class="comment">you are not wende!</span></span><br><span class="line"><span class="comment">Hero , Welcome to China!</span></span><br><span class="line"><span class="comment">How are you? Hero , Welcome to China!</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>有了这些操作符，在STL中仿函数都可以直接使用string作为参数，例如 less, great, equal_to 等，因此在把string作为参数传递的时候，它的使用和int 或者float等已经没有什么区别了。例如，你可以使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="keyword">int</span>&gt; mymap; <span class="comment">//以上默认使用了 less&lt;string&gt;</span></span><br></pre></td></tr></table></figure><p>有了 operator + 以后，你可以直接连加，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string strinfo=<span class="string">&quot;Winter&quot;</span>;</span><br><span class="line">string strlast=<span class="string">&quot;Hello &quot;</span> + strinfo + <span class="string">&quot;!&quot;</span>;</span><br><span class="line">string strtest=<span class="string">&quot;Hello &quot;</span> + strinfo + <span class="string">&quot; Welcome&quot;</span> + <span class="string">&quot; to China&quot;</span> + <span class="string">&quot; !&quot;</span>;</span><br></pre></td></tr></table></figure><p>看见其中的特点了吗？只要你的等式里面有一个 string 对象，你就可以一直连续”+”，但有一点需要保证的是，在开始的两项中，必须有一项是 string 对象。其原理很简单：</p><p>系统遇到”+“号，发现有一项是string 对象。 系统把另一项转化为一个临时 string 对象。 执行 operator + 操作，返回新的临时string 对象。 如果又发现”+“号，继续第一步操作。</p><p>由于这个等式是由左到右开始检测执行，如果开始两项都是const char<em>，程序自己并没有定义两个const char</em> 的加法，编译的时候肯定就有问题了。</p><p>有了操作符以后，assign(), append(), compare(), at()等函数，除非有一些特殊的需求时，一般是用不上。当然at()函数还有一个功能，那就是检查下标是否合法，如果是使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string str=<span class="string">&quot;winter&quot;</span>;<span class="comment">//下面一行有可能会引起程序中断错误</span></span><br><span class="line">str[<span class="number">100</span>]=<span class="string">&#x27;!&#x27;</span>;<span class="comment">//下面会抛出异常:throws: out_of_range</span></span><br><span class="line">cout&lt;&lt;str.<span class="built_in">at</span>(<span class="number">100</span>)&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>了解了吗？如果你希望效率高，还是使用[]来访问，如果你希望稳定性好，最好使用at()来访问。</p><h4 id="1-2-眼花缭乱的string-find-函数"><a href="#1-2-眼花缭乱的string-find-函数" class="headerlink" title="1.2 眼花缭乱的string find 函数"></a>1.2 眼花缭乱的string find 函数</h4><p>由于查找是使用最为频繁的功能之一，string 提供了非常丰富的查找函数。其列表如下： 函数名 描述 find 查找 rfind 反向查找 find_first_of 查找包含子串中的任何字符，返回第一个位置 find_first_not_of 查找不包含子串中的任何字符，返回第一个位置 find_last_of 查找包含子串中的任何字符，返回最后一个位置 find_last_not_of 查找不包含子串中的任何字符，返回最后一个位置以上函数都是被重载了4次，以下是以find_first_of 函数为例说明他们的参数，其他函数和其参数一样，也就是说总共有24个函数 ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">size_type <span class="title">find_first_of</span><span class="params">(<span class="keyword">const</span> basic_string&amp; s, size_type pos = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">size_type <span class="title">find_first_of</span><span class="params">(<span class="keyword">const</span> charT* s, size_type pos, size_type n)</span></span></span><br><span class="line"><span class="function">size_type <span class="title">find_first_of</span><span class="params">(<span class="keyword">const</span> charT* s, size_type pos = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">size_type <span class="title">find_first_of</span><span class="params">(charT c, size_type pos = <span class="number">0</span>)</span></span></span><br></pre></td></tr></table></figure><p>所有的查找函数都返回一个size_type类型，这个返回值一般都是所找到字符串的位置，如果没有找到，则返回string::npos。有一点需要特别注意，所有和string::npos的比较一定要用string::size_type来使用，不要直接使用int 或者unsigned int等类型。其实string::npos表示的是-1, 看看头文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">CharT</span>, <span class="keyword">class</span> _<span class="title">Traits</span>, <span class="keyword">class</span> _<span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">const</span> basic_string&lt;_CharT,_Traits,_Alloc&gt;::size_type</span><br><span class="line">basic_string&lt;_CharT,_Traits,_Alloc&gt;::npos</span><br><span class="line">= basic_string&lt;_CharT,_Traits,_Alloc&gt;::size_type) <span class="number">-1</span>;</span><br></pre></td></tr></table></figure><p>find 和 rfind 都还比较容易理解，一个是正向匹配，一个是逆向匹配，后面的参数pos都是用来指定起始查找位置。对于find_first_of 和find_last_of 就不是那么好理解。</p><p>find_first_of 是给定一个要查找的字符集，找到这个字符集中任何一个字符所在字符串中第一个位置。或许看一个例子更容易明白。</p><p>有这样一个需求：过滤一行开头和结尾的所有非英文字符。看看用string 如何实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string strinfo=<span class="string">&quot; //*---Hello Word!......------&quot;</span>;</span><br><span class="line">    string strset=<span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> first = strinfo.<span class="built_in">find_first_of</span>(strset);</span><br><span class="line">     <span class="keyword">if</span>(first == string::npos)</span><br><span class="line">     &#123;</span><br><span class="line">      cout&lt;&lt;<span class="string">&quot;not find any characters&quot;</span>&lt;&lt;endl;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">int</span> last = strinfo.<span class="built_in">find_last_of</span>(strset);</span><br><span class="line">     <span class="keyword">if</span>(last == string::npos)</span><br><span class="line">     &#123;</span><br><span class="line">      cout&lt;&lt;<span class="string">&quot;not find any characters&quot;</span>&lt;&lt;endl;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     cout &lt;&lt; strinfo.<span class="built_in">substr</span>(first, last - first + <span class="number">1</span>)&lt;&lt;endl;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里把所有的英文字母大小写作为了需要查找的字符集，先查找第一个英文字母的位置，然后查找最后一个英文字母的位置，然后用substr 来的到中间的一部分，用于输出结果。下面就是其结果：<code>Hello Word</code><br>前面的符号和后面的符号都没有了。像这种用法可以用来查找分隔符，从而把一个连续的字符串分割成为几部分，达到 shell 命令中的 awk 的用法。特别是当分隔符有多个的时候，可以一次指定。例如有这样的需求：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">张三|3456123, 湖南</span><br><span class="line">李四,4564234| 湖北</span><br><span class="line">王小二, 4433253|北京</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>我们需要以 “|” “,“为分隔符，同时又要过滤空格，把每行分成相应的字段。</p><p>1.3 string insert, replace, erase</p><p>了解了string 的操作符，查找函数和substr，其实就已经了解了string的80%的操作了。insert函数, replace函数和erase函数在使用起来相对简单。下面以一个例子来说明其应用。 string只是提供了按照位置和区间的replace函数，而不能用一个string字串来替换指定string中的另一个字串。这里写一个函数来实现这个功能：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">string_replace</span><span class="params">(string &amp; strBig, <span class="keyword">const</span> string &amp; strsrc, <span class="keyword">const</span> string &amp;strdst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     string::size_type pos=<span class="number">0</span>;</span><br><span class="line">    string::size_type srclen=strsrc.<span class="built_in">size</span>();</span><br><span class="line">    string::size_type dstlen=strdst.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span>( (pos=strBig.<span class="built_in">find</span>(strsrc, pos)) != string::npos)</span><br><span class="line">     &#123;</span><br><span class="line">      strBig.<span class="built_in">replace</span>(pos, srclen, strdst);</span><br><span class="line">      pos += dstlen;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看如何调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     string strinfo=<span class="string">&quot;This is Winter, Winter is a programmer. Do you know Winter?&quot;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Orign string is :\n&quot;</span>&lt;&lt;strinfo&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">string_replace</span>(strinfo, <span class="string">&quot;Winter&quot;</span>, <span class="string">&quot;wende&quot;</span>);</span><br><span class="line">     cout&lt;&lt;<span class="string">&quot;After replace Winter with wende, the string is :\n&quot;</span>&lt;&lt;strinfo&lt;&lt;endl;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Orign string is :</span><br><span class="line">This is Winter, Winter is a programmer. Do you know Winter?</span><br><span class="line">After replace Winter with wende, the string is :</span><br><span class="line">This is wende, wende is a programmer. Do you know wende?</span><br></pre></td></tr></table></figure><p>如果不用replace函数，则可以使用erase和insert来替换，也能实现string_replace函数的功能：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">string_replace</span><span class="params">(string &amp; strBig, <span class="keyword">const</span> string &amp; strsrc, <span class="keyword">const</span> string &amp;strdst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     string::size_type pos=<span class="number">0</span>;</span><br><span class="line">     string::size_type srclen=strsrc.<span class="built_in">size</span>();</span><br><span class="line">    string::size_type dstlen=strdst.<span class="built_in">size</span>();</span><br><span class="line">     <span class="keyword">while</span>( (pos=strBig.<span class="built_in">find</span>(strsrc, pos)) != string::npos)</span><br><span class="line">    &#123;</span><br><span class="line">     strBig.<span class="built_in">erase</span>(pos, srclen);</span><br><span class="line">     strBig.<span class="built_in">insert</span>(pos, strdst);</span><br><span class="line">     pos += dstlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，这种方法没有使用replace来得直接.</p><h3 id="2-string-和C-style字符串"><a href="#2-string-和C-style字符串" class="headerlink" title="2 string 和C-style字符串"></a>2 string 和C-style字符串</h3><p>现在看了这么多例子，发现const char* 可以和string 直接转换，例如我们在上面的例子中，使用</p><p><code>string_replace(strinfo, &quot;Winter&quot;, &quot;wende&quot;);</code>来代用<code>void</code></p><p><code>string_replace(string &amp; strBig, const string &amp; strsrc, const string &amp;strdst)</code><br>在C语言中只有<code>char*</code> 和 <code>const char*</code>，为了使用起来方便，string提供了三个函数满足其要求：</p><p>const charT<em>c_str() const<br>const charT</em> data() const<br>size_type copy(charT* buf, size_type n, size_type pos = 0) const<br>其中： c_str 直接返回一个以\0结尾的字符串。 data 直接以数组方式返回string的内容，其大小为size()的返回值，结尾并没有\0字符。 copy 把string的内容拷贝到buf空间中。 你或许会问，c_str()的功能包含data()，那还需要data()函数干什么？看看源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> charT* <span class="title">c_str</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="built_in">length</span> () == <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="built_in">terminate</span> ();</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">data</span> ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来c_str()的流程是：先调用terminate()，然后在返回data()。因此如果你对效率要求比较高，而且你的处理又不一定需要以\0的方式结束，你最好选择data()。但是对于一般的C函数中，需要以const char*为输入参数，你就要使用c_str()函数。</p><p>对于c_str() data()函数，返回的数组都是由string本身拥有，千万不可修改其内容。其原因是许多string实现的时候采用了引用机制，也就是说，有可能几个string使用同一个字符存储空间。而且你不能使用sizeof(string)来查看其大小。详细的解释和实现查看Effective STL的条款15：小心string实现的多样性。</p><p>另外在你的程序中，只在需要时才使用c_str()或者data()得到字符串，每调用一次，下次再使用就会失效，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">string <span class="title">strinfo</span><span class="params">(<span class="string">&quot;this is Winter&quot;</span>)</span></span>;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//最好的方式是:</span></span><br><span class="line"><span class="built_in">foo</span>(strinfo.<span class="built_in">c_str</span>());</span><br><span class="line"><span class="comment">//也可以这么用:</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* pstr=strinfo.<span class="built_in">c_str</span>();</span><br><span class="line"><span class="built_in">foo</span>(pstr);</span><br><span class="line"><span class="comment">//不要再使用了pstr了, 下面的操作已经使pstr无效了。</span></span><br><span class="line">strinfo += <span class="string">&quot; Hello!&quot;</span>;</span><br><span class="line"><span class="built_in">foo</span>(pstr);<span class="comment">//错误！</span></span><br></pre></td></tr></table></figure><p>会遇到什么错误？当你幸运的时候pstr可能只是指向<code>&quot;this is Winter Hello!“</code>的字符串，如果不幸运，就会导致程序出现其他问题，总会有一些不可遇见的错误。总之不会是你预期的那个结果。</p><h3 id="3-string-和-Charactor-Traits-了解了string的用法，该详细看看string的真相了"><a href="#3-string-和-Charactor-Traits-了解了string的用法，该详细看看string的真相了" class="headerlink" title="3 string 和 Charactor Traits 了解了string的用法，该详细看看string的真相了"></a>3 string 和 Charactor Traits 了解了string的用法，该详细看看string的真相了</h3><p>前面提到string 只是basic_string的一个typedef。看看basic_string 的参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">charT</span>, <span class="keyword">class</span> <span class="title">traits</span> =</span> char_traits&lt;charT&gt;,</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Allocator</span> =</span> allocator&lt;charT&gt; &gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">basic_string</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char_traits不仅是在basic_string 中有用，在basic_istream 和 basic_ostream中也需要用到。 就像Steve Donovan在过度使用C++模板中提到的，这些确实有些过头了，要不是系统自己定义了相关的一些属性，而且用了个<span class="keyword">typedef</span>，否则还真不知道如何使用。</span><br><span class="line"></span><br><span class="line">但复杂总有复杂道理。有了char_traits，你可以定义自己的字符串类型。当然，有了char_traits &lt; <span class="keyword">char</span> &gt; 和char_traits &lt; <span class="keyword">wchar_t</span> &gt; 你的需求使用已经足够了，为了更好的理解string ，咱们来看看char_traits都有哪些要求。</span><br><span class="line"></span><br><span class="line">如果你希望使用你自己定义的字符，你必须定义包含下列成员的结构： 表达式 描述</span><br><span class="line"></span><br><span class="line">```C++</span><br><span class="line">char_type 字符类型</span><br><span class="line">int_type <span class="keyword">int</span> 类型</span><br><span class="line">pos_type 位置类型</span><br><span class="line">off_type 表示位置之间距离的类型</span><br><span class="line">state_type 表示状态的类型</span><br><span class="line"><span class="built_in">assign</span>(c1,c2) 把字符c2赋值给<span class="function">c1</span></span><br><span class="line"><span class="function"><span class="title">eq</span><span class="params">(c1,c2)</span> 判断c1,c2 是否相等</span></span><br><span class="line"><span class="function"><span class="title">lt</span><span class="params">(c1,c2)</span> 判断c1是否小于c2</span></span><br><span class="line"><span class="function"><span class="title">length</span><span class="params">(str)</span> 判断str的长度</span></span><br><span class="line"><span class="function"><span class="title">compare</span><span class="params">(s1,s2,n)</span> 比较s1和s2的前n个字符</span></span><br><span class="line"><span class="function"><span class="title">copy</span><span class="params">(s1,s2, n)</span> 把s2的前n个字符拷贝到s1中</span></span><br><span class="line"><span class="function"><span class="title">move</span><span class="params">(s1,s2, n)</span> 把s2中的前n个字符移动到s1中</span></span><br><span class="line"><span class="function"><span class="title">assign</span><span class="params">(s,n,c)</span> 把s中的前n个字符赋值为c</span></span><br><span class="line"><span class="function"><span class="title">find</span><span class="params">(s,n,c)</span> 在s的前n个字符内查找c</span></span><br><span class="line"><span class="function"><span class="title">eof</span><span class="params">()</span> 返回end-of-file</span></span><br><span class="line"><span class="function"><span class="title">to_int_type</span><span class="params">(c)</span> 将c转换成int_type</span></span><br><span class="line"><span class="function"><span class="title">to_char_type</span><span class="params">(i)</span> 将i转换成char_type</span></span><br><span class="line"><span class="function"><span class="title">not_eof</span><span class="params">(i)</span> 判断i是否为EOF</span></span><br><span class="line"><span class="function"><span class="title">eq_int_type</span><span class="params">(i1,i2)</span> 判断i1和i2是否相等</span></span><br></pre></td></tr></table></figure><p>想看看实际的例子，你可以看看sgi STL的char_traits结构源码.</p><p>现在默认的string版本中，并不支持忽略大小写的比较函数和查找函数，如果你想练练手，你可以试试改写一个char_traits , 然后生成一个case_string类, 也可以在string 上做继承，然后派生一个新的类，例如：ext_string，提供一些常用的功能，例如：</p><p>定义分隔符。给定分隔符，把string分为几个字段。 提供替换功能。例如，用winter, 替换字符串中的wende 大小写处理。例如，忽略大小写比较，转换等 整形转换。例如把”123”字符串转换为123数字。 这些都是常用的功能，如果你有兴趣可以试试。其实有人已经实现了，看看Extended STL string。如果你想偷懒，下载一个头文件就可以用，有了它确实方便了很多。要是有人能提供一个支持正则表达式的string，我会非常乐意用。</p><h3 id="4-string-建议"><a href="#4-string-建议" class="headerlink" title="4.string 建议"></a>4.string 建议</h3><p>使用string 的方便性就不用再说了，这里要重点强调的是string的安全性。 string并不是万能的，如果你在一个大工程中需要频繁处理字符串，而且有可能是多线程，那么你一定要慎重(当然，在多线程下你使用任何STL容器都要慎重)。 string的实现和效率并不一定是你想象的那样，如果你对大量的字符串操作，而且特别关心其效率，那么你有两个选择，首先，你可以看看你使用的STL版本中string实现的源码；另一选择是你自己写一个只提供你需要的功能的类。 string的c_str()函数是用来得到C语言风格的字符串，其返回的指针不能修改其空间。而且在下一次使用时重新调用获得新的指针。 string的data()函数返回的字符串指针不会以’\0’结束，千万不可忽视。 尽量去使用操作符，这样可以让程序更加易懂</p><h3 id="5-小结"><a href="#5-小结" class="headerlink" title="5 小结"></a>5 小结</h3><p> 难怪有人说：string 使用方便功能强，我们一直用它！</p><h3 id="6-附录"><a href="#6-附录" class="headerlink" title="6 附录"></a>6 附录</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">string 函数列表 函数名 描述</span><br><span class="line">begin 得到指向字符串开头的Iterator</span><br><span class="line">end 得到指向字符串结尾的Iterator</span><br><span class="line">rbegin 得到指向反向字符串开头的Iterator</span><br><span class="line">rend 得到指向反向字符串结尾的Iterator</span><br><span class="line">size 得到字符串的大小</span><br><span class="line">length 和size函数功能相同</span><br><span class="line">max_size 字符串可能的最大大小</span><br><span class="line">capacity 在不重新分配内存的情况下，字符串可能的大小</span><br><span class="line">empty 判断是否为空</span><br><span class="line"><span class="keyword">operator</span>[] 取第几个元素，相当于数组</span><br><span class="line">c_str 取得C风格的<span class="keyword">const</span> <span class="keyword">char</span>* 字符串</span><br><span class="line">data 取得字符串内容地址</span><br><span class="line"><span class="keyword">operator</span>= 赋值操作符</span><br><span class="line">reserve 预留空间</span><br><span class="line">swap 交换函数</span><br><span class="line">insert 插入字符</span><br><span class="line">append 追加字符</span><br><span class="line">push_back 追加字符</span><br><span class="line"><span class="keyword">operator</span>+= += 操作符</span><br><span class="line">erase 删除字符串</span><br><span class="line">clear 清空字符容器中所有内容</span><br><span class="line">resize 重新分配空间</span><br><span class="line">assign 和赋值操作符一样</span><br><span class="line">replace 替代</span><br><span class="line">copy 字符串到空间</span><br><span class="line">find 查找</span><br><span class="line">rfind 反向查找</span><br><span class="line">find_first_of 查找包含子串中的任何字符，返回第一个位置</span><br><span class="line">find_first_not_of 查找不包含子串中的任何字符，返回第一个位置</span><br><span class="line">find_last_of 查找包含子串中的任何字符，返回最后一个位置</span><br><span class="line">find_last_not_of 查找不包含子串中的任何字符，返回最后一个位置</span><br><span class="line">substr 得到字串</span><br><span class="line">compare 比较字符串</span><br><span class="line"><span class="keyword">operator</span>+ 字符串链接</span><br><span class="line"><span class="keyword">operator</span>== 判断是否相等</span><br><span class="line"><span class="keyword">operator</span>!= 判断是否不等于</span><br><span class="line"><span class="keyword">operator</span>&lt; 判断是否小于</span><br><span class="line"><span class="keyword">operator</span>&gt;&gt; 从输入流中读入字符串</span><br><span class="line"><span class="keyword">operator</span>&lt;&lt; 字符串写入输出流</span><br><span class="line">getline 从输入流中读入一行 </span><br></pre></td></tr></table></figure><p>之所以抛弃char*的字符串而选用C++标准程序库中的string类，是因为他和前者比较起来，不必担心内存是否足够、字符串长度等等，而且作为一个类出现，他集成的操作函数足以完成我们大多数情况下(甚至是100%)的需要。我们可以用 = 进行赋值操作，== 进行比较，+ 做串联（是不是很简单?）。我们尽可以把它看成是C++的基本数据类型。 好了，进入正题……… 首先，为了在我们的程序中使用string类型，我们必须包含头文件<code>&lt;cstring&gt;</code>。</p><h4 id="1．声明一个C-字符串"><a href="#1．声明一个C-字符串" class="headerlink" title="1．声明一个C++字符串"></a>1．声明一个C++字符串</h4><p>声明一个字符串变量很简单：<br><code>string Str;</code><br>这样我们就声明了一个字符串变量，但既然是一个类，就有构造函数和析构函数。上面的声明没有传入参数，所以就直接使用了string的默认的构造函数，这个函数所作的就是把Str初始化为一个空字符串。String类的构造函数和析构函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">a)    string s;  <span class="comment">//生成一个空字符串s</span></span><br><span class="line">b)    <span class="function">string <span class="title">s</span><span class="params">(str)</span> <span class="comment">//拷贝构造函数 生成str的复制品</span></span></span><br><span class="line"><span class="function">c)    string <span class="title">s</span><span class="params">(str,stridx)</span> <span class="comment">//将字符串str内“始于位置stridx”的部分当作字符串的初值</span></span></span><br><span class="line"><span class="function">d)    string <span class="title">s</span><span class="params">(str,stridx,strlen)</span> <span class="comment">//将字符串str内“始于stridx且长度顶多strlen”的部分作为字符串的初值</span></span></span><br><span class="line"><span class="function">e)    string <span class="title">s</span><span class="params">(cstr)</span> <span class="comment">//将C字符串作为s的初值</span></span></span><br><span class="line"><span class="function">f)    string <span class="title">s</span><span class="params">(chars,chars_len)</span> <span class="comment">//将C字符串前chars_len个字符作为字符串s的初值。</span></span></span><br><span class="line"><span class="function">g)    string <span class="title">s</span><span class="params">(num,c)</span> <span class="comment">//生成一个字符串，包含num个c字符</span></span></span><br><span class="line"><span class="function">h)    string <span class="title">s</span><span class="params">(beg,end)</span> <span class="comment">//以区间beg;end(不包含end)内的字符作为字符串s的初值</span></span></span><br><span class="line"><span class="function">i)    s.~<span class="title">string</span><span class="params">()</span> <span class="comment">//销毁所有字符，释放内存</span></span></span><br></pre></td></tr></table></figure><p>都很简单，我就不解释了。</p><h4 id="2．字符串操作函数"><a href="#2．字符串操作函数" class="headerlink" title="2．字符串操作函数"></a>2．字符串操作函数</h4><p>这里是C++字符串的重点，我先把各种操作函数罗列出来，不喜欢把所有函数都看完的人可以在这里找自己喜欢的函数，再到后面看他的详细解释。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">a) =,<span class="built_in">assign</span>()   <span class="comment">//赋以新值</span></span><br><span class="line">b) <span class="built_in">swap</span>()   <span class="comment">//交换两个字符串的内容</span></span><br><span class="line">c) +=,<span class="built_in">append</span>(),<span class="built_in">push_back</span>() <span class="comment">//在尾部添加字符</span></span><br><span class="line">d) <span class="built_in">insert</span>() <span class="comment">//插入字符</span></span><br><span class="line">e) <span class="built_in">erase</span>() <span class="comment">//删除字符</span></span><br><span class="line">f) <span class="built_in">clear</span>() <span class="comment">//删除全部字符</span></span><br><span class="line">g) <span class="built_in">replace</span>() <span class="comment">//替换字符</span></span><br><span class="line">h) + <span class="comment">//串联字符串</span></span><br><span class="line">i) ==,!=,&lt;,&lt;=,&gt;,&gt;=,<span class="built_in">compare</span>()  <span class="comment">//比较字符串</span></span><br><span class="line">j) <span class="built_in">size</span>(),<span class="built_in">length</span>()  <span class="comment">//返回字符数量</span></span><br><span class="line">k) <span class="built_in">max_size</span>() <span class="comment">//返回字符的可能最大个数</span></span><br><span class="line">l) <span class="built_in">empty</span>()  <span class="comment">//判断字符串是否为空</span></span><br><span class="line">m) <span class="built_in">capacity</span>() <span class="comment">//返回重新分配之前的字符容量</span></span><br><span class="line">n) <span class="built_in">reserve</span>() <span class="comment">//保留一定量内存以容纳一定数量的字符</span></span><br><span class="line">o) [ ], <span class="built_in">at</span>() <span class="comment">//存取单一字符</span></span><br><span class="line">p) &gt;&gt;,<span class="built_in">getline</span>() <span class="comment">//从stream读取某值</span></span><br><span class="line">q) &lt;&lt;  <span class="comment">//将谋值写入stream</span></span><br><span class="line">r) <span class="built_in">copy</span>() <span class="comment">//将某值赋值为一个C_string</span></span><br><span class="line">s) <span class="built_in">c_str</span>() <span class="comment">//将内容以C_string返回</span></span><br><span class="line">t) <span class="built_in">data</span>() <span class="comment">//将内容以字符数组形式返回</span></span><br><span class="line">u) <span class="built_in">substr</span>() <span class="comment">//返回某个子字符串</span></span><br><span class="line">v)查找函数</span><br><span class="line">w)<span class="built_in">begin</span>() <span class="built_in">end</span>() <span class="comment">//提供类似STL的迭代器支持</span></span><br><span class="line">x) <span class="built_in">rbegin</span>() <span class="built_in">rend</span>() <span class="comment">//逆向迭代器</span></span><br><span class="line">y) <span class="built_in">get_allocator</span>() <span class="comment">//返回配置器</span></span><br></pre></td></tr></table></figure><h5 id="2．1-C-字符串和C字符串的转换"><a href="#2．1-C-字符串和C字符串的转换" class="headerlink" title="2．1 C++字符串和C字符串的转换"></a>2．1 C++字符串和C字符串的转换</h5><p>C++提供的由C++字符串得到对应的C_string的方法是使用data()、c_str()和copy()，其中，data()以字符数组的形式返回字符串内容，但并不添加’\0’。c_str()返回一个以‘\0’结尾的字符数组，而copy()则把字符串的内容复制或写入既有的c_string 或字符数组内。C++字符串并不以’\0’结尾。我的建议是在程序中能使用C++字符串就使用，除非万不得已不选用c_string。由于只是简单介绍，详细介绍掠过，谁想进一步了解使用中的注意事项可以给我留言(到我的收件箱)。我详细解释。</p><h5 id="2．2-大小和容量函数"><a href="#2．2-大小和容量函数" class="headerlink" title="2．2 大小和容量函数"></a>2．2 大小和容量函数</h5><p> 一个C++字符串存在三种大小：a)现有的字符数，函数是size()和length()，他们等效。Empty()用来检查字符串是否为空。 b)max_size() 这个大小是指当前C++字符串最多能包含的字符数，很可能和机器本身的限制或者字符串所在位置连续内存的大小有关系。我们一般情况下不用关心他，应该大小足够我们用的。但是不够用的话，会抛出length_error异常c)capacity()重新分配内存之前 string所能包含的最大字符数。这里另一个需要指出的是reserve()函数，这个函数为string重新分配内存。重新分配的大小由其参数决定，默认参数为0，这时候会对string进行非强制性缩减。</p><p>还有必要再重复一下C++字符串和C字符串转换的问题，许多人会遇到这样的问题，自己做的程序要调用别人的函数、类什么的（比如数据库连接函数 Connect(char*,char*)），但别人的函数参数用的是char<em>形式的，而我们知道，c_str()、data()返回的字符数组由该字符串拥有，所以是一种const char</em>,要想作为上面提及的函数的参数，还必须拷贝到一个char*,而我们的原则是能不使用C字符串就不使用。那么，这时候我们的处理方式是：如果此函数对参数(也就是char*)的内容不修改的话，我们可以这样Connect((char*)UserID.c_str(), (char*)PassWD.c_str()),但是这时候是存在危险的，因为这样转换后的字符串其实是可以修改的（有兴趣地可以自己试一试），所以我强调除非函数调用的时候不对参数进行修改，否则必须拷贝到一个char<em>上去。当然，更稳妥的办法是无论什么情况都拷贝到一个char</em>上去。同时我们也祈祷现在仍然使用C字符串进行编程的高手们（说他们是高手一点儿也不为过，也许在我们还穿开裆裤的时候他们就开始编程了，哈哈…）写的函数都比较规范，那样我们就不必进行强制转换了。</p><h5 id="2．3元素存取"><a href="#2．3元素存取" class="headerlink" title="2．3元素存取"></a>2．3元素存取</h5><p> 我们可以使用下标操作符[] 和函数at()对元素包含的字符进行访问。但是应该注意的是操作符[]并不检查索引是否有效（有效索引 0~str.length()），如果索引失效，会引起未定义的行为。而at()会检查，如果使用at()的时候索引无效，会抛出 out_of_range异常。 有一个例外不得不说，const string a;的操作符[]对索引值是a.length()仍然有效，其返回值是’\0’。其他的各种情况，a.length()索引都是无效的。举例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> string <span class="title">Cstr</span><span class="params">(“<span class="keyword">const</span> string”)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">Str</span><span class="params">(“string”)</span></span>;</span><br><span class="line"></span><br><span class="line">Str[<span class="number">3</span>];    <span class="comment">//ok</span></span><br><span class="line">Str.<span class="built_in">at</span>(<span class="number">3</span>);  <span class="comment">//ok</span></span><br><span class="line"></span><br><span class="line">Str[<span class="number">100</span>]; <span class="comment">//未定义的行为</span></span><br><span class="line">Str.<span class="built_in">at</span>(<span class="number">100</span>);  <span class="comment">//throw out_of_range</span></span><br><span class="line"></span><br><span class="line">Str[Str.<span class="built_in">length</span>()]  <span class="comment">//未定义行为</span></span><br><span class="line">Cstr[Cstr.<span class="built_in">length</span>()] <span class="comment">//返回 ‘\0’</span></span><br><span class="line">Str.<span class="built_in">at</span>(Str.<span class="built_in">length</span>());<span class="comment">//throw out_of_range</span></span><br><span class="line">Cstr.<span class="built_in">at</span>(Cstr.<span class="built_in">length</span>()) <span class="comment">////throw out_of_range</span></span><br></pre></td></tr></table></figure><p>我不赞成类似于下面的引用或指针赋值： <code>char&amp; r=s[2]; char* p= &amp;s[3];</code></p><p>因为一旦发生重新分配，r,p立即失效。避免的方法就是不使用。</p><h5 id="2．4比较函数"><a href="#2．4比较函数" class="headerlink" title="2．4比较函数"></a>2．4比较函数</h5><p> C++字符串支持常见的比较操作符（&gt;,&gt;=,&lt;,&lt;=,==,!=），甚至支持string与C-string的比较(如 str&lt;”hello”)。在使用&gt;,&gt;=,&lt;,&lt;=这些操作符的时候是根据“当前字符特性”将字符按字典顺序进行逐一得比较。字典排序靠前的字符小，比较的顺序是从前向后比较，遇到不相等的字符就按这个位置上的两个字符的比较结果确定两个字符串的大小。同时，string(“aaaa”) &lt;string(aaaaa)。 另一个功能强大的比较函数是成员函数compare()。他支持多参数处理，支持用索引值和长度定位子串来进行比较。他返回一个整数来表示比较结果，返回值意义如下：0-相等 〉0-大于 &lt;0-小于。举例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(“abcd”)</span></span>;</span><br><span class="line">s.<span class="built_in">compare</span>(“abcd”); <span class="comment">//返回0</span></span><br><span class="line">s.<span class="built_in">compare</span>(“dcba”); <span class="comment">//返回一个小于0的值</span></span><br><span class="line">s.<span class="built_in">compare</span>(“ab”); <span class="comment">//返回大于0的值</span></span><br><span class="line">s.<span class="built_in">compare</span>(s); <span class="comment">//相等</span></span><br><span class="line">s.<span class="built_in">compare</span>(<span class="number">0</span>,<span class="number">2</span>,s,<span class="number">2</span>,<span class="number">2</span>); <span class="comment">//用”ab”和”cd”进行比较 小于零</span></span><br><span class="line">s.<span class="built_in">compare</span>(<span class="number">1</span>,<span class="number">2</span>,”bcx”,<span class="number">2</span>); <span class="comment">//用”bc”和”bc”比较。</span></span><br></pre></td></tr></table></figure><p>怎么样？功能够全的吧！什么？还不能满足你的胃口？好吧，那等着，后面有更个性化的比较算法。先给个提示，使用的是STL的比较算法。什么？对STL一窍不通？你重修吧！</p><h5 id="2．5-更改内容"><a href="#2．5-更改内容" class="headerlink" title="2．5 更改内容"></a>2．5 更改内容</h5><p> 这在字符串的操作中占了很大一部分。 首先讲赋值，第一个赋值方法当然是使用操作符=，新值可以是string(如：s=ns) 、c_string(如：s=”gaint”)甚至单一字符（如：s=’j’）。还可以使用成员函数assign()，这个成员函数可以使你更灵活的对字符串赋值。还是举例说明吧：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">assign</span>(str); <span class="comment">//直接</span></span><br><span class="line">s.<span class="built_in">assign</span>(str,<span class="number">1</span>,<span class="number">3</span>);<span class="comment">//如果str是”iamangel” 就是把”ama”赋给字符串</span></span><br><span class="line">s.<span class="built_in">assign</span>(str,<span class="number">2</span>,string::npos);<span class="comment">//把字符串str从索引值2开始到结尾赋给s</span></span><br><span class="line">s.<span class="built_in">assign</span>(“gaint”); <span class="comment">//不说</span></span><br><span class="line">s.<span class="built_in">assign</span>(“nico”,<span class="number">5</span>);<span class="comment">//把’n’ ‘I’ ‘c’ ‘o’ ‘\0’赋给字符串</span></span><br><span class="line">s.<span class="built_in">assign</span>(<span class="number">5</span>,’x’);<span class="comment">//把五个x赋给字符串</span></span><br></pre></td></tr></table></figure><p>把字符串清空的方法有三个：s=””;s.clear();s.erase();(我越来越觉得举例比说话让别人容易懂！)。 string提供了很多函数用于插入（insert）、删除（erase）、替换（replace）、增加字符。 先说增加字符（这里说的增加是在尾巴上），函数有 +=、append()、push_back()。举例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">s+=str;<span class="comment">//加个字符串</span></span><br><span class="line">s+=”my name is jiayp”;<span class="comment">//加个C字符串</span></span><br><span class="line">s+=’a’;<span class="comment">//加个字符</span></span><br><span class="line"></span><br><span class="line">s.<span class="built_in">append</span>(str);</span><br><span class="line">s.<span class="built_in">append</span>(str,<span class="number">1</span>,<span class="number">3</span>);<span class="comment">//不解释了 同前面的函数参数assign的解释</span></span><br><span class="line">s.<span class="built_in">append</span>(str,<span class="number">2</span>,string::npos)<span class="comment">//不解释了</span></span><br><span class="line"></span><br><span class="line">s.<span class="built_in">append</span>(“my name is jiayp”);</span><br><span class="line">s.<span class="built_in">append</span>(“nico”,<span class="number">5</span>);</span><br><span class="line">s.<span class="built_in">append</span>(<span class="number">5</span>,’x’);</span><br><span class="line"></span><br><span class="line">s.<span class="built_in">push_back</span>(‘a’);<span class="comment">//这个函数只能增加单个字符 对STL熟悉的理解起来很简单</span></span><br></pre></td></tr></table></figure><p>也许你需要在string中间的某个位置插入字符串，这时候你可以用insert()函数，这个函数需要你指定一个安插位置的索引，被插入的字符串将放在这个索引的后面。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">insert</span>(<span class="number">0</span>,”my name”);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">1</span>,str);</span><br></pre></td></tr></table></figure><p>这种形式的insert()函数不支持传入单个字符，这时的单个字符必须写成字符串形式(让人恶心)。既然你觉得恶心，那就不得不继续读下面一段话：为了插入单个字符，insert()函数提供了两个对插入单个字符操作的重载函数：<code>insert(size_type index,size_type num,chart c)和insert(iterator pos,size_type num,chart c)</code>。其中size_type是无符号整数，iterator是char*,所以，你这么调用insert函数是不行的：insert(0,1,’j’);这时候第一个参数将转换成哪一个呢？所以你必须这么写：insert((string::size_type)0,1,’j’)！第二种形式指出了使用迭代器安插字符的形式，在后面会提及。顺便提一下，string有很多操作是使用STL的迭代器的，他也尽量做得和STL靠近。 删除函数erase()的形式也有好几种（真烦！），替换函数replace()也有好几个。举例吧：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string s=”il8n”;</span><br><span class="line">s.<span class="built_in">replace</span>(<span class="number">1</span>,<span class="number">2</span>,”nternationalizatio”);<span class="comment">//从索引1开始的2个替换成后面的C_string</span></span><br><span class="line">s.<span class="built_in">erase</span>(<span class="number">13</span>);<span class="comment">//从索引13开始往后全删除</span></span><br><span class="line">s.<span class="built_in">erase</span>(<span class="number">7</span>,<span class="number">5</span>);<span class="comment">//从索引7开始往后删5个</span></span><br></pre></td></tr></table></figure><p>2．6提取子串和字符串连接</p><p>题取子串的函数是：substr(),形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">substr</span>();<span class="comment">//返回s的全部内容</span></span><br><span class="line">s.<span class="built_in">substr</span>(<span class="number">11</span>);<span class="comment">//从索引11往后的子串</span></span><br><span class="line">s.<span class="built_in">substr</span>(<span class="number">5</span>,<span class="number">6</span>);<span class="comment">//从索引5开始6个字符</span></span><br></pre></td></tr></table></figure><p>把两个字符串结合起来的函数是+。（谁不明白请致电120）</p><p>2．7输入输出操作 1．» 从输入流读取一个string。 2．« 把一个string写入输出流。 另一个函数就是getline(),他从输入流读取一行内容，直到遇到分行符或到了文件尾。</p><p>2．8搜索与查找 查找函数很多，功能也很强大，包括了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span>()</span><br><span class="line"><span class="built_in">rfind</span>()</span><br><span class="line"><span class="built_in">find_first_of</span>()</span><br><span class="line"><span class="built_in">find_last_of</span>()</span><br><span class="line"><span class="built_in">find_first_not_of</span>()</span><br><span class="line"><span class="built_in">find_last_not_of</span>()</span><br></pre></td></tr></table></figure><p>这些函数返回符合搜索条件的字符区间内的第一个字符的索引，没找到目标就返回npos。所有的函数的参数说明如下： 第一个参数是被搜寻的对象。第二个参数（可有可无）指出string内的搜寻起点索引，第三个参数（可有可无）指出搜寻的字符个数。比较简单，不多说 不理解的可以向我提出，我再仔细的解答。当然，更加强大的STL搜寻在后面会有提及。 最后再说说npos的含义，string::npos的类型是string::size_type,所以，一旦需要把一个索引与npos相比，这个索引值必须是string::size)type类型的，更多的情况下，我们可以直接把函数和npos进行比较（如：if(s.find(“jia”)==string::npos)）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;em&gt;本文根据 CC BY-NC-SA 4.0 许可协议参考Nicolai M.Josuttis的文章并进行小部分转载&lt;/em&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;C++ 语言是个十分优秀的语言，但优秀并不表示完美。还是有许多人不愿意使用C或者C++，为什么？原因众多，其中之一就是</summary>
      
    
    
    
    <category term="编程算法" scheme="https://billma.top/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>C++中如何使用struct和STL创建链表结构</title>
    <link href="https://billma.top/2021/07/21/stl_use/"/>
    <id>https://billma.top/2021/07/21/stl_use/</id>
    <published>2021-07-21T07:39:00.000Z</published>
    <updated>2021-09-04T13:04:04.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-链表结构的使用"><a href="#一-链表结构的使用" class="headerlink" title="一.链表结构的使用"></a>一.链表结构的使用</h2><div class="story post-story"><h3 id="1-创建"><a href="#1-创建" class="headerlink" title="1.创建"></a>1.创建</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;<span class="comment">//该链数据</span></span><br><span class="line">    node *next;<span class="comment">//指向链表下一个数据</span></span><br><span class="line">&#125;</span><br><span class="line">node *p;<span class="comment">//链表所在的地址</span></span><br></pre></td></tr></table></figure><h3 id="2-新增存储单元"><a href="#2-新增存储单元" class="headerlink" title="2.新增存储单元"></a>2.新增存储单元</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = <span class="keyword">new</span> node;</span><br></pre></td></tr></table></figure><h3 id="3-其他所需的操作符"><a href="#3-其他所需的操作符" class="headerlink" title="3.其他所需的操作符"></a>3.其他所需的操作符</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node *head;<span class="comment">//指向头节点</span></span><br><span class="line">node *p;<span class="comment">//用来申请新的数据单元</span></span><br><span class="line">node *r;<span class="comment">//用来指向末节点(最后一个数据)</span></span><br></pre></td></tr></table></figure><h3 id="4-输入一个链表"><a href="#4-输入一个链表" class="headerlink" title="4.输入一个链表"></a>4.输入一个链表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x;<span class="comment">//每次输入的数据</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line"><span class="keyword">while</span> (<span class="comment">/*输入链条的终止条件*/</span>)&#123;</span><br><span class="line">    p=<span class="keyword">new</span> node;<span class="comment">//申请一个新节点</span></span><br><span class="line">    p-&gt;data=x;<span class="comment">//录入数据</span></span><br><span class="line">    p-&gt;next=<span class="literal">NULL</span>;<span class="comment">//初始化下一个节点避免闪退</span></span><br><span class="line">    r-&gt;next=p;<span class="comment">//将新节点接到前面链表中</span></span><br><span class="line">    r=p;<span class="comment">//末节点后移</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);<span class="comment">//输入下一个数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-输出链表"><a href="#5-输出链表" class="headerlink" title="5.输出链表"></a>5.输出链表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p=head-&gt;next;<span class="comment">//p指针回到链表开头</span></span><br><span class="line"><span class="keyword">while</span>(p-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,p-&gt;data);</span><br><span class="line">    p=p-&gt;next;<span class="comment">//到下一个节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,p-&gt;data);<span class="comment">//把最后一个数据也输出</span></span><br></pre></td></tr></table></figure><h3 id="6-查找某个条件的数据"><a href="#6-查找某个条件的数据" class="headerlink" title="6.查找某个条件的数据"></a>6.查找某个条件的数据</h3><h4 id="a-查找满足一定条件的节点"><a href="#a-查找满足一定条件的节点" class="headerlink" title="a.查找满足一定条件的节点"></a>a.查找满足一定条件的节点</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p=head-&gt;next;</span><br><span class="line"><span class="keyword">while</span>((p-&gt;data !=(满足的条件))&amp;&amp;(p-&gt;next !=<span class="literal">NULL</span>))p=p-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(p-&gt;data ==(满足的条件))处理该数据;</span><br><span class="line"><span class="keyword">else</span> 输出不存在;</span><br></pre></td></tr></table></figure><h4 id="b-查找所有满足条件的点"><a href="#b-查找所有满足条件的点" class="headerlink" title="b.查找所有满足条件的点"></a>b.查找所有满足条件的点</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p=head-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(p-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;data==(满足的条件))&#123;</span><br><span class="line">        <span class="comment">/*处理该数据*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    p=p-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="二-使用STL容器进行"><a href="#二-使用STL容器进行" class="headerlink" title="二.使用STL容器进行"></a>二.使用STL容器进行</h2><div class="story post-story"><h3 id="a-set"><a href="#a-set" class="headerlink" title="a.set"></a>a.set</h3><h4 id="1-特点"><a href="#1-特点" class="headerlink" title="1.特点"></a>1.特点</h4><p>无序，随机，类似于指针（但其实不是指针，STL容器过于强大）</p><h4 id="2-头文件"><a href="#2-头文件" class="headerlink" title="2.头文件"></a>2.头文件</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure><h4 id="3-定义容器"><a href="#3-定义容器" class="headerlink" title="3.定义容器"></a>3.定义容器</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set&lt;kind&gt;name</span><br><span class="line"><span class="comment">/*例：*/</span>set&lt;string&gt;class_set;<span class="comment">//类中的一个学生列表</span></span><br></pre></td></tr></table></figure><h4 id="4-添加元素"><a href="#4-添加元素" class="headerlink" title="4.添加元素"></a>4.添加元素</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="comment">/*满足条件*/</span>)&#123;</span><br><span class="line">    string str;</span><br><span class="line">    cin&gt;&gt;str;</span><br><span class="line">    class_set.<span class="built_in">insert</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-输出学生集合（无序的）"><a href="#5-输出学生集合（无序的）" class="headerlink" title="5.输出学生集合（无序的）"></a>5.输出学生集合（无序的）</h4><h5 id="1-创建迭代器"><a href="#1-创建迭代器" class="headerlink" title="[1]创建迭代器"></a>[1]创建迭代器</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set&lt;kind&gt;::const_iterator cur_name;<span class="comment">//cur_name为迭代器</span></span><br><span class="line"><span class="comment">/*example*/</span>set&lt;string&gt;::const_iterator cur_student;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="2-遍历输出"><a href="#2-遍历输出" class="headerlink" title="[2]遍历输出"></a>[2]遍历输出</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(cur_student = class_set.<span class="built_in">begin</span>();</span><br><span class="line">    cur_student !=class_set.<span class="built_in">end</span>();</span><br><span class="line">    cur_student++)cout&lt;&lt;*cur_student&lt;&lt;endl;</span><br></pre></td></tr></table></figure><blockquote><p>cur_student被定义成string类型的迭代器，类似于指针地址</p></blockquote><blockquote><p>初始条件：cur_student指针指向class_set.begin()的地址</p></blockquote><blockquote><p>终止条件：cur_student指针指向class_set.end()的地址</p></blockquote><p><em><strong>注意：不能将for循环里面的！=改成&lt;或者其他符号，因为列表是无序的。++指的是地址后移一位，而不是数字+1</strong></em></p><h5 id="3-使用foreach函数进行遍历输出"><a href="#3-使用foreach函数进行遍历输出" class="headerlink" title="[3]使用foreach函数进行遍历输出"></a>[3]使用foreach函数进行遍历输出</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*1.头文件*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="comment">/*2.创建输出指令*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(set&lt;string&gt;::const_iterator cur_student)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;*cur_student&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*3.使用foreach进行遍历*/</span></span><br><span class="line">foreach(class_set.<span class="built_in">begin</span>(),class_set.<span class="built_in">end</span>(),write);</span><br></pre></td></tr></table></figure><h4 id="6-其它"><a href="#6-其它" class="headerlink" title="6.其它"></a>6.其它</h4><p>set容器当中不能有重复的元素，否则程序会意外终止。如果你想要存放重复元素，你可以将上述set换成multiset即可。</p><h3 id="b-map"><a href="#b-map" class="headerlink" title="b.map"></a>b.map</h3><h4 id="1-特点-1"><a href="#1-特点-1" class="headerlink" title="1.特点"></a>1.特点</h4><p>不同于set，map有两个值，第一个可以称为关键字(key)，每个关键字只能在map中出现一次；第二个可能称为该关键字的值(value)；</p><p>key在一个map只能出现一次，但是value可以出现多次。</p><p>key和value是一对一(one-to-one)的，而不同于set，map是有序对。</p><h4 id="2-头文件-1"><a href="#2-头文件-1" class="headerlink" title="2.头文件"></a>2.头文件</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure><h4 id="3-声明map"><a href="#3-声明map" class="headerlink" title="3.声明map"></a>3.声明map</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std:map&lt;type1,type2&gt; variable;</span><br><span class="line"><span class="comment">/*example*/</span>std:map&lt;<span class="keyword">int</span>,string&gt; person;</span><br></pre></td></tr></table></figure><p>当然，如果你觉得每次都定义一个map太烦了，你可以使用<code>typedef</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> map&lt;<span class="keyword">int</span>,string&gt; mapp;</span><br><span class="line">mapp variable1;</span><br><span class="line">mapp variable2;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="4-加入元素"><a href="#4-加入元素" class="headerlink" title="4.加入元素"></a>4.加入元素</h4><p>现在，我们已经声明了一个叫做<code>variable</code>的map容器(你自己随便声明一个也无所谓)。插入有几种方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//First Kind:INSERT function</span></span><br><span class="line"><span class="comment">//1.insert+pair</span></span><br><span class="line">varibale.<span class="built_in">insert</span>(pair&lt;type1,type2&gt;(key,value));</span><br><span class="line"><span class="comment">/*example*/</span>variable.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>,string&gt;(<span class="number">1</span>,<span class="string">&quot;Bill Gates&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.insert+value_type</span></span><br><span class="line">variable.<span class="built_in">insert</span>(map&lt;type1,type2&gt;::<span class="built_in">value_type</span>(key,value));</span><br><span class="line"><span class="comment">/*example*/</span>variable.<span class="built_in">insert</span>(map&lt;<span class="keyword">int</span>,string&gt;::<span class="built_in">value_type</span>(<span class="number">2</span>,<span class="string">&quot;Jeff Bezos&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//Second Kind:Array[]</span></span><br><span class="line">variable[key]=value;</span><br><span class="line"><span class="comment">/*example*/</span>variable[<span class="number">3</span>]=<span class="string">&quot;Michael Dell&quot;</span>;</span><br></pre></td></tr></table></figure><p>为什么我要分为两种呢？因为使用insert+pair和insert+value_type组合效果是相同的。他俩都是通过insert函数插入数据。但是，如果某key已经有了一个value，insert函数是会自动跳过不执行指令的。如果使用array数组进行插入，新输入的数据就会把原有的数据覆盖住。</p><h4 id="5-查找元素"><a href="#5-查找元素" class="headerlink" title="5.查找元素"></a>5.查找元素</h4><p>这个时候又要用到迭代器了。先声明一个迭代器iterate，随后循环查找：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iterate = variable.<span class="built_in">find</span>(key);</span><br><span class="line"><span class="keyword">while</span>(iterate != variable.<span class="built_in">end</span>())&#123;</span><br><span class="line">    <span class="comment">/*处理该数据*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-删除元素"><a href="#6-删除元素" class="headerlink" title="6.删除元素"></a>6.删除元素</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.iterate</span></span><br><span class="line">iterate =variable.<span class="built_in">find</span>(key);</span><br><span class="line"><span class="keyword">int</span> del =variable.<span class="built_in">erase</span>(iterate);</span><br><span class="line"><span class="comment">//erase函数删除成功返回1，否则返回0，下同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.key</span></span><br><span class="line"><span class="keyword">int</span> del =variable.<span class="built_in">erase</span>(key);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.delete key1~key2</span></span><br><span class="line"><span class="keyword">int</span> del =variable.<span class="built_in">erase</span>(key1,key2);</span><br><span class="line"><span class="comment">//把key1到key2之间所有的数据全部删除</span></span><br><span class="line"><span class="comment">//如果想删除某map所有数据，有以下两种办法：</span></span><br><span class="line"><span class="comment">/*1*/</span><span class="keyword">int</span> del =variable.<span class="built_in">erase</span>(variable.<span class="built_in">begin</span>(),variable.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">/*2*/</span><span class="keyword">int</span> del =variable.<span class="built_in">clear</span>();</span><br></pre></td></tr></table></figure><h4 id="7-map大小"><a href="#7-map大小" class="headerlink" title="7.map大小"></a>7.map大小</h4><p>我怎么知道map里面目前有多少数据呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num =variable.<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure><p>未完待续。。。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一-链表结构的使用&quot;&gt;&lt;a href=&quot;#一-链表结构的使用&quot; class=&quot;headerlink&quot; title=&quot;一.链表结构的使用&quot;&gt;&lt;/a&gt;一.链表结构的使用&lt;/h2&gt;&lt;div class=&quot;story post-story&quot;&gt;&lt;h3 id=&quot;1-创建&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="编程算法" scheme="https://billma.top/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>我的第一篇博客</title>
    <link href="https://billma.top/2021/07/10/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <id>https://billma.top/2021/07/10/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</id>
    <published>2021-07-09T20:23:52.000Z</published>
    <updated>2021-08-25T13:40:50.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="首先-欢迎各位到访我的空间"><a href="#首先-欢迎各位到访我的空间" class="headerlink" title="首先,欢迎各位到访我的空间"></a>首先,欢迎各位到访我的空间</h3><p>一直没时间打理这个博客,时至今日,终于在凌晨从百忙中完成了我的第一篇博客.<br>这就算我的第一篇博客吧.</p><iframe src="//player.bilibili.com/player.html?aid=459511106&bvid=BV1t5411K71N&cid=309837458&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;首先-欢迎各位到访我的空间&quot;&gt;&lt;a href=&quot;#首先-欢迎各位到访我的空间&quot; class=&quot;headerlink&quot; title=&quot;首先,欢迎各位到访我的空间&quot;&gt;&lt;/a&gt;首先,欢迎各位到访我的空间&lt;/h3&gt;&lt;p&gt;一直没时间打理这个博客,时至今日,终于在凌晨从百忙中</summary>
      
    
    
    
    
  </entry>
  
</feed>
