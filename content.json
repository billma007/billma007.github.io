{"meta":{"title":"Bill Ma's blog.","subtitle":"","description":"","author":"Bill MA","url":"http://billma.top","root":"/"},"pages":[{"title":"Calall产品发布页","date":"2021-08-10T08:33:29.000Z","updated":"2023-12-12T11:52:55.963Z","comments":true,"path":"calall/1_0_db3.html","permalink":"http://billma.top/calall/1_0_db3.html","excerpt":"","text":"Calall是一款多功能计算器，可以精确计算指数函数，对数函数，7种三角函数，阶乘，以及发送邮件，定时关机/重启电脑，4种经典单机游戏等多功能。该版本为Callall3内测版第二版本，上线时间为2020/7/20。 软件声明如何使用下载链接更新内容及仍然存在的bugbug反馈方式/联系作者更多 1.软件声明 Calall多功能计算器 ©2020-2021 Billma 2.如何使用？ 一.首先，打开该软件，进入密码界面，输入密码6283； （注：Developer Beta版本有期限，过期则无法使用） 二.进入功能选择界面。选择要选择功能的序号，按下回车键。 1.log function：对数函数，点开后输入base number（底数）等参数，既可输出答案。注意，如果输出nan，则表明函数无效。2.factorial function：阶乘3.trigononetric function：计算三角函数。该功能具体用法在下面会讲到。4.pow function：指数函数。71.计算BMI。请按照软件提供的单位输入。62.给作者发邮件。在该版本不可用。64.作者精选美女高清大图。目前该功能仅提供三张测试照片。65.4种经典小游戏：贪吃蛇，打飞机，扫雷，小恐龙（部分机型体验较差，不建议使用）【注意：游戏一定要将输入法切换至英文再使用】100.Universal Calculator：普通计算器。在该版本不可用。97.Clear：清屏。该功能在2.3.0之后就没有使用的必要了。98.change color：改变背景颜色，目前内测版仅支持3种配色。99.close this software：关闭软件。在Linux系统中必须手动关闭。9901.Unistall this software：卸载该软件。输入错误：I don&#8217;t know what you&#8217;re entering，按任意键重新输入。 三角函数功能具体用法（该部分bug已经修复） 1-6.计算各种函数类型。选择后直接输入你要计算的数字（不能含有π）7.计算含有π的数字时，请选择7，然后输入要选择的模式，随后输入该数字（不需要输入π，系统已经自动乘上了）8.打印0-π/2之间所有数字的sin值并保存到软件所在目录下面的一个txt文件中。该程序根据必修一数学书的介绍编写，但是随后发现计算非常不准，不建议参考使用。注：以上所有计算均为弧度制，精确到小数点后4位，若出现nan则为定义域错误，若出现XXXe+XXX则为科学记数法，意思是a*10^b 飞机大战玩法 进入游戏，切换至控制位置，英文输入法，使用w和s按钮选择难度，按k开始游戏。 进入游戏后，用wasd控制飞机位置，用k开炮。 未解决的bug：飞机大战结束后ruoxu 3.如何下载 点击此处前往下载 4.bug见上。 目前仅支持Windows2000，Vista，XP，Windows7,8,10。系统需要64位。 仅支持Intel 酷睿I5/I7/I9/M1处理器，内存容量需要512MB，建议大于2048MB 暂不支持Windows2000以前的系统，WIndows11，Linux系统，MacOS所有系统 如果不会使用or有bug？ QQ：36937975 Wechat：billma6688 Email：maboning237103015@163.com Twitter：@billma007cool Facebook：billma007"},{"title":"about","date":"2021-08-07T08:34:23.000Z","updated":"2024-04-18T01:47:46.834Z","comments":true,"path":"about/index.html","permalink":"http://billma.top/about/index.html","excerpt":"","text":"关于作者江苏省某不知名四星级高中学生江苏省某以江苏省名字命名的双非院校大学生，数学系（数学系！），热衷于计算机，会C++，Python语言。 爱好爱好广泛（但都不精通），在各个领域都能看到我的身影。 游戏音游：成分复杂（phigros，arcaea，cytusII，demoo，maimaiDX，Muse Dash计划通玩家。玩过BanG Dream，lanota，dynamix，Groove Coaster，Rizline，Phira。 二游：原舟率玩家，崩铁退坑已经被吃阮饭了。 端游：天际线，钢丝，it takes two，dead cells，muse dash， tiny Tina’s Wonderlands，冰与火之舞等 音乐1.音游：如上 2.小提琴，上音10级 3.会唱歌，但是大学没唱过 4.曾经会用库乐队 5.乐理B,约等于没考过 番拉到最上面，选择追番就可以看到了（） 但是不全，毕竟追番调用的是b站的api，相当多的番貌似都在b站没有。。。 计算机会C++，已退役OIer &amp;&amp; ACMer，也会Python语言（自学的），也懂一点点（真的就一点点）前端开发。 正在了解深度学习，参与深度学习相关大创，同时正在自学java。 本人也喜欢使用hexo。目前使用过的主题有：Stellar,Volantis等。 联系方式1234567QQ=36937975Wechat=billma6688email=maboning237103015@163.comTwitter=@***(hidden)***Instagram/facebook=***hidden***private=billma.top"},{"title":"Calall产品发布页","date":"2021-08-10T08:33:29.000Z","updated":"2023-12-12T11:52:55.963Z","comments":true,"path":"calall/1_0_db2.html","permalink":"http://billma.top/calall/1_0_db2.html","excerpt":"","text":"Calall是一款多功能计算器，可以精确计算指数函数，对数函数，7种三角函数，阶乘，以及发送邮件，定时关机/重启电脑，4种经典单机游戏等多功能。该版本为Callall3内测版第二版本，上线时间为2020/7/20。 软件声明如何使用下载链接更新内容及仍然存在的bugbug反馈方式/联系作者更多 1.软件声明 Calall多功能计算器 ©2020-2021 Billma 2.如何使用？ 一.首先，打开该软件，进入密码界面，输入密码6283； （注：Developer Beta版本有期限，过期则无法使用） 二.进入功能选择界面。选择要选择功能的序号，按下回车键。 1.log function：对数函数，点开后输入base number（底数）等参数，既可输出答案。注意，如果输出nan，则表明函数无效。2.factorial function：阶乘3.trigononetric function：计算三角函数。该功能具体用法在下面会讲到。4.pow function：指数函数。71.计算BMI。请按照软件提供的单位输入。62.给作者发邮件。在该版本不可用。64.作者精选美女高清大图。目前该功能仅提供三张测试照片。65.4种经典小游戏：贪吃蛇，打飞机，扫雷，小恐龙（部分机型体验较差，不建议使用）【注意：游戏一定要将输入法切换至英文再使用】100.Universal Calculator：普通计算器。在该版本不可用。97.Clear：清屏。该功能在2.3.0之后就没有使用的必要了。98.change color：改变背景颜色，目前内测版仅支持3种配色。99.close this software：关闭软件。在Linux系统中必须手动关闭。9901.Unistall this software：卸载该软件。输入错误：I don&#8217;t know what you&#8217;re entering，按任意键重新输入。 三角函数功能具体用法（该部分bug已经修复） 1-6.计算各种函数类型。选择后直接输入你要计算的数字（不能含有π）7.计算含有π的数字时，请选择7，然后输入要选择的模式，随后输入该数字（不需要输入π，系统已经自动乘上了）8.打印0-π/2之间所有数字的sin值并保存到软件所在目录下面的一个txt文件中。该程序根据必修一数学书的介绍编写，但是随后发现计算非常不准，不建议参考使用。注：以上所有计算均为弧度制，精确到小数点后4位，若出现nan则为定义域错误，若出现XXXe+XXX则为科学记数法，意思是a*10^b 飞机大战玩法 进入游戏，切换至控制位置，英文输入法，使用w和s按钮选择难度，按k开始游戏。 进入游戏后，用wasd控制飞机位置，用k开炮。 未解决的bug：飞机大战结束后ruoxu 3.如何下载 点击此处前往下载 4.bug见上。 目前仅支持Windows2000，Vista，XP，Windows7,8,10。系统需要64位。 仅支持Intel 酷睿I5/I7/I9/M1处理器，内存容量需要512MB，建议大于2048MB 暂不支持Windows2000以前的系统，WIndows11，Linux系统，MacOS所有系统 如果不会使用or有bug？ QQ：36937975 Wechat：billma6688 Email：maboning237103015@163.com Twitter：@billma007cool Facebook：billma007"},{"title":"Calall简约版！","date":"2021-08-20T09:01:19.000Z","updated":"2023-12-12T11:52:55.963Z","comments":true,"path":"calall-light/index.html","permalink":"http://billma.top/calall-light/index.html","excerpt":"","text":"Calall简约版现已上线你是否觉得Calall太花里胡哨？你是否觉得Calall不会用？现在，Calall正式上线了！ 下载地址： 1.0.0.0Developer Beta 1：敬请期待 1.0.0.0Developer Beta 2：敬请期待 1.0.0.2Public Beta 1:敬请期待"},{"title":"分类","date":"2026-01-06T13:21:23.165Z","updated":"2026-01-06T13:21:23.165Z","comments":false,"path":"categories/index.html","permalink":"http://billma.top/categories/index.html","excerpt":"","text":""},{"title":"","date":"2026-01-06T11:44:13.738Z","updated":"2023-12-12T11:52:55.952Z","comments":true,"path":"404.html","permalink":"http://billma.top/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"1.0.1Developer Beta版本：如何使用？","date":"2026-01-06T11:44:13.740Z","updated":"2023-12-12T11:52:55.966Z","comments":true,"path":"wiki/calall-light/how_to_use.html","permalink":"http://billma.top/wiki/calall-light/how_to_use.html","excerpt":"","text":"1.下载地址:点击这里跳转2.启动时：输入密码点此获得密码 然后使用记事本打开即可获取。打开main.exe，在软件的最上面右击，选择编辑-粘贴然后回车即可。暂不支持Ctrl+V。一次输入密码无需再次输入。 3.直接输入算式支持以下算式： +-* / sin(); cos() tan(); sinh(); cosh(); tanh(); !//阶乘； 支持像科学计算器那样嵌套 暂不支持π"},{"title":"关于本站","date":"2021-08-07T08:34:23.000Z","updated":"2023-12-12T12:38:15.207Z","comments":true,"path":"about/station.html","permalink":"http://billma.top/about/station.html","excerpt":"","text":"1.RightMenu(右键菜单)本站右键菜单启用JS，如果需要调取系统菜单请按住Ctrl后再右击。 2.live2d本文已启用live2d模型，live2d模型作者cneyhn 如需关闭，请按F12（部分浏览器Ctrl+U）删除元素。 3.评论系统本博客采用Beaudar评论系统。该评论系统依赖github issues运行，所以需要注册一个github来进行评论 被墙了 4.主题本站使用Hexo制作。主题使用Volantis . 5.search(搜索功能)该功能暂不可用。 6.BiliBili本站外链的哔哩哔哩视频暂不适配电脑观看，手机端可以完美适配。注意，电脑端可以点击视屏下方的链接直接观看。 7.CSS订阅本站移动端支持CSS订阅。安卓或鸿蒙系统手机请复制以下网站到相应的CSS订阅器： 1https://billma.top/atom.xml 苹果手机在Safari中可以直接点击这里进行订阅 8.CDN加速本站使用CDN加速。但即便如此，本站的托管网站github的访问速度还是很下饭的。"},{"title":"","date":"2026-01-06T11:44:13.738Z","updated":"2023-12-12T11:52:55.963Z","comments":true,"path":"baidu_verify_code-ymIFKBAamH.html","permalink":"http://billma.top/baidu_verify_code-ymIFKBAamH.html","excerpt":"","text":"eecdbb800b42eb7ff563bd2fb258bc14"},{"title":"便笺","date":"2021-11-11T09:01:24.000Z","updated":"2023-12-12T11:52:55.964Z","comments":true,"path":"notes/index.html","permalink":"http://billma.top/notes/index.html","excerpt":"","text":"1.一堆奇奇怪怪的OJ系统"},{"title":"calall项目主页","date":"2026-01-06T11:44:13.740Z","updated":"2023-12-12T11:52:55.966Z","comments":true,"path":"wiki/calall-light/index.html","permalink":"http://billma.top/wiki/calall-light/index.html","excerpt":"","text":"Calall简约版现已上线你是否觉得Calall太花里胡哨？你是否觉得Calall不会用？现在，Calall正式上线了！ 下载地址： 1.0.0.0Developer Beta 1：敬请期待 1.0.0.0Developer Beta 2：敬请期待 1.0.0.2Public Beta 1:敬请期待"},{"title":"guestbook","date":"2021-09-19T12:22:12.000Z","updated":"2023-12-12T11:52:55.964Z","comments":true,"path":"guestbook/index.html","permalink":"http://billma.top/guestbook/index.html","excerpt":"","text":"(function(d, s) { var j, e = d.getElementsByTagName(s)[0]; if (typeof LivereTower === &#39;function&#39;) &#123; return; &#125; j = d.createElement(s); j.src = &#39;https://cdn-city.livere.com/js/embed.dist.js&#39;; j.async = true; e.parentNode.insertBefore(j, e); })(document, ‘script’);为正常使用来必力评论功能请激活JavaScript"},{"title":"游戏大全","date":"2026-01-06T11:44:13.739Z","updated":"2023-12-12T11:52:55.964Z","comments":true,"path":"game/index.html","permalink":"http://billma.top/game/index.html","excerpt":"","text":"这里是我自己制作的一些小游戏，欢迎来玩 1.你有多喜欢娟姐&#x2F;小南的英语&#x2F;数学课？这是新概念音游，由arcxingye制作框架。本游戏纯属是对两个老师课堂的喜爱。 你有多喜欢娟姐的课https://billmarepo.github.io/juan/index.html 你有多喜欢小南的课https://billmarepo.github.io/nan/index.html"},{"title":"南京航空航天大学苏州附属中学星湖高二建党百年诗歌朗诵活动","date":"2021-09-11T09:01:24.000Z","updated":"2023-12-12T11:52:55.965Z","comments":true,"path":"videopoem/index.html","permalink":"http://billma.top/videopoem/index.html","excerpt":"","text":"1.十人集体诗歌朗诵感谢以下参与人员参与录制： 汤骏懿 姚远 顾天欣 崔可欣 曹艺舟 祝中翔 杨海佳 沈思遥 王韬越 张翌晨 导演：马泊宁 姚远 拍摄+后期剪辑：马泊宁 陈星宇 特别感谢后勤小组：何昊 金弈 蒯翔 顾俊贤 陈星宇 视频播放 三连地址点击这里给作者给予支持：点击这里 2.陈星宇讲故事主讲：陈星宇 导演：马泊宁 拍摄+后期剪辑：马泊宁 陈星宇 特别感谢后勤小组： 张祉珺 视频播放 三连地址点击这里给作者给予支持：点击这里 3.张祉珺讲故事主讲：张祉珺 导演：马泊宁 拍摄+后期剪辑：马泊宁 陈星宇 特别感谢后勤小组： 陈星宇 视频播放 三连地址点击这里给作者给予支持：点击这里 4.幕后花絮 点击这里给作者给予支持：点击这里 感谢观看！"},{"title":"Calall产品发布页","date":"2021-08-10T08:33:29.000Z","updated":"2023-12-12T11:52:55.964Z","comments":true,"path":"calall/index.html","permalink":"http://billma.top/calall/index.html","excerpt":"","text":"Calall是一款多功能计算器，可以精确计算指数函数，对数函数，7种三角函数，阶乘，以及发送邮件，定时关机/重启电脑，4种经典单机游戏等多功能。该版本为Callall3内测版第二版本，上线时间为2020/7/20。 软件声明如何使用下载链接更新内容及仍然存在的bugbug反馈方式/联系作者更多 1.软件声明 Calall多功能计算器 ©2020-2021 Billma 2.如何使用？ 一.首先，打开该软件，进入密码界面，输入密码6283； （注：Developer Beta版本有期限，过期则无法使用） 二.进入功能选择界面。选择要选择功能的序号，按下回车键。 1.log function：对数函数，点开后输入base number（底数）等参数，既可输出答案。注意，如果输出nan，则表明函数无效。2.factorial function：阶乘3.trigononetric function：计算三角函数。该功能具体用法在下面会讲到。4.pow function：指数函数。71.计算BMI。请按照软件提供的单位输入。62.给作者发邮件。在该版本不可用。64.作者精选美女高清大图。目前该功能仅提供三张测试照片。65.4种经典小游戏：贪吃蛇，打飞机，扫雷，小恐龙（部分机型体验较差，不建议使用）【注意：游戏一定要将输入法切换至英文再使用】100.Universal Calculator：普通计算器。在该版本不可用。97.Clear：清屏。该功能在2.3.0之后就没有使用的必要了。98.change color：改变背景颜色，目前内测版仅支持3种配色。99.close this software：关闭软件。在Linux系统中必须手动关闭。9901.Unistall this software：卸载该软件。输入错误：I don&#8217;t know what you&#8217;re entering，按任意键重新输入。 三角函数功能具体用法（该部分bug已经修复） 1-6.计算各种函数类型。选择后直接输入你要计算的数字（不能含有π）7.计算含有π的数字时，请选择7，然后输入要选择的模式，随后输入该数字（不需要输入π，系统已经自动乘上了）8.打印0-π/2之间所有数字的sin值并保存到软件所在目录下面的一个txt文件中。该程序根据必修一数学书的介绍编写，但是随后发现计算非常不准，不建议参考使用。注：以上所有计算均为弧度制，精确到小数点后4位，若出现nan则为定义域错误，若出现XXXe+XXX则为科学记数法，意思是a*10^b 飞机大战玩法 进入游戏，切换至控制位置，英文输入法，使用w和s按钮选择难度，按k开始游戏。 进入游戏后，用wasd控制飞机位置，用k开炮。 未解决的bug：飞机大战结束后ruoxu 3.如何下载 点击此处前往下载 4.bug见上。 目前仅支持Windows2000，Vista，XP，Windows7,8,10。系统需要64位。 仅支持Intel 酷睿I5/I7/I9/M1处理器，内存容量需要512MB，建议大于2048MB 暂不支持Windows2000以前的系统，WIndows11，Linux系统，MacOS所有系统 如果不会使用or有bug？ QQ：36937975 Wechat：billma6688 Email：maboning237103015@163.com Twitter：@billma007cool Facebook：billma007"}],"posts":[{"title":"Linux系统调用","slug":"linux-compile","date":"2026-01-06T13:27:22.000Z","updated":"2026-01-06T14:45:37.711Z","comments":true,"path":"2026/01/06/linux-compile/","permalink":"http://billma.top/2026/01/06/linux-compile/","excerpt":"","text":"1.课程设计目的与要求重新编译Linux内核。 增加一个Linux的系统调用。 写一个程序进行调用。 2.课程设计设备与环境设备：MicrosoftSurface Laptop 5 (CPU:i7-1255U,内存16G) 环境：宿主机Windows 11虚拟机VirtualBox平台，使用CentOS7作为编译环境，使用Linux 4.20.4作为内核编译 3.实验过程在VirtualBox官网下载VirtualBox最新版本，并在宿主机下载CentOS7:https://www.virtualbox.org/wiki/Downloads 打开VirtualBox，新建虚拟机，选择centos7，取消勾选Proceed with Installation，完成初始化。 随后打开设置，将Memory提升至4096MB，然后将CPU 数量加到5，方便后面编译linux。或者依据电脑能力调到合适的数量。这个数量和后面编译指令有关系，请记住。 随后安装系统，在安装的时候设置root账户。不需要设置普通账户。除了存储空间需要点进去后点击完成以外，其他任何设置都不需要碰。 在接下来的步骤之前，你需要先学会下面内容： vim是命令行下的一种文本编辑器。打开一个文件后，首先进去的模式是命令模式。在该模式下无法进行编辑。 在该模式下，按下i进入编辑模式。进入编辑模式后用键盘上的上下左右挪动光标并进行编辑（不能粘贴）。按下esc返回到命令模式 命令模式下，最底部的区域是命令区，可以输入各种命令。以下是部分需要用到的指令： 按下“&#x2F;”，会进入查找模式。后面输入想要查找的内容，按下回车后进行查找。按下”n”寻找下一项，“N”则为上一项。 按下i就会进入编辑模式，如上所示。 按下:可以进行文件操作。后面如果跟着w，则代表保存。若为q则代表退出。若强制进行操作则添加感叹号。可以进行组合，例如:w是保存,:wq是保存后退出。 小技巧：新建一个空文件，可以先 vi newfile后直接 :wq 安装完毕后，我们的虚拟机是连不上网的。我们需要添加DNS解析。 123456789101112131415cd /etc/sysconfig/network-scripts/lsvi ifcfg-ens33# -----------vim.start-------------#在命令模式下按i进入编辑模式#把ONBOOT的no改成yes#然后在文件末尾加上两行：DNS1=8.8.8.8DNS2=4.2.2.2#按下esc，返回到命令模式#输入:eq保存# -----------vim.end---------------#重启网卡systemctl restart network 测试一下是否能连上网： 1ping baidu.com ping通后就需要配置一下yum。因为centos7已经EOL，所以我们需要自己配置yum。 12curl -O http://mirrors.aliyun.com/epel/7/x86_64/Packages/c/cloud-utils-growpart-0.31-4.el7.noarch.rpmsudo rpm -ivh cloud-utils-growpart-0.31-4.el7.noarch.rpm 大写的O不要小写。小写的也不要大写 接下来为了方便我们操作，我们需要给自己安装一个桌面。 123yum groupinstall &quot;GNOME Desktop&quot; &quot;Graphical Administration Tools&quot;systemctl set-default graphical.targetreboot 重启后选择一个登陆账号，就可以用桌面进行操作了。 解压内核首先打开自带的Firefox，前往：http://cdn.kernel.org/pub/linux/kernel/v4.x/ 找一个内核版本进行下载。我选择linux-4.20.4.tar.xz 下载的应该是.tar.xz，我第一次下载错了重新安装的时候没截图。 1234sucp -r &#x27;/home/billma007/linux-4.20.2.tar.xz&#x27; /usr/src/kernelstar xvJf linux-4.20.2.tar.xz -C /usr/src/kernels/ 第二行中，&#39;/home/billma007/linux-4.20.2.tar.xz&#39;是下载下来的位置。小技巧：直接把文件拖进到命令行中，就可以直接把他的路径复制到命令行中。最后面的文件夹不需要改。 配置编译环境搭建编译环境： 1234yum -y install bison flexyum install gcc g++ gdb make devtoolset-7-gcc* centos-release-scl ncurses-develyum install elfutils-libelf-develyum install openssl-devel 然后把内核配置文件复制过来 12cd /usr/src/kernels/linux-4.20.2/sudo cp /boot/config-3.10.0-1160.el7.x86_64 ./.config 第二行的那个config文件不一定是这个。反正是长得像的就行。注意我的空格 基本工作已经做好了。现在开始第一次编译： 1make menuconfig 选择save后exit 然后开始编译： 1make j5 前面设置了几个CPU就改成多少。我前面拨了5个，这边就用5个核心编译来获取最大效率。8个cpu就是j8，1个就是j1，以此类推。 编译完毕的截图我忘记截了。反正如果你看到很整齐的输出没有单独一段一段的文字就是编译成功了。 编译完毕后确认没问题就可以开始添加一个系统调用。 添加函数调用在linux-4.20.4文件夹中打开终端，添加一个调用函数的声明： 123456vim include/linux/syscalls.h#这边按i进入编辑模式#找到 #endif ，并在这一行之前输入 ：asmlinkage long sys_time(int num);# esc返回# 输入:wq保存并退出 随后编辑调用函数定义 12suvim kernel/sys.c 我添加的调用函数功能是：在不调用C语言中time()的情况下直接从linux系统中获取时间戳并上报到系统日志。 在末尾#endif后加上这个函数： 12345678910111213SYSCALL_DEFINE1(time, int, num)&#123; struct timespec64 ts; ktime_get_real_ts64(&amp;ts); printk(KERN_INFO, &quot;Current time: %lld seconds, %ld nanoseconds (num=%d)\\n&quot;, (long long)ts.tv_sec, ts.tv_nsec, num); return 0;&#125; 然后添加调用索引: 12suvim arch/x86/entry/syscalls/syscall_64.tbl 拉到整个文件最后，对照上面添加系统调用号，方便我们后期调用。最好按照顺序添加调用号。后面的数据不变。 保存后需要清除之前的编译配置，然后再次编译。 1234sumake mrpropermake menuconfigmake -j5 编译完成后需要将内核安装到系统中。 12sudo make modules_install sudo make install 随后重启，再重启界面选择我们刚刚编译的linux 4.20.4，课程设计完毕。 4.验证实验接下来我们验证是否可以调用我们刚刚编写的调用函数。 在桌面上创建文件1&#x2F;test.c，并写一个需要调应这个函数的c语言程序： 12345678910111213141516#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/syscall.h&gt;#define __NR_time 548int main(void)&#123; int num = 5; long ret = syscall(__NR_time, num); if (ret &lt; 0) &#123; perror(&quot;syscall failed&quot;); return 1; &#125; printf(&quot;syscall returned %ld\\n&quot;, ret); return 0;&#125; 随后编译： 123sugcc test.c -o test./test 发现返回值为0，表示调用函数被成功运行。 随后查看日志： 1dmesg | tail 发现时间戳被成功写入到日志中。 为了验证我们只在这个内核安装，我们返回到原本的那个Linux核心，发现程序没有检测到这个调用函数。这表明了我们确实只在新编译的内核中插入了这个函数。","categories":[],"tags":[]},{"title":"数码管动态显示电路设计","slug":"lab5new","date":"2024-12-27T12:28:57.000Z","updated":"2024-12-27T13:06:33.518Z","comments":true,"path":"2024/12/27/lab5new/","permalink":"http://billma.top/2024/12/27/lab5new/","excerpt":"","text":"实验原理与相关准备七段数码管是电子开发过程中常用的输出显示设备。实验箱中七段数码管采用共阴极，当数码管的中的哪一个段被输入高电平，则相应的这一段被点亮。四位一体的七段数码管在单个静态数码管的基础上加入了用于选择哪一位数码管的位选信号端口。 八个数码管的a、b、c、d、e、f、g、h、dp都连在了一起，8个数码管分别由各自的位选信号来控制，被选通的数码管显示数据，其余关闭。这样对于一组数码管动态扫描显示需要有两组信号来控制：一组是字段输出口输出的字形代码，用来控制显示的字形，称为段码；另一组是位输出口的控制信号，用来选择第几个数码管工作，称为位码。 实验内容及过程本实验要求完成的任务是在时钟信号的作用下，通过输入的键值在数码管上显示相应的键值。 在实验调试中，数字时钟从1HZ 开始改变，频率逐步提高，观察当始终频率达到多少时，可以看到8个数码管稳定的输出。用四个拨动开关作为输入，当四个拨动开关置为一个二进制数时，在数码管上显示其十六进制的值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354library ieee;use ieee.std_logic_1164.all;use ieee.std_logic_unsigned.all;entity lab5 is port( clk : in std_logic; -- 时钟信号 key : in std_logic_vector(3 downto 0); -- 输入按键，支持十六进制值 ledag: out std_logic_vector(6 downto 0); -- 七段显示的段码 sel : out std_logic_vector(2 downto 0) -- 3位地址信号，连接到74LS138 );end lab5;architecture behaviour of lab5 is signal count : std_logic_vector(2 downto 0) := &quot;000&quot;; -- 计数器信号begin -- 时钟驱动计数器 process(clk) begin if rising_edge(clk) then count &lt;= count + 1; -- 每个时钟上升沿递增 end if; end process; -- 将计数器值直接输出到 74LS138 的地址输入 sel &lt;= count; -- `count` 驱动 74LS138 的 A、B、C 地址输入 -- 根据按键值设置七段显示的段码（支持十六进制显示） process(key) begin case key is when &quot;0000&quot; =&gt; ledag &lt;= &quot;0111111&quot;; -- 显示 0 when &quot;0001&quot; =&gt; ledag &lt;= &quot;0000110&quot;; -- 显示 1 when &quot;0010&quot; =&gt; ledag &lt;= &quot;1011011&quot;; -- 显示 2 when &quot;0011&quot; =&gt; ledag &lt;= &quot;1001111&quot;; -- 显示 3 when &quot;0100&quot; =&gt; ledag &lt;= &quot;1100110&quot;; -- 显示 4 when &quot;0101&quot; =&gt; ledag &lt;= &quot;1101101&quot;; -- 显示 5 when &quot;0110&quot; =&gt; ledag &lt;= &quot;1111101&quot;; -- 显示 6 when &quot;0111&quot; =&gt; ledag &lt;= &quot;0000111&quot;; -- 显示 7 when &quot;1000&quot; =&gt; ledag &lt;= &quot;1111111&quot;; -- 显示 8 when &quot;1001&quot; =&gt; ledag &lt;= &quot;1101111&quot;; -- 显示 9 when &quot;1010&quot; =&gt; ledag &lt;= &quot;1110111&quot;; -- 显示 A when &quot;1011&quot; =&gt; ledag &lt;= &quot;1111100&quot;; -- 显示 b when &quot;1100&quot; =&gt; ledag &lt;= &quot;0111001&quot;; -- 显示 C when &quot;1101&quot; =&gt; ledag &lt;= &quot;1011110&quot;; -- 显示 d when &quot;1110&quot; =&gt; ledag &lt;= &quot;1111001&quot;; -- 显示 E when &quot;1111&quot; =&gt; ledag &lt;= &quot;1110001&quot;; -- 显示 F when others =&gt; ledag &lt;= &quot;0000000&quot;; -- 默认值，关闭所有段 end case; end process;end behaviour;","categories":[],"tags":[]},{"title":"用层次结构设计时序电路（Quartus）","slug":"clock-ff","date":"2024-12-26T14:08:52.000Z","updated":"2024-12-26T14:49:22.395Z","comments":true,"path":"2024/12/26/clock-ff/","permalink":"http://billma.top/2024/12/26/clock-ff/","excerpt":"","text":"这是一个简易的1khz输入频率的电子钟。简易数字钟电路分两个层次：（1）顶层：由一个时计数模块（24进制）和分、秒计数模块（60进制）、分频器、动态扫描模块组成顶层的原理图CLOCK.BDF；（2）底层：设计24进制、60进制技术模块、动态扫描模块、分频器模块。 1.先设计底层的24进制和60进制模块60进制模块： 12345678910111213141516171819202122232425262728293031323334library IEEE;use IEEE.STD_LOGIC_1164.ALL;use IEEE.NUMERIC_STD.ALL;entity counter_60 is Port ( clk : in STD_LOGIC; -- 时钟信号（1Hz） reset : in STD_LOGIC; -- 异步复位 count : out STD_LOGIC_VECTOR(7 downto 0); -- 计数值（BCD码表示） carry : out STD_LOGIC -- 进位信号 );end counter_60;architecture Behavioral of counter_60 is signal cnt : integer range 0 to 59 := 0;begin process(clk, reset) begin if reset = &#x27;1&#x27; then cnt &lt;= 0; carry &lt;= &#x27;0&#x27;; elsif rising_edge(clk) then if cnt = 59 then cnt &lt;= 0; carry &lt;= &#x27;1&#x27;; else cnt &lt;= cnt + 1; carry &lt;= &#x27;0&#x27;; end if; end if; end process; -- 将二进制计数值转换为BCD码 count &lt;= std_logic_vector(to_unsigned(cnt / 10, 4) &amp; to_unsigned(cnt mod 10, 4));end Behavioral; 24 进制模块： 12345678910111213141516171819202122232425262728293031323334library IEEE;use IEEE.STD_LOGIC_1164.ALL;use IEEE.NUMERIC_STD.ALL;entity counter_24 is Port ( clk : in STD_LOGIC; -- 时钟信号（来自分钟计数器的进位） reset : in STD_LOGIC; -- 异步复位 count : out STD_LOGIC_VECTOR(7 downto 0); -- 计数值（BCD码表示） carry : out STD_LOGIC -- 进位信号 );end counter_24;architecture Behavioral of counter_24 is signal cnt : integer range 0 to 23 := 0;begin process(clk, reset) begin if reset = &#x27;1&#x27; then cnt &lt;= 0; carry &lt;= &#x27;0&#x27;; elsif rising_edge(clk) then if cnt = 23 then cnt &lt;= 0; carry &lt;= &#x27;1&#x27;; else cnt &lt;= cnt + 1; carry &lt;= &#x27;0&#x27;; end if; end if; end process; -- 将二进制计数值转换为BCD码 count &lt;= std_logic_vector(to_unsigned(cnt / 10, 4) &amp; to_unsigned(cnt mod 10, 4));end Behavioral; 2.设计 1Khz-&gt;1Hz 的分频模块分频器： 123456789101112131415161718192021222324252627282930313233library IEEE;use IEEE.STD_LOGIC_1164.ALL;use IEEE.NUMERIC_STD.ALL;entity freq_divider is Port ( clk_in : in STD_LOGIC; -- 输入时钟 reset : in STD_LOGIC; -- 异步复位 clk_out : out STD_LOGIC -- 输出时钟 );end freq_divider;architecture Behavioral of freq_divider is constant N : integer := 1000; -- 分频系数 signal count : integer range 0 to N/2-1 := 0; signal clk_div : STD_LOGIC := &#x27;0&#x27;;begin process(clk_in, reset) begin if reset = &#x27;1&#x27; then count &lt;= 0; clk_div &lt;= &#x27;0&#x27;; elsif rising_edge(clk_in) then if count = N/2-1 then count &lt;= 0; clk_div &lt;= not clk_div; else count &lt;= count + 1; end if; end if; end process; clk_out &lt;= clk_div;end Behavioral; 3.设计动态扫描模块12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182library IEEE;use IEEE.STD_LOGIC_1164.ALL;use IEEE.NUMERIC_STD.ALL;entity dynamic_scan is Port ( clk_scan : in STD_LOGIC; -- 扫描时钟 reset : in STD_LOGIC; -- 异步复位 digits : in STD_LOGIC_VECTOR(23 downto 0); -- 输入6位BCD数字 seg : out STD_LOGIC_VECTOR(6 downto 0); -- 段选信号 sel : out STD_LOGIC_VECTOR(2 downto 0) -- 位选信号 );end dynamic_scan;architecture Behavioral of dynamic_scan is signal scan_count : unsigned(2 downto 0) := (others =&gt; &#x27;0&#x27;); -- 扫描计数器 signal current_digit : STD_LOGIC_VECTOR(3 downto 0); -- 当前显示的BCDbegin -- 扫描计数器 process(clk_scan, reset) begin if reset = &#x27;1&#x27; then scan_count &lt;= (others =&gt; &#x27;0&#x27;); elsif rising_edge(clk_scan) then if scan_count = 7 then scan_count &lt;= (others =&gt; &#x27;0&#x27;); else scan_count &lt;= scan_count + 1; end if; end if; end process; -- 位选信号 sel &lt;= std_logic_vector(scan_count); -- 当前显示内容选择 process(scan_count, digits) constant DASH : STD_LOGIC_VECTOR(3 downto 0) := &quot;1010&quot;; -- 定义破折号 begin case to_integer(scan_count) is when 0 =&gt; current_digit &lt;= digits(7 downto 4); -- 第一位数字 when 1 =&gt; current_digit &lt;= digits(3 downto 0); -- 第二位数字 when 2 =&gt; current_digit &lt;= DASH; -- 第三位破折号 when 6 =&gt; current_digit &lt;= digits(15 downto 12); -- 第四位数字 when 7 =&gt; current_digit &lt;= digits(11 downto 8); -- 第五位数字 when 5 =&gt; current_digit &lt;= DASH; -- 第六位破折号 when 3 =&gt; current_digit &lt;= digits(23 downto 20); -- 第七位数字 when 4 =&gt; current_digit &lt;= digits(19 downto 16); -- 第八位数字 when others =&gt; current_digit &lt;= &quot;0000&quot;; -- 默认关闭 end case; end process; -- 数字到段选信号译码 process(current_digit) begin case current_digit is when &quot;0000&quot; =&gt; seg &lt;= &quot;0111111&quot;; -- 显示 0 when &quot;0001&quot; =&gt; seg &lt;= &quot;0000110&quot;; -- 显示 1 when &quot;0010&quot; =&gt; seg &lt;= &quot;1011011&quot;; -- 显示 2 when &quot;0011&quot; =&gt; seg &lt;= &quot;1001111&quot;; -- 显示 3 when &quot;0100&quot; =&gt; seg &lt;= &quot;1100110&quot;; -- 显示 4 when &quot;0101&quot; =&gt; seg &lt;= &quot;1101101&quot;; -- 显示 5 when &quot;0110&quot; =&gt; seg &lt;= &quot;1111101&quot;; -- 显示 6 when &quot;0111&quot; =&gt; seg &lt;= &quot;0000111&quot;; -- 显示 7 when &quot;1000&quot; =&gt; seg &lt;= &quot;1111111&quot;; -- 显示 8 when &quot;1001&quot; =&gt; seg &lt;= &quot;1101111&quot;; -- 显示 9 when &quot;1010&quot; =&gt; seg &lt;= &quot;1000000&quot;; -- 显示破折号 when others =&gt; seg &lt;= &quot;0000000&quot;; -- 默认关闭 end case; end process;end Behavioral; 4.编译模块，获得组件；使用原理图调用上述模块，设计电子钟的顶层模块 实验结果：","categories":[],"tags":[]},{"title":"转载：新冠大流行和数字资本主义的崛起（文/丹尼尔·科恩（Daniel Cohen））","slug":"COVID-19-zbzydjq","date":"2022-02-06T07:18:06.000Z","updated":"2023-12-12T11:52:55.954Z","comments":true,"path":"2022/02/06/COVID-19-zbzydjq/","permalink":"http://billma.top/2022/02/06/COVID-19-zbzydjq/","excerpt":"","text":"新冠肺炎疫情的暴发，让面对面的交流接触成为了一种负担甚至是一种可怕的行为。为了让人们远离感染的风险，并防止大面积的感染造成的卫生系统的不堪重负，在许多国家，餐馆、咖啡馆、音乐厅和其他对繁荣的城市文明必不可少的文化设施，被关闭了长达一年之久。生活退回到家庭中，足不出户成为常态。 疫情期间的封锁状态，依靠网络的在线工作场景，无需进入实体店的网上购物体验，在不冒险外出的情况下自娱自乐，最大的赢家是亚马逊、苹果和网飞等公司，它们的市值在新冠危机期间不断地飙升。 事实上，这种所谓的数字资本主义恰恰依赖于减少实体互动和消除面对面会议的现实需要。新冠疫情使许多活动转向互联网的线上活动，例如，医疗问诊实现了远程在线服务。因而，疫情大流行让数字领域的巨头们获得了一个机会，得以对虚拟世界如何影响现实世界，进行一次全方位的实验。 2021年1月20日，德国亚琛市，伯利恒医院的医生与亚琛大学医院的医生通过远程医疗系统，讨论针对新冠患者的治疗方案。 要了解为什么数字经济与保护人们免受面对面互动的需要齐头并进，重读法国经济学家让·富雷斯蒂埃（Jean Fourastié）1948年的开创性著作《二十世纪的伟大希望》（The Great Hope of the Twentieth Century）会有所帮助。富雷斯蒂埃对未来世界进行了乐观的展望：在耕耘土壤的农业社会和与物质打交道的工业社会之后，服务社会中的人类最终将耕耘自己，教育、健康和休闲将成为新世界的核心。 “第三产业文明将灿烂辉煌，一半或四分之三的人口将享受高等教育的优势。”富雷斯蒂埃写道，“在几代人之内，即使是低技能工作的主动性，以及交通工具和休闲活动的多样性，都会有利于人类的个人主义倾向。” 因此，他得出的结论是，“这样的时代即将到来：历史已经进步到足以让人类合理地努力阐述新时代的哲学，并在一个不那么压抑的黑暗中努力实现戏剧性的诞生。机器要将人类从‘非生命体’就可自主完成的劳动中解放出来，把我们引向只有人类才能完成的工作：智力培养和道德提升。” 转型成为一个“人性化”社会这一观点得到了诸多人的评论。在1930年代成为法国首位社会党总理的利昂·布卢姆（Léon Blum）就是其中之一，他在此书出版时写下了一段精彩且直指核心问题的评论。此书预测到了一个没有经济增长的世界。富雷斯蒂埃确信服务型社会不会受制于科技，而科技最终会让经济增长消失。如果一个人所能出售的商品是他与别人相处的时间，那么经济增长在理论上受限于人拥有的时间。 疫情期间，亚马逊、网飞等公司成了大赢家。 这就导致了经济学家所说的“鲍莫尔成本病”，这是由威廉·鲍莫尔（William J. Baumol）和威廉·鲍文（William G. Bowen）在1960年代创造的经济术语。无论是医疗、教育还是表演行业，相当于鲍莫尔提出的两部门非均衡增长模型中的停滞部门，这是服务行业显著特征，靠的是人的一对一或一对多的服务，劳动效率难以提高。 如果没有数字技术，所有服务行业的从业人员都将缺少规模经济，从而无法让某个供应商接触到越来越多的客户。规模经济的概念，即企业可以在保持成本不变或只增加一点成本的情况下增加产量，是经济分析的基础。它让一家企业进入一个良性循环：客户群越大，其业务就越繁荣。否则，超过一定规模，公司就会陷入停滞。 服务业为了获得最大的经济利益，需要能使产品受众群体数量级剧增的新兴科技。例如，电影和电视技术让比以往更多的观众能看到演员们的表演。 我们花了很长时间，经过大量的反复试验，才找到了解决成本问题的方法。这也就是当下新兴的数字社会：当我们将人类个体的健康和欲望等肉体和精神的信息转化为数据集，人类就可以成为数字世界的一部分，在那里我们可以被算法管理，为了实现“效率”，每个人都必须成为可以被其他数据位处理的数据位。 人工智能软件将为无限数量的客户提供治疗、咨询和娱乐，只要相关信息事先已经数字化。当我手腕上的手表分析我的生命体征时，算法可以为我的健康问题开发定制的解决方案。2013年的预言电影《她》描绘了一个拥有情感能力的人工智能，“她”有着女演员斯嘉丽·约翰逊（Scarlett Johansson）迷人的声音，同时和数百万人谈情说爱。这就是《数字化人类》（Homo digitalis）所发出的憧憬：一个从人体极限中解放出来的世界。 正如富雷斯蒂埃预测的那样，人类是服务社会的核心，但为了满足当今对增长的永不枯竭的渴望，人类必须首先实现数字化。新冠大流行清楚地表明，一旦人们摆脱了面对面接触的必要性，在线实现增长是完全可能的。 显然，最大的问题是，数字化治疗是否会比疾病本身更糟糕。机器人会取代人类并导致人类因此陷入贫困吗？工业流水线工作是否会通过脸书和网飞让位于思想的泰勒主义？让人类陷入一种思想上的“标准操作方法”？ 通过历史时间的不断轮回，数字世界正在取代工业世界，而工业世界的老问题也正在数字世界中重新浮出水面。因此，我们是否必须重蹈旧世界的每一个阶段，包括道德破产、金融危机和经济不安全，还是我们可以做得更好？ 到2022年，我们可能就会有答案了。 （作者系巴黎经济学院校长、董事会主席，最近著有《不光彩的年代》）","categories":[{"name":"精华转载","slug":"精华转载","permalink":"http://billma.top/categories/%E7%B2%BE%E5%8D%8E%E8%BD%AC%E8%BD%BD/"}],"tags":[]},{"title":"U盘里的文件夹突然变成了“应用程序”后缀名怎么办？","slug":"file-exe","date":"2021-11-12T11:47:58.000Z","updated":"2023-12-12T11:52:55.957Z","comments":true,"path":"2021/11/12/file-exe/","permalink":"http://billma.top/2021/11/12/file-exe/","excerpt":"","text":"最近学校电脑有很多老师喜欢使用U盘拷贝文件，但是我发现，许多老师的U盘都被感染上了病毒。这种病毒很常见，感染力极强，而且甚至像360系软件等等根本无法查杀。那么，这种病毒如何查杀呢？ 1.病毒介绍文件夹EXE病毒，学名Worm.Win32.AutoRun.soq。这种病毒只会运行在win32系统上。当你把你的U盘插入到一台电脑后，突然发现U盘内生成了以文件夹名字命名的文件，扩展名为exe，并且它们的图标跟windows默认的文件夹图标是一样的，很具有迷惑性。当你双击这个被伪装的exe文件后，木马自动启动并在电脑内下毒。 2.运作原理简而言之，这个病毒就是将你原有的文件夹隐藏起来，然后制造一个exe文件伪装成你的文件夹，其实这个exe就是病毒。在“组织”中，勾选“显示被隐藏的文件和文件夹”，并且取消勾选“隐藏被保护的文件夹”即可看到你的文件夹。 完整病毒机理： 病毒运行后会释放以下文件： 123456789101112com.run dp1.fne eAPI.fne internet.fnekrnln.fnrog.dllog.edt RegEx.fnrfne spec.fne ul.dllXP-290F2C69.EXE（后8位随机） 这些文件会被复制到系统盘的C:\\WINDOWS\\system32里面 随后，新增以下注册表项，以达到病毒随系统启动而自启动的目的。 HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run 注册表值：XP-290F2C69（后8位随机） 类型：REG_SZ 值：C:\\WINDOWS\\system32\\XP-290F2C69.EXE（后8位随机） 添加以下启动项，实现病毒自启动：“C:\\Documents and Settings\\Administrator\\「开始」菜单\\程序\\启动” 里的“ .lnk”指向病毒文件。 下载病毒文件： （16,896 字节）保存为以下文件，并且运行它们：%Windir%\\System32\\winvcreg.exe %Windir%\\System32\\2080.EXE (名称随机) 然后，被感染的电脑接入移动磁盘后，病毒会遍历移动磁盘根目录下的文件夹，衍生自身到移动磁盘根目录下，更名为检测到的文件夹名称，修改原文件夹属性为隐藏，使用户在其他计算机使用移动磁盘打开其文件夹时运行病毒， 以达到病毒随移动磁盘传播的目的。 3.解决办法：1.杀毒软件360并不能查清此病毒，建议使用毒霸或者电脑管家查杀。注意，该方法只能清除病毒，但不能显示被隐藏的文件夹。 2.手工清除1、结束病毒进程。打开任务管理器，选择进程，结束进程XP-290F2C69.EXE（后8位随机），winvcreg.exe，2080.exe（随机名）。 2、删除病毒在System32生成的以下文件： com.run dp1.fne eAPI.fne internet.fne krnln.fnr og.dll og.edt RegEx.fnr fne spec.fne ul.dll XP-290F2C69.EXE winvcreg.exe 2080.EXE（随机名） 3、删除病毒的启动项，删除以下启动项： “HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run”里的XP-290F2C69.EXE（后8位随机） “C:\\Documents and Settings\\Administrator\\「开始」菜单\\程序\\启动” 里的“ .lnk” 4、清除你的点击“开始”—输入“cmd” ，进入命令提示符，然后进入你U盘所在的根目录，具体操作如下，比如你的U盘盘符位G(即你的U盘在G盘），那么依次运行如下命令（第一行的“G:”为你的U盘盘符）： 注意：第二句话会删除根目录下包括非病毒在内的所有exe文件，谨慎使用，可以仅使用1、3句话然后手动删除exe文件夹 123cd /d G:for /f &quot;delims=&quot; %a in (&#x27;dir /b /ad&#x27;) do (del /a /f /q &quot;%a.exe&quot;) for /f &quot;delims=&quot; %a in (&#x27;dir /b /adh&#x27;) do (attrib -s -h -r &quot;%a&quot;) 这一步也可以用C++来代替：（不会清除其他文件） 首先删除你跟目录下所有exe文件夹，随后使用此代码： #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;windows.h&gt; void listFiles(const char * dir); int main() &#123; using namespace std; char dir[100]; cout &lt;&lt; &quot;Enter a directory (ends with \\&#39;\\\\\\&#39;): &quot;; cin.getline(dir, 100); strcat(dir, &quot;*.*&quot;); listFiles(dir); return 0; &#125; void listFiles(const char * dir) &#123; using namespace std; HANDLE hFind; WIN32_FIND_DATA findData; LARGE_INTEGER size; hFind = FindFirstFile(dir, &amp;findData); if (hFind == INVALID_HANDLE_VALUE) &#123; cout &lt;&lt; &quot;Failed to find first file!\\n&quot;; return; &#125; do &#123; if (strcmp(findData.cFileName, &quot;.&quot;) == 0 || strcmp(findData.cFileName, &quot;..&quot;) == 0) continue; if (findData.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) &#123; cout &lt;&lt; findData.cFileName &lt;&lt; &quot;\\t&lt;dir&gt;\\n&quot;; string str=&quot;attrib \\&quot;&quot;; str.append(findData.cFileName); str.append(&quot;\\&quot; -s -h&quot;); system(str.c_str()); &#125; else &#123; size.LowPart = findData.nFileSizeLow; size.HighPart = findData.nFileSizeHigh; cout &lt;&lt; findData.cFileName &lt;&lt; &quot;\\t&quot; &lt;&lt; size.QuadPart &lt;&lt; &quot; bytes\\n&quot;; &#125; &#125; while (FindNextFile(hFind, &amp;findData)); cout &lt;&lt; &quot;Done!\\n&quot;; system(&quot;Pause&quot;); &#125; 输入你U盘所在盘符（例如 G:\\) （\\要反斜杠）即可","categories":[{"name":"日常经验","slug":"日常经验","permalink":"http://billma.top/categories/%E6%97%A5%E5%B8%B8%E7%BB%8F%E9%AA%8C/"}],"tags":[]},{"title":"孔子：黑暗王国里的残烛","slug":"zz_confuzi","date":"2021-10-30T13:49:45.000Z","updated":"2023-12-12T11:52:55.961Z","comments":true,"path":"2021/10/30/zz_confuzi/","permalink":"http://billma.top/2021/10/30/zz_confuzi/","excerpt":"","text":"原作者：鲍鹏山，民革成员，文学博士，作家，学者。上海开放大学人文学院教授 ，青海师范大学硕士研究生导师 [2] 、上海交通大学兼职教授。中国作家协会会员、中国孔子基金会学术委员会委员。潜心研究先秦诸子数十年，长期从事中国古代文学研究。 前言儒家者流。盖出于司徒之官，助人君顺阴阳明教化者也。游文于六经之中，留意于仁义之际，祖述尧舜，宪章文武，宗师仲尼，以重其言，于道最为高。——《汉书·艺文志》 士不可不弘毅，任重而道远。仁以为己任，不亦重乎！死而后已，不亦远乎！——曾参 一 孔子的长相颇怪。“生而圩顶”，就是说，他天生的脑袋畸型，头顶上中间低，四周高，司马贞说，其形状恰像倒过来的屋顶。名之曰丘，固当。不知命相学家是如何解释的。这种头顶是否暗示着承受天地之甘露阳光？孔子自学而成大才，其天赋必然很高。而其身长亦不凡，“九尺有六寸”，这在那时可以说是“硕人”了，“人皆谓之长人而异之”，人人都说他是长人，感到惊异。真正的一个齐鲁大汉。不过，这个“长人”的身影也确实够长了——长到遮蔽了整个民族漫长的历史，—个民族都—直顺着他的倒影前行两干多年了，我们何时才能走出这漫漫的阴影呢? 据司马迁和《孔子家语》的记载，孔子乃是商代“三仁”之一微子的后代。那个有名的“仁义之师”的统帅宋襄公，便是他的十一世祖——难怪他也像宋襄公那样泥古不化，自讨苦吃。用古老的仁义道德去对付现世的流氓强盗，这也是他家族的祖传秘诀吧，只可惜常常不灵。到孔子的六世祖孔父嘉，“五世亲尽，别为公族”，不再属王族，姓也成了“孔”。后来孔父嘉又为人所逼而奔鲁。所以孔子确实是一位“没落贵族”。到他父亲叔梁纥，便是连人丁也很寥落了：正妻连生九女，—妾生子叫孟皮，却又是个跛子。年近七十的叔梁纥大概非常绝望了。但他还要作最后的努力，于是便向颜氏求婚，颜氏少女颜征“从父命”而嫁给了古稀之年的叔梁纥。所以，司马迁说这是“野合”，“野”与“礼”相对，夫妻双方年龄差别太大，不合周礼，所以这婚姻不是“礼合”，而是“野合”。“野合而生孔子”——这实在太有意味了，为什么呢？孔子终其一生都在为“礼坏乐崩”而头疼，而愤怒，而奔走呼号，要人们“克己复礼”，孰料他本人即是个不合礼的产儿呢。如果他的那位老父亲真的克制自己来恢复周礼，可就没有孔子了。真玄哪。要知道，这不合“礼”的产儿，竟是他们这古老家族之链上最辉煌的一环，也是我们这古老民族历史上最辉煌的人物啊！ 宋人说，“天不生仲尼，万古长如夜”。好抬杠的李贄就此讽刺道，怪不得孔子出生之前，人们都点着蜡烛走路。我想，话不能这么说，也不是这么说的。我觉得，孔子确实是悬挂在那个遥远古世纪的一盏明灯，他使我们对那个遥远的时代不再觉得晦暗和神秘，他使那时代的人与后代乃至于我们沟通了。我们由他知道，即便在那么一个洪荒时代，也是有阳光普照着而万物不探手段地生机勃勃；那时代也发生着我们今天一样的事情：暴力和弱者的呻吟；混乱和宁静的企望；束缚与挣扎；阴谋与流血；理想碰了钉子；天真遇见邪恶；友情温暖，世态炎凉。在他手订的《诗经》中，我们甚至可以体验到最个性的感受——当那些面孔不一情性各异的个人复活时，那个时代不也就复活了吗？ 孔子生活的时代也真像他所说的，确实是混乱无道。他为之伤心不已：辉煌的“郁郁乎文哉”的周王朝已是日薄西山，伟大的周公早已英魂远逝，他制定的“礼”“乐”也土崩瓦解。“弑君三十六，亡国五十二”，到处都是乱臣贼子，且个个生龙活虎。西周古都废墟上的青草与野黍也一茬一茬地青了又黄，黄了又青，根深而茎壮了，掩埋在草丛中瓦裂的陶器早已流尽了最后一滴汁液。九鼎不知去向，三礼流失民间。东周呢？龟缩在洛邑弹九之地，可怜巴巴地看着那些纵横天下的伯霸诸侯，把九州版图闹得瓜分而豆刮。 无可奈何花落去，还有谁来用红巾翠袖，擦去周王混浊的老泪？连孔子本人都不曾去那里。在这种时候，要“兴灭国，继绝世，举逸民”，真无异于痴人说梦。孔子正是这样的一位痴人。痴人往往缺乏现实感。他的精神就常常脱逸出现实的背景，沉浸在过去的辉煌中，追寻着万物逝去的方向。是的，他一生都在追寻，他周游列国，颠颠簸簸，既是在找人，找一个能实施他主张的人，更是在找过去的影子，找东周昔日的文明昌盛。面对这一伟大帝国的文化废墟，孔子领悟到并承诺了自己的使命！但挽狂澜于既倒，或知其不可而为之，只不过是一种令人钦敬的悲剧精神罢了，他最终还是失败了。当他奔波倦极归来，在一条小河边饮他那匹汗马时，他偶然从平静的流水中惊见自己斑驳的两鬓，“甚矣，吾衰矣”（太惨啦！我已经衰老了！）他顿时心凉如水。这衰弱的老人，他的多少雄心都失败了，多少理想都破灭了。壮志不酬，眺望茫茫无语的宇宙，他心事浩茫。人世渺小，天道无情，青山依旧，哲人其萎。于是，一句意味深长的叹息便如一丝凉风，吹彻古今：“逝者如斯夫！” 我在几千年后的漆黑的夜里写这篇文章时，宛如见到他当初衰弱地站在苍茫高天之下的无情逝水边。那无限凄惶的老人的晚景使我大为感动。于是这篇文章的题目也就一闪而现了：这衰弱的，即将随着时间的流水逝去的老人，不就像黑暗旷野上快要燃尽的一枝蜡烛吗？四面飚风，寒意四逼，这支蜡烛艰难地闪耀…… 孔子死后，鲁哀公装模作样地悲痛一番，悼念一番，他写了一篇诔文，似乎感伤得很：“上天太不公平啦。不肯留下一位老人陪我，让我一人在鲁国孤零零的，唉，多么悲痛。”孔子的弟子子贡毫不客气地顶了回去：“生不能用，死而诔之，非礼也！” 其实，对孔子“生不能用”的，岂止—位鲁哀公呢？孔子一生见过不少诸侯，像楚昭王，齐景公，卫灵公……等等，有谁用他呢？天下人事纷纷扬扬，新生事物层出不穷，人人都在玩新花样，搞新名堂，他老先生拿着一把过时的且是万古不变的尺子，东量量，西测测，这也不合“礼”，那也不合“乐”，到处招人惹人，别人对他敬而远之也是很自然的。同时他又像一个蹩脚的推销员，推销过时的、早已更新换代的产品。这产品不是按顾客的需求而设计，而是要以这产品的规格来设计顾客，正如韩非嘲笑他的，不是根据脚的大小来选鞋，而是根据鞋的大小来“削足”。他这么不合时宜，被人拒绝不是很正常的么？子贡以他的经济实力和外交天才，到处为老师打点鼓吹，也没有什么效果。子贡的悲痛心情是可以理解的，但过分责备鲁哀公不能用孔子，就不大合情合理啦。 二 痴人有多种，或因情深而痴，或因智浅而痴，孔子属于前者，而他的很多徒子徒孙，如宋明之际的理学家们，就属于后者了，新儒家们当更是等而下之。因情而痴的孔子常常沉湎在过去的怀想之中，“郁郁乎文哉！吾从周！”“逝者如斯夫！”这时，他就是一位抒情者，抒得很动情，很感人。在一个抽象的、冷酷的、沉闷的老子之后，出现一个一往情深、感怀万端的孔子，使我们再次感受到—种温软，一种熨帖，这实在是让我们大大舒了—口气，历史终于在绝望中咧口而哭出了声，一些可怕的心理能量在孔子的歌哭、幽默、感喟中被释放了。 孔子使一些无序的暴力变成了有目的有方向的努力与企望，他使天下英雄入于他的彀中，并带着这些社会精英致力于建构新的理想。当混乱的历史有了理想与方向时，混乱就不再是一无是处，相反，倒往往显示出一种蓬蓬勃勃、生机无穷的魅力。春秋战国时代是一个刀光剑影的时代，一个流血漂橹的时代，一个杀人盈城、杀人盈野的时代，但它不也是一个充满理想，充满激情，充满公理仁德的时代吗？谁开辟了这样的时代？是孔子。非常具有象征意义的是，当孔子和弟子们周游列国的时候，他往往自己驾车——他确实是在驾着这个时代的马车。弟子们在车上或呼呼大睡或哈欠连天，一脸凄迷与怀疑，只有他永远目光炯炯，自信目标就在前方。 有一次，在一条汤汤而流的小河边他们又找不到渡口了。远处的水田中有两人在耕作，子路便上前去打问。 其中的一个细长个子却不回答子路的询问，而是反问子路： “那个执缰绳的人是谁？” 子路恭敬地回答：“是孔丘。” “是鲁国的那个孔丘吗？”——可见孔子的知名度颇高。 子路答：“是”。这个细高个冷冷的就来了一句：“既然是鲁国的那个孔丘，他应该知道渡口在哪里嘛”。 没奈何，已经由绿林好汉改邪归正到孔子门下的子路，只能按捺住火气，转过身去问另一位。这一位魁梧雄桀，是个大块头。大块头也反问子路：“你是谁？” 子路仍然是恭敬地回答：“我是仲由。” “你是孔丘的门徒吗？” “是。” 现在又轮到大块头来教训子路了：“天下混乱，举世皆然。谁能改变这种局面？我看你身体强壮，是个好庄稼汉。与其跟随孔子这样的避人之士东奔西走，鼓唇摇舌，倒不如跟随我们这些避世之士，躬耕垄亩的好！” 这里我先解释两个词。什么叫“避人”呢？避人就是择人，就是避开那些昏庸无道的诸侯，而去寻找志同道合的有为之君，一同来重整乾坤。良禽择木而栖，贤才择主而事嘛，不择主，只要给富贵就帮他卖力，那是苏秦张仪的作为。孔子一心要的是救世，而不是个人富贵，所以他恓恓惶惶的马车在纵横阡陌间奔走扬尘，就是要避开身后的昏君而去寻找前面的明君。什么是“避世”？在“避人”的基础上再跨一步，彻底冷了心，闭了眼，认定天下不可能有什么诸侯还能与他一起改变这世界，于是彻底绝望；从而彻底不抱希望，回到田园中去，回到自己的内心中去，告别都市、政治与熙熙攘攘的外部世界，就叫避世。 再回头说子路被这两人教训得一愣一愣的，又要注意自己此时的身份，不能发作，只好垂头丧气地回来向孔子汇报。孔子听完，不尽的迷惘。谁说这两位隐士说得不对呢？这不也是孔子自己内心中常有的感触吗？但他历尽艰辛，学而不厌，“十年磨一剑，霜刃未曾试”，难道就此卷而怀之吗？他有教无类，诲人不倦，门徒三千，贤者七十二，就是为了培养一批隐士，或者懂文化的农夫吗？于是他感慨万端：“人总不能与鸟兽一起生活在山林之中啊，我不和芸芸众生生活在一起，与他们共享欢乐共担不幸，我又能和谁生活在一起呢？他们说天下无道，但不正因为天下混乱无道，才需要我们去承担责任吗？假如天下有道，还需要我们吗?” 《论语》中的这一段，很传神，两千多年了，那条汤汤小河边发生的这场争论就好像发生在昨天似的。这几个人好像还在我们身边。我尤其为孔子感动。他恓惶而寂寞，迷惘而执拗。“志于道”的人越来越少了，不少人顺应潮流，从而成了新贵，或成为新贵的红人，其中甚至有他的门徒，比如那个顶善于察言观色的弟子冉求。又有不少人冷了心，折断宝剑为锄犁，平戎策换得种树书，如长沮，桀溺；其中也有他的弟子，如樊迟。樊迟向他问稼，问为圃，大概也是准备避世了吧。望望眼前，路漫漫其修远兮，看看身后，追随者渐渐寥落。“道不行，乘桴浮于海，从我者，其由与！”（道行不通了，我只能乘小船漂荡到大海中去了。到那时还能跟随我的，可能只有一个仲由了吧！） 这位可敬可叹的老人，想凭自己个人的德行与魅力来聚集一批年轻人，让他们传道义之火，文化之火；拯民于水火，匡世于既颠，但年轻人不容易经受得了各种诱惑，“吾未见好德如好色者”（我从未见过一个喜爱德行比得上喜爱美色的人。）“吾未见刚者”（我未见过刚强的人）“吾未见好仁者，恶不仁者”，（我未见过喜好仁厌恶不仁的人）“末闻好学者”（没听说过好学的人）。这些话不也把他的三千弟子甚至七十二贤者都包括在内了吗？要让这些弟子们“无欲则刚”、“好德如好色”都不可能，更何况别人？韩非就曾刻薄尖酸地揶揄孔子，说凭着孔子那么巨大的个人德行，不就只有七十子之徒跟随他么？而下等君主鲁哀公却能让一国人都服从他，孔子本人也不得不向鲁哀公臣服。所以，人是多么容易向权势屈服，而向慕仁义的人是多么少啊。孔子此时的处境，真是令人同情。 但他更让我们尊敬。这就是他的那种“知其不可而为之”的殉道精神。“三军可夺帅也，匹夫不可夺志也”（三军可以更改主帅，匹夫却不能逼他改变志向）。匹夫尚且不能夺志，更何况圣人之志，得天地浩然正气，至大至刚，岂容玷污？天下一团漆黑了，不少原先追求光明的人也练就了猫头鹰的眼睛，从适应黑暗而进于喜欢黑暗，为黑暗辩护，他们把这称为提高了觉悟和认识，并且得道似的沾沾自喜于在黑森林中占据了一棵枝丫，又转过头来嘲笑别人不知变通。而孔子，这位衰弱的老人却在那里一意孤行！我很喜欢“一意孤行”这个词，很喜欢这个词所指称的那种性情与人格。敢于一意孤行的人必有大精神，大人格。 一位楚地的狂生曾经警告过孔子：“往者不可谏，来者犹可追。已而已而，今之从政者殆而！”（你过去糊涂就算了，以后你可改了吧！算了吧算了吧！现在追随政治危险得很啦！）但不能因为政治危险，就置天下苍生于不顾，听任他们受暴政的煎熬，置自己的伦理责任于不顾！“政者，正也”——政治，就是对暴政的矫正！就是正义！所以，孔子庄严宣告：“志士仁人，无求生以害仁，有杀身以成仁。”虽然他也说过“危邦不入，乱邦不居，天下有道则见，无道则隐”之类的话；虽然他也称赞蘧伯玉：“邦有道则仕，邦无道则卷而怀之”，宁武子“邦有道则知，邦无道则愚”，并慨叹“其知可及也，其愚不可及也”（他的聪明别人是比得上，他的糊涂别人就比不上了），大有郑板桥“由糊涂入聪明难，由聪明入糊涂尤难”的意味，但他对自己，却有更高的要求，那就是如史鱼一样，“邦有道，如矢，邦无道，如矢”，永远是如射出的箭一样，正道直行，永不回头。 自魏晋以后，中国的文化传统中，就有了一种极古怪的现象，那就是人格理想与伦理责任的分离。最受人敬仰的人格乃是那些在天下苦难面前卷而怀之、闭目养神的隐君子！他们的伦理关怀哪里去了？他们的道德痛苦哪里去了？作为知识分子，他们的基本人道精神哪里去了？难道我们不应该要求知识分子有起码的价值关怀吗？但我们却偏偏认为他们是涵养最高、道德最纯洁的人！鲁迅禁不住对这些人怒形于色：泰山崩，黄河溢，隐士目无见，耳无闻！这种目不关注人间苦难，耳不听弱者呻吟的人物，不就是饭桶酒囊茶壶甚至权势的尿壶么！现在不少人飘飘然地要“告别鲁迅”，却又腻歪歪地对“茶壶”周作人大为钟情。这种人是难以让人生出敬意的。一个人让人尊敬是有条件的。在孔子那里，在他的学说之中，那种古典的崇高确实让我们这些聪明机灵的后来人愈显扁平而单薄。 三 孔子的哲学核心是“仁”。在《论话》中，“仁”以不同的面目，在不同的背景下出现了无数次。这些闪烁不定的面容并不是因为孔子的“仁”没有“一以贯之”的主旨，而恰恰说明了“仁”内涵的丰富。樊迟问“仁”，孔子答曰“爱人”；颜回问“仁”，孔子答曰“克己”，曾子概括说，“夫子之道，忠恕而已”。朱熹解释说，尽自己的力量去办事叫忠，推己及人叫恕。这样看来，孔子的“仁”，也就是从人我双方立论，相当于我们今天常说的“人类共存意识”吧。 “仁”的内涵里，主要的两方面就是“忠”和“恕”。有了这个“忠”，就会有足够的自我约束；有了这个“恕”，就会有足够的对别人的宽容。这个顶重要了。孟子后来讲“仁”，就不大讲“恕”了，这就一步一步走向专制。孟子就没有孔子可爱。当然，孔子的“仁”，不仅仅是指一个人应当具有的人格境界，而且还应该是一个社会政治应当具有的政治理念。是公理，是正义。因而，在非常时刻应当“杀身以成仁”，而决不能”求生以害仁”。他自己一生，倡导“仁”，实践“仁”，修自身为“仁”，又要改造社会政治为“仁”。修自身成“仁”，他是做到了，改造社会政治为“仁”，他失败了。但他“颠沛必于是，造次必于是”，何曾有—丝—毫的媚俗之态！他正大光明，磊磊落落，他一意孤行，坦坦荡荡。 他亦知道改造社会是不可能的，但他“知其不可而为之”，关键在于做！他肯定已经意识到了他在未来的影响，所以他要用自己的行为树立一个榜样，以自己的生命之汁点亮一盏明灯，使后世一切以各种借口逃避伦理责任的行为无所遁形。——既然他已经在知其不可的情形下做了，而且做得如此艰苦，如此卓绝，如此寂寞，又如此轰轰烈烈，如此失败，又如此辉煌灿烂。因失败而辉煌，我以为这是古典悲剧的基本定律，不失败何以感人心？不辉煌何以长人志？但这失败必须是大失败，必须是必然的失败，是自由在逻辑面前的失败，是个人意志在历史规律面前的失败，而且必须是主人公已经预知的失败。他已经预先知道结局了，但高傲的心性使他无法改变自己人生的方向。在古典悲剧中，生命的投入是人格成就的最后一道工序，如干将莫邪之铸剑，最后必以自身的血肉之躯投入熔炉，用自己的血光赋予宝剑以阳刚杀气。 孔子的“得其真传”的弟子曾参，有一段话：“士不可不弘毅，任重而道远。仁以为己任，不亦重乎？死而后已，不亦远乎？”我无法不为这句话而感动，虽然我已经被那些最靠近话筒，因而最有发言权的某些人的这个“后”那个“后后”，还有什么“解构”，解构得没有什么完整的心智了。曾子的这段话包含着两个推论，所以我们可以把它译成问答句：士为什么要弘大坚定？因为他们任重道远。为什么说他们任重？因为他们是把仁当作自己的人生责任的；又为什么道远？因为他们除非死掉，不然就不能卸下这副担子。这就是自讨苦吃式的崇高。我上文说，让人尊敬是有条件的，不能因为你读了不少书，甚至读了不少洋文书，知道各种主义，就能受人尊敬。你还得有所承担。孔子及其弟子们，在那么—个时代，就已经意识到担当道义是知识分子的最高使命甚至无法摆脱的宿命了，就已经知道执行文化批判而不是文化媚俗文化献媚是知识分子的基本职责了，他们怎能不伟大，又怎能不为这伟大而颠沛，造次！ 那些冷了心肠的隐士讽刺孔子，还有些愤世嫉俗的道理。而下面这位“丈人”对孔子的批评就莫名其妙了： 子路从而后，遇丈人。以杖荷蓧。 子路问曰：“子见夫子乎？” 丈人曰：“四体不勤，五谷不分，孰为夫子？”植其杖而芸（耘）。 子路拱而立。 止子路宿。杀鸡为黍而食之。见其二子焉。 …… 子路曰：“不仕无义。……欲洁其身而乱大伦！君子之仕也，行其义也。道之不行，已知之矣。” 这一段中的“四体不勤，五谷不分”，后来成为不少人批评孔子的口实。是的，在一个小农意识很浓厚的国家里，这种情形较易发生，并且较易引来阵阵喝彩。甚至人们还能这样想：你孔子四肢不勤劳，五谷分不清，你连一个农夫都比不上。这种说法会引来更多的喝彩，因为很多人一下子从孔子的缺点中找回了自己的自信心。——但我要说，这种批评的荒谬性太明显了。在春秋后期，我们缺少一位农夫吗？减少一位卓越的思想家，增添一名普通的农夫，我们就是这样算账的吗？我们这个民族的历史与文化会因此更加辉煌灿烂吗？我们这个“文明古国”就会更加文明吗？ 另外，我们民族在那个时代连养活一位像孔子这样的大思想家的经济能力都没有，还必须让他自己去耕种自存吗？或者，我们这个民族连给孔子这样的大思想家提供必要的生活条件都不愿意，而必欲使之和农夫一样才心满意足吗？这些问法可以换成现代式的：我们必须分给陈景润一块自留地，由他自己播种，收获，磨粉，蒸馒头，吃下去，然后再去桌子边求证他的哥德巴赫猜想吗？如果不是这样，他即使证出了1+2，由于他不会蒸馒头，于是我们就可以鄙夷他连一个馒头师傅都不如吗？我的这种问法不是没有道理的，二十多年前，我们就这么干过。否则，要办那么多的“干校”干什么? 樊迟问稼问为圃，孔子怒不可遏，甚至在背后骂他是“小人”。又有不少人说这是孔子轻视体力劳动，现在的某些大学教材上就有这种说法。这种批评也太师心自用了。问如何种菜种小麦，需要问孔子吗？孔子的回答：“我不如老农民，我不如老菜农”，已经说得很明白了：你樊迟要学这些，你何必到我这儿来？你去问老农即是。要学腌泡菜蒸馒头切土豆丝，需要去中科院生问博士生导师吗？ 以上的问题还在于，培养一个老农易，至少在孔子那时，还不提倡科学种田时是这样。那时候就没有什么农业技术学校，但遍地是老农在种麦子种大头菜。培养一个知识分子就难了。孔子的时代，传播知识，提高人口素质，似乎比自己去亲自参加劳动更迫切。所以，孔子的这些言行，与轻视体力劳动如何扯得上。这一位“植其杖而芸（耘）”的“丈人”，耘来耘去，也就那一亩二分地，所养活的，不过就是他自己及家人。这又如何能与孔子比呢？他自己的言行能够传留后世，还是沾的孔子的光呢。孔子所耘的是什么荒？是文化之荒！所培养的是什么苗？是文化之苗！柳诒徵《中国文化史》云： 孔子者中国文化之中心也，无孔子则无中国文化。自孔子以前数千年之文化赖孔子而传，自孔子以后数千年之文化赖孔子而开。 孔子所给予我们这个民族的，甚至全世界的，又如何能估量？又如何是小农思想满脑子的人所能理喻、所能批评的？ 所以，上述的那些对孔子的批评，让我联想到今天一些人对鲁迅的批评，以及他们莫名其妙的对于鲁迅的优胜感。鲁迅的某些缺点确实让某些人孱弱的心性得到一种自信的证明。但他们对于鲁迅的批评，恰像旧时代老爷家中感觉很幸福从而很温柔的小妾，对现代独身女性的批评；又好比是青铜时代贵族几案上的玲珑的酒器或床底下温静的溺器，对铁器时代绿林好汉手中青锋长剑的批评。 我对古代的隐士评价不高。相应的，我对现代的周作人及其鼓吹者们也心存怀疑。我认为，一个人，比如这几年“告别鲁迅”而麋集到周作人羽翼下的一些人，他在这个社会里占有了比别人好—些的地位、财富、机会，使他能上大学读书，能明理，他理应对这个社会有所回报，有所补偿。按我们现在的大学招生数和报考数，有一个上大学的，就必至少有一个或更多上不了大学的。这种回报与补偿就是把自己的聪明才智贡献出来，使这个社会有所进步，人们的幸福能有所增进。也就是说，他的知识应该有益于社会，而不是把这种知识当成自己的文雅的小妾。我在一篇文章里，就认为周作人是把他的学识当小妾，只让她陪自己喝茶谈玄。而如果把知识当作取媚权力的手段，就更等而下之了。另一方面，出于某种自私的目的，掩盖自己的智慧，就是对社会的背叛；隐匿自己的发现，就是对社会的犯罪——当然，这种行为在专制社会里可能是迫不得已的。 四 因为怕孔子到楚国后说陈蔡诸侯的不是，陈蔡的小政客们便把孔子围在郊野。小政客毕竟是小政客，他们把孔子围住后，却拿不准到底要怎么样。面对一位文化巨人，他们的内心毕竟很虚怯。他们很憎恨孔子文化人格的光芒，所以，他们把他包围起来，试图挡住这光芒的四射，但他们又绝没有胆量去迫近光源——于是在陈蔡之野，便有了这样一种既滑稽又尴尬的场面：里面的人出不去，外面的人也不进来。彼此都迫切希望有一个第三者出现，来给大家一个台阶下。在第三者楚昭王派兵迎接孔子之前，孔子和他的弟子们在饥肠辘辘与满脸菜色中进行一番有趣的对话，其主题是讨论道与势的关系。 孔子的知音司马迁在记叙这一段历险时，把孔子的人格精神写得淋漓尽致。据司马迁记载，此时的孔子，有意识地利用这次挫折，来考验、考查弟子们对道的忠诚贞定。孔子先叫来子路，问他：“难道我的主张不对吗？我为什么落得这个下场？”忠厚的子路疑疑惑惑地说：“是不是我们还不仁呢？人们不信任我们？是不是我们还不智呢？人们不放心我们？”悲愤的孔子说：“仲由啊，你听着，假使仁义的人一定受信任，怎么会有饿死首阳山的伯夷和叔齐？假使智慧的人一定行得通，怎么会有被纣王挖腹剖心的王子比干？”子贡进来了，孔子用同样的问题问他，子贡说：“老师，你的道太伟大了，所以这狭隘的世界容不了你。你能不能稍微降格以求呢？”孔子说：“赐啊，好的农夫只问耕耘不问收获，好的工匠只追求技巧而不追求苟顺人意，作为君子，修习大道，是不能讲苟合的啊。” 最后是颜回入见，这位比孔子小三十岁的小学生，聪慧谦让，悟性高，不爱显山露水，能过苦日子，深受孔子的喜爱。他的回答，令先生愁肠顿开：“夫子之道至大，故天下莫能容。虽然，夫子推而行之，不容何病？不容然后见君子！夫道之不修也，是吾丑也，夫道既已修而不用，是有国者之丑也。不容何病！不容然后见君子！”孔子欣然而笑，说：“说得好啊，颜家小于！将来你发财时，我给你赶车吧！ 五 孔子晚年，倦于奔波。鲁迅曾在一篇颇似游戏的文字中推测孔子晚年有严重的胃病和胃下垂。一个医生对一个常年在坎坷的道路上颠簸的人很容易下这个判断。总之，孔子老了，病了，不能再奔波了，况且奔波又有什么收获呢？于是，在离开鲁国十四年之后，靠弟子冉求的疏通，又回到了鲁国故乡。此时孔子已是知命了，不说心如死灰，但心如止水却是必然的。鲁君无意用他，他也懒洋洋的不求用了。回到自己阔别多年的老屋，撩去门楣窗棂上的蛛网，拂去案几上的积尘，他坐下来，心境一片茫然。这时，外面的世界更混乱了，乱臣贼子们活得更神气了，但也令他更无奈了。宝剑折断，铩羽而归，他还能做些什么呢？他打开了竹简。这是一个有世界意义的举动。孔子现实政治活动的失败使中国少了一位晏婴、子产或管仲式的人物，但却使世界从此有了一个伟大文化的源头。这活力绵绵不绝的文化之源，浩浩荡荡，渐远渐无穷，使整个东方世界都浸润其中。是的，当孔子的现实政治活动失败后，他埋头于古代典籍的整理；在被自己的时代拒绝之后，他成功地通过文化符号进入了未来的世纪；在被几个诸侯国的诸侯和政客拒绝后，他的影响力却遍及全世界，名声响彻天下。 孔子本来是想通过立功来传名后世的，像他终生倾慕的周公一样。但这一点已经毫无疑问地没有可能了。“君子疾没世而名不称焉！”（君子很惧怕死后没有名声留传啊）于是他便想通过立言来不朽。我们知道，在这一点上，他成功了，而且在立言中他还立了德。“三不朽”他完成了两项。据司马迁的记载，“六经”都是经他手订的。也正因了他的手，这些积满时光尘土的古典才成为“经”，而为后世不断地钻研，又在这不断的琢磨中发出历久弥新的光芒。 那本“饥者歌其食，劳者歌其事”的三百零五首“诗”，记录着那么遥远时代的真切的痛苦，更是因为他的手订，由愚夫愚妇引车卖浆者流的歌吟一跃而成为六经之首，“子曰”与“诗云”并称。实际上，就是因为“孔子曰”，孔子的赞誉，《诗》中愚夫愚妇们的“云”，才成为中国古代文学的圣经。他对这三百首《诗》说过些什么呢？他和子夏讨论过“巧笑倩兮，美目盼兮”；他和子贡讨论过“如切如磋，如琢如磨”；他说：“不学《诗》，无以言”，他还说，“《诗》可以怨”！他把《诗》当作教材，传授给弟子们，正是因为这种口耳相传式的传授，才使得《诗经》能避开暴君赢政的焚书之火和莽汉项羽的复仇之火，斯文不灭。他还庄重地为《诗》回护，说：“《诗》三百，一言以蔽之，曰思无邪！”这就使后世很多对《诗经》暗怀不满的人，比如朱熹，只能做些鬼鬼祟祟的歪曲的勾当。孔子是文学的守护神呢。原来他不仅是一位庄严谨恪的人，还是一位情感丰富的人！因此，他不仅要求人类要有道德，就是对人类的情感——包括对人性的弱点，他也有那么多善意的回护与爱惜！他要人们好德，但也不反对人们好色，“国风好色而不淫”，不过分，就行了嘛。 说到这里，插入一件小事。跟孔子学语言修辞的子夏，有一个毛病，那就是吝啬。知生莫如师，孔子深知子夏这一毛病，于是就刻意为他遮掩。一次孔子出门，碰上下雨，而子夏有伞，孔子却不去借，甘冒雨淋之苦。有人问孔子为何不问子夏借伞，孔子说，子夏有这个小毛病，若向他借伞，借，他心里不痛快；不借，不是把他的缺点暴露给众人了吗？如果能掩盖住别人的缺点，我淋点雨算什么呢？ 文学是人学，文学就是人性的表现。不能对人性的优点有极崇高的敬意，对人性的弱点有极宽厚的怜悯，是不可能理解文学的。我们再举一个相反的例子，朱熹。对这个人我老实说没有一丝一毫的好感。且不说他的那一套“存天理，灭人欲”的理论是多么仇视人性，我只想举他对《诗经》中一首诗的评论来说说。《诗经·卫风》中有一首诗叫《氓》，是一位被遗弃女子的哀歌。这个女子坚持要明媒正娶地嫁给她所爱的男人（这就是“乐而不淫”），做了妻子后她辛勤贤慧，但最后还是被抛弃了，即便这样，她也依然那么理智，节制，哀而不伤，怨而不怒。老实说，我读到这首诗的最后“亦已焉哉”（唉，算了吧），是颇失望的，我私下里希望她能报复对方一下。我知道这种想法不对，既不合法也不合理，但我觉得这才合情。美狄亚就实施了惨烈的报复么。孔子也提倡“以直报怨”么。但朱熹对这个不幸女子的评论，使我觉得他很卑鄙，很没有人性。他说：“此淫妇为人所弃，自叙其事以道其悔恨之意也”（这个淫荡的女子被别人始乱终弃了，自己追叙自己的所作所为，倾吐出悔恨之意）”读到这样的议论如果不觉得朱熹卑鄙下流，就不是正派人。因为朱熹凭空污人清白（在这首诗中一点也看不出这个女子有什么淫荡的地方）；他对一位多情的恋人（婚前）一个贤淑的妻子（婚后）毫无首肯之意，理学家之不懂欣赏女人，于此可见一斑，而理学家之仇视—切鲜活的女性，对人间痛苦毫无同情心也在此原形毕露。这些只知“以理杀人”的后儒们，他们何曾及得上孔子的一分—毫啊。 由于孔子丰富的文学情怀，他把人格修养的最高境界理解为一种自由的艺术境界，而不是严谨的道德境界。在这一点上他又和后世的道德家们大相径庭。我们也一直没注意这一点。孔子在道德的熔炉里冶炼自己，而最后出炉的结果却大出我们意料：他熔炼出的不是森森剑戟，而是更加的幽默生动。你看他说的：“志于道，据于德，依于仁，游于艺”，又说“兴于诗，立于礼，成于乐”。他最后的形象是“成于乐”而“游于艺”！他一下子变得亲近了，不再壁垒森严了。你看他：“闻《韶》，三月不知肉味”，这时他能是一位皱着眉头板着面孔不苟言笑的人么？他是一位手之舞之、足之蹈之的老顽童哩！他极爱音乐，即便在围困之中，也是每日“弦歌不衰”，只要附近没死丧，他每日都大声地唱歌。司马迁的《孔子世家》中记载了孔子与音乐的一件轶事：他在师襄子那里学了一首曲子，一连弹了十数天还不换其他曲子，直到他从这首曲子里“听”出了那个肤色黝黑、身材顾长、眼神忧郁的文王的形象！“作《易》者，其有忧患乎！”文王可不就是一个满腹忧患的古之高人么？孔子的精神通过飞翔的音符而与之相通了！ 有这样的音乐修养与音乐情怀，“三百五篇孔子皆弦歌之。”这是多么宏伟壮丽的大乐章啊。我们今天已经不能再聆听孔子弦歌过的音乐了，“此曲只应天上有，人间哪得几回闻”。但那古老而简朴的文字仍留传下来，那远古时代活生生个体的欢乐与哀伤，希望与失望，怨愤与爱慕……仍然如此鲜活，是的，那远古的神经末梢仍在向我们传来敏锐而清晰的刺痛…… 《诗经》中有一百六十首都是采自民间，包括黄河流域，汉水、汝水流域。我们可以由此贴近这片辽阔土地上的风、水、丘陇与庄稼，贴近这片土地上的阳光、情感、悲欢与离合。班固与何休都提到当时有专门采诗的行人，摇着木铎顺着乡间小道去采诗。我有时痴想，没有比这更好的职业了。如果我在那时，我一定做个采诗者。不采诗还干什么呢？还有什么比这更快乐的工作呢？ ——冬日的蛰居过去了，春光融融，芳草萋萋。我立于道口，望农夫荷锄远来，而他的歌声亦悠扬而感伤…… 我在村落间徘徊，看顽童嬉闹；我亦走上田头，看麦苗油油，静观灌溉之水汩汩流淌。 多忧伤的故事啊。有一个人因想念远方的恋人而去了，从此杳无音信；一位多情的女子被人遗弃了，哭泣着回到娘家；而服役归来的人，拄杖立于田头，他的家园已成一片废墟，丘垄上葬着他的亲人…… 在还处飘来的歌声面前，我老泪纵横。 我是被《诗经》感动了。最幸福的时候就是被感动的时候。谁能说当孔子对这三百零五首诗逐一弦歌时，他不也是感怀万端呢？“四方有羡，我独居忧。民莫不逸，我独不敢休”（《十月之交》），这样的句子，如此贴切他忧患人生的情怀，如此真切地反映他奔波为天下的辛苦，他能不感慨吗？而那一位走过周朝旧都，面对废墟上的野黍而“中心摇摇”悲不自禁的诗人，不更是他的同调吗？面对伟大朝代的文化废墟，他不更是忧患满怀吗？“知我者谓我心忧，不知我者谓我何求。悠悠苍天，此何人哉？”（《黍离》），是啊，孔子，他是—位什么样的人呢？ 六 《尚书》之流传具有传奇色彩，我们今天读到的本子乃是东晋豫章内史梅赜所献的《孔传古文尚书》。这个“孔”字乃是孔安国，司马迁的老师。他也是孔子的十一代孙。而这个孔安国所传的《尚书》，乃是汉鲁共王从孔子故居的墙壁中得到的。光这—点，就可知孔子与《尚书》之关系了。 如果说《诗经》是中国历史上最早的诗歌总集，那么，作为“上古之书”的《尚书》乃是中国历史上最早的散文集。同时，如果说《诗经》是民间的（风、雅都可以算作是民间的），那么《尚书》就是朝廷的。《诗》是民间的情感，《书》是朝廷的意志。《诗》是抒情的，《书》是理智的。《诗》是散漫的，《书》是约束的。 《诗》唱个性感受，《书》倡国家价值。《诗》是艺术，《书》是道德。《诗》是大地，是天空，是大地上的野花，是天空中的飞鸟；《书》是庙宇，是碑石，是庙宇中的祖训．是碑石中的缄言。《诗》是音乐《书》是建筑，谢林说，音乐是流动的建筑，建筑是凝固的音乐。没错，《诗》是意志的流动，《书》是情感的凝固……我们民族最古老最本质的东西，都积淀在《诗》、《书》之中了。它们都与孔子有关。 《易》据说最初乃是“大墙文化”，乃是周文王为商纣所拘押，在狱中无聊，又担心自己就此玩完，“没世而名不称”，推演而成。但文王的《周易》，纯属卜筮之书，对一般读者不啻天书。“孔子晚而喜易，序《彖》，《系》，《象》，《说卦》，《文言》，谈《易》，韦编三绝”（《史记》）。他的研究成果，经口授学生，学生整理成册，始有“十翼”，翼者，辅翼，辅助理解也。应该说，孔子是把卜筮之书改造成了哲学之书，综合天地人，探究天道人道，从“究天人之际，通古今之变”而“成一家之言”。所以，就《易》在这个意义上影响中国传统文化，我们又是在这个意义上理解《易》，毋宁说，《易》乃是孔子的著作了。孔子晚年，一边穷年兀兀以研《易》，一边却又担心时不我与，叹息道：“假我数年，若是，我于《易》则彬彬矣”。天不灭斯文，孔子而后，《易》果然彬彬而盛。“易者，易也，不易也。”这截然不同却又相辅相承的训释，恰好表明了天道人道的反复，变与不变的统一。《诗经》说：“鸢飞戾天，鱼跃于渊”（《早鹿》）《易》言：“天行健，君子以自强不息”“天地之大德曰生”，这是一个生机盎然蓬勃如斯的宇宙，这也是一个满腹忧患、自强不息的人生！ 《礼》《乐》亦是孔子的教化工具。孔子对枯燥乏味的周代官制、礼仪的记录《仪礼》进行研究，指出其内涵、作用与本质。这一切都不过是“托古改制”而已。孔子说：“夫礼，先王以承天之道，以治人之情”，仍然是天道与人道。伟大的周公盛世初建，创建周礼，规范一个大帝国的行为与思想，开创了灿烂的周文化；伟大的孔子身当乱世，礼崩乐坏，他所做的，乃是在文化废墟上的考古、整理与保存。帝国的庞大躯体，已然僵仆，他已不能使之复生，他能做的乃是使帝国的精神与文化长存人间。他所唱的，乃是伟大文化的挽歌，世运不可回，人事有兴替，挽歌者，挽留之歌也！ 在《礼运》的记载中，孔子根据可考历史的发展情况，预见着未来的道路。他认为，人类社会之发展经历着三个阶段：据乱世，升平世和太平世。据乱世就是他所处的时代了，而他为后人设想的“太平世”是什么样子呢？ 天下为公，选贤与能，讲信修睦。故人不独亲其亲，不独子其子。使老有所终，壮有所用，幼有所长，鳏寡、孤独、废疾者皆有所养；男有分，女有归。 谁说孔子只是向后看呢？他也展望未来啊！只是这位衰弱的老人自知自己是等不到那黄河清的一天了！ 《乐记》也还是在谈哲学，谈政治： (音乐)清明象天，广大象地。终始象四时，周还象风雨……乐行而伦清，耳目聪明，血气和平，移风易俗，天下皆宁。 好像不能一味指责孔子把文艺都搞成道德教化，都搞成政治蓝图。你看他所处的是什么时代？一个“仁以为己任”的思想家，他不关心天下不宁，还关心什么？他不祈望天下皆宁并为之奋斗，他还祈望什么？让他回到家里，关上门，温壶春酒，泡杯苦茶，弹琴逍遥吗？ 最后就要谈到《春秋》了。这是使一个时代都因此而得名的著作。 晚年的孔子顾视日影，喟然叹息：“不行啊不行啊，君子很惧怕死后没有留下名声啊。我的道行不通了，我凭什么在后世传名呢？”他搬来鲁国历代太史记录的史料，开始著作历史。以前在做官审案时，他很谦虚地与其他陪审官商定判辞，而此时他却突然“专断”起来，“笔则笔，削则削，子夏之徒不能赞一辞”。连插嘴提建议的机会都不给！这本以“微言大义”著称的历史著作，孔子是有意把它写成政治学著作、伦理学著作的！他在这里要审判的，是整个历史！而且他所进行的不止是历史批判，更重要的倒是他的政治批判与道德批判！他希望他的这本书能成为人的道德准则，更希望它能建立一种合理有序的政治运行法则。这就是这本书使“乱臣贼子惧”的原因。 孔子在给弟子们讲授《春秋》时感慨地说：“后世知丘者以《春秋》，而罪丘者亦以《春秋》。”丘吉尔说，影响历史的最好方法就是写历史，“春秋”以后的历史，不都受着《春秋》的影响么？孔子一直在参与着历史进程啊。只是他本人没有到场罢了，对后来的历史而言，他只是一个缺席者。 七 我认为，孔子最伟大的贡献乃是他的“私学”。最初开办私学的人未必就是孔子，但把私学办成传授文化、培养人格、培养知识阶层的场所，则毫无疑问是孔子。正是在他的私学里，才出现了中国历史上第一批真正意义上的知识分子。——这些人既不是世袭贵族，也不是后来的科举士大夫，他们不是官僚机构中的成员。他们是那时代冒出来的“新人”，名称叫“士”，后来孟子宣称“大德者不官不王”，魏文侯之师田子方宣称“行不合，言不用，则去之楚越，如脱屦然。”可以见出这些人的傲慢与偏见——对诸侯的傲慢是那么显眼，对学问的偏见又是那么深固。 谁培养了这一批特行独立的知识分子？是孔子。上引的孟子与田子方都是孔门后学。所以，孔子的私学促成了文化的独立，文化由权势者股掌之间的小妾，蜕变为特行独立的汉子，“大丈夫”（孟子语）。这种文化不以取悦权势换得宠爱为目的，而以社会批判为天职。文化而以社会批判为天职，这就是文化的本质属性了。谁赋予了文化这种本质属性？是孔子。对于世俗政权而言，权力体制自身的制衡是必要的，重要的；而文化批判所产生的文化制衡尤其重要。中国后来漫长的封建社会里，之所以没能在权力体制之中产生制衡，这与封建政权把文化纳入权力体制，取消其独立性，否定其文化批判的必要性合理性有极大的关系。也就是说，当我们否定了文化批判之后，权力内部的制衡也就相应的被消解。官僚系统之内的权力制衡是为了政府及其各职权部门行为的合法有序及防止权力滥用；而文化批判所产生的制衡则是保证整个社会的行为合乎人性，合乎理性。孔子以后的百家私说，不都是在这个意义上讨论世俗政权的合理性么？ 八 孔子曾描述过自己的形象，“学而不厌，诲人不倦，不知老之将至”。在他的身边，一批勤奋好学安贫乐道的年轻人在成长着。看看这些蓬勃的春花，他真的就想不到自己已是秋天的一枚黄叶？这句话我看应该这么理解，正是因为知道自己老冉冉而将逝，才抱定“朝闻道，夕死可矣”的信念与日逐走，学而不厌。同时又把自己的心得传授给弟子们，诲人不倦他已是明白地知道，自己来日无多了！鲁迅晚年自知不久于人世，便一再告诫自己要“赶紧做”。孔子也是在与自己的生命赛跑，赶紧做呵。“天下无道久矣，而莫能宗予，”他已无力回天了，“道不行，乘桴浮于海”，他要离开我们去那道山了！ 颜渊死了，他的精神受到沉重的打击。“天丧予！天丧予！（天要灭我，天要灭我啊！）安贫而乐道的颜回死于贫困，死后连棺材也没有。孔子为之深深恸哭。“我不为他哭还为谁哭呢？”他越来越老了，世道也越来越混乱了，不久，有消息传来，仲由死在卫国了，正中了孔子以前的忧心忡忡的预言：“不得其死”，被人剁为肉酱。仲由是众弟子中唯一敢于冲撞他的学生，小他九岁，总是雄纠纠的样子。孔子知道这个有些粗野的弟子其实最为忠厚义气，他还曾设想，当他远遁人世时，让仲由跟随着他。可现在又死在他前面了。他已经多次承受着这白发人送黑发人的惨痛了。他的心境更为凄凉了。做生意的端木赐（子贡）来看他，给老师一些周济，他正拄着拐杖在门外看西山的落日，那落日如血的余辉最后一次染红大地与天空。孤独的孔子问端木赐：“赐啊，你为什么到现在才来看我呢？”接着便低吟了一首绝命歌，那简单的字句和厚重的内涵使人想到宇宙中最简单而又最本质的哲理，人间的生死竟也牵动着宇宙的毁成： 太山坏乎！ 梁柱摧乎! 哲人萎乎！ 圣人洒泪而尽了。带着他的雄心去了。如蜡烛最后一次耀眼的一跳，熄灭了。天地之间，一片黑暗。但，也就是从那一刻起，他不再仅属于一个时代，而属于千秋万代！ 痴人有多种，或因情深而痴，或因智浅而痴，孔子属于前者，而他的很多徒子徒孙，如宋明之际的理学家们，就属于后者了，新儒家们当更是等而下之。因情而痴的孔子常常沉湎在过去的怀想之中，“郁郁乎文哉!吾从周：”“逝者如斯夫!”这时，他就是一位抒情者，抒得很动情，很感人。在一个抽象的、冷酷的、沉闷的老子之后，出现一个一往情深、感怀万端的孔子，使我们再次感受到一种温软，一种熨帖，这实在是让我们大大舒了一口气，历史终于在绝望中咧口而哭出了声，一些可怕的心理能量在孔子的歌哭、幽默、感喟中被释放了。孔子使一些无序的暴力变成了有目的、有方向的努力与企望，他使天下英雄人于他的彀中，带着这些社会精英致力于建构新的理想。当混乱的历史有了理想与方向时，混乱就不再是一无是处，相反，倒往注显示出一种蓬蓬勃勃、生机无穷的魅力。 春秋战国时代是一个刀光剑影的时代，一个流血漂橹的时代，一个杀人盈城、杀人盈野的时代，但它不也是一个充满理想、充满激情，充满公理仁德的时代吗?谁开辟了这样的时代?是孔子！非常具有象征意义的是，当孔子子和弟子们周游列国的时候，他往往自己驾车一一他确实是在驾着这个时代的马车。弟子们在车上或呼呼大睡或哈欠连天．一脸凄迷与怀疑。只有他永远目光炯炯，自信目标就在前方。 有一次。在一条汤汤而流的小河边。他们又找不到渡口了。远处的水田中有两人在耕作，子路便上前去打问。其中的一个细长个子却不回答子路的询问，而是反问子路： “那个执缰绳的人是谁？” 子路恭敬地回答：“是孔丘。” “是鲁国的那个孔丘吗?”——可见孔子的知名度颇高。 子路答：“是。”这个细高个冷冷地就来了一句：“既然是鲁国的那个孔丘，他应该知道渡口在哪里嘛。” 没奈何，已经由绿林好汉改邪归正到孔子门下的子路，只能捺住火气，转过身去问另一位。这一位魁梧雄桀，是个大块头。大块头也反问子路：“你是谁?” 子路仍然是恭敬地回答：“我是仲由。” “你是孔丘的门徒吗?” “是。” 现在又轮到大块头来教训子路了：“天下混乱，举世皆然。谁能改变这种局面?我看你身体强壮，是个好庄稼汉。与其跟随孔子这样的避人之士东奔西走，鼓唇摇舌，倒不如跟随我们这些避世之士，躬耕垄亩的好!” 这里我先解释两个词。什么叫“避人”呢?避人就是择人，就是避开那些昏庸无道的诸侯，而去寻找志同道合的有为之君，一同来重整乾坤。良禽择木而栖，贤才择主而事嘛，不择主，只要给富贵就帮他卖力，那是苏秦张仪的作为。孔子一心要的是救世，而不是个人富贵，所以他栖 惶惶的马车在纵横阡陌间奔走扬尘，就是要避开身后的昏君而去寻找前面的明君。什么是“避世”?在“避人”的基础上再跨一步，彻底冷了心，闭了眼，认定天下不可能有什么诸侯还能与他一起改变这世界，于是彻底绝望，从而彻底不抱希望，回到田园中去，回到自己的内心中去，告别都市、政治与熙熙攘攘的外部世界，就叫避世。 再回头说子路被这两人教训得一楞一楞的，又要注意自己此时的身份，不能发作，只好垂头丧气地回来向孔子汇报。孔子听完。不尽的迷悯。谁说这两位隐士说得不对呢?这不也是孔子自己内心中常有的感触吗?但他历尽艰辛，学而不厌，“十年磨一剑，霜刃未曾试”，难道就此卷而怀之吗?他有教无类，诲人不倦。门徒三千，贤者七十二，就是为了培养一批隐士，或者懂文化的农夫吗?于是他感慨万端：“人总不能与乌兽一起生活在山林之中啊，我不和芸芸众生生活在一起，与他们共享欢乐共担不幸，我又能和淮生活在一起呢?他们说天下无道，但不正因为天下混乱无道，才需要我们去承担责任吗?假如天下有道，还需要我们吗?” 《论语》中的这一段，很传神，两干多年了，那条汤汤小河边发生的这场争论就好像发生在昨天似的。这几个人好像还在我们身边。我尤其为孔子感动。惜惶而寂寞，迷悯而执拗。“志于道”的人越来越少了，不少人顺应潮流，从而成了新贵，或成为新贵的红人，其中甚至有他的门徒，比如那个顶善于察言观色的弟子冉求。又有不少人冷了心，折断宝剑为锄犁，平戎策换得种树书，如长沮，桀溺；其中也有他的弟子，如樊迟。樊迟向他稼、问为圃，大概也是准备避世了吧。望望眼前。路漫漫其修远今，看看身后，追随者渐渐寥落。”道不行，乘俘浮于海，从我者，其由与!”(道行不通了，我只能乘小船漂荡到大海中去了。到那时还能跟随我的、可能只有一个仲由了吧!)这位可敬可叹的老人，想凭自己个人的德行与魅力来聚集一批年轻人，让他们传道义之火，文化之火；拯民于水火，匡世于既颠，但年轻人不容易经受得了各种诱惑，“吾未见好德如好色者’’(我从未见过一个喜爱德行比得上喜爱美色的人)“吾未见刚者”(我未见过刚强的人)“吾未见好仁者，恶不仁者”(我未见过喜好仁厌恶不仁的人)“末闻好学者’’(没听说过好学的人)。这些话不也把他的三千弟子甚至七十二贤者都包括在内了吗?要让这些弟子们“无欲而刚”“好德如好色”都不可能，更何况别人?韩非就曾刻薄尖酸地椰榆孔子，说凭着孔子那么巨大的个人德行，不就只有七十子之徒跟随他么?而下等君主鲁哀公却能让一国人都服从他，孔子本人也不得不向鲁哀公臣服。所以，人是多么容易向权势屈服，而向幕仁义的人是多么少啊。孔子此时的处境，真是令人同情。 但他更让我们尊敬。这就是他的那种“知其不可而为之”的殉道精神。“三军可夺帅也，匹夫不可夺志也”(三军可以更改主帅、匹夫却不能逼他改变志向)。匹夫尚且不能夺志，更何况圣人之志，得天地浩然正气，至大至刚，岂容站污?天下一团混黑了，不少原先追求光明的人也练就了猫头鹰的眼睛，从适应黑暗而进于喜欢黑暗，为黑暗辩护，他们把这称为提高了觉悟和认识，并且得道似的沾沾自喜于在黑森林中占据了一棵枝丫，又转过头来嘲笑别人不知变通。而孔子，这位衰弱的老人却在那里一意孤行!我很喜欢“一意孤行”这个词，很喜欢这个词所指称的那种性情与人格。敢于一意现行的人必有大精神、大人格。一位楚地的狂生曾经警告过孔子：”往者不可谏，来者犹可追。已而已而，今之从政者殆而!”(你过去糊涂就算啦，以后你可改了吧：算了吧算了吧．现在追随政治危险得很啦：)但不能因为政治危险，就置天下苍生于不顾，听任他们受暴政的煎熬，置自己的伦理责任于不顾！“政者，正也”—一政治，就是对暴政的矫正：就是正义！所以孔子庄严宣告：“志士仁人，无求生以害仁，有系身以成仁。”虽然他也说过：“危邦不入，乱邦不居，天下有道则见，无道则隐’’之类的话；虽然他也称赞遽伯玉“邦有道则仕。邦无道则可卷而怀之”，宁武子“邦有道则知，邦无道则愚”、并慨叹“其知可及也，其愚不可及也”(他的聪明别人能比得上，他的糊涂别人就比不上了)，大有郑板桥“由糊涂入聪明难，由聪明人糊涂尤难”的意味，但他对自己，却有更高的要求，那就是如史色一样，“邦有道，如矢，邦无道，如矢”，永远是如射出的箭一样、正道直行，永不回头。 自魏晋以后。中国的文化传统中，就有了一种极古怪的现象，那就是人格理想与伦理责任的分离。最受人敬仰的人格乃是那些在天下苦难面前卷而怀之，闭目养神的隐君子!他们的伦理关怀哪里去了?他们的道德痛苦哪里去了?作为知识分子，他们的基本人道精神哪里去了?难道我们不应该要求知识分子以起码的价值关怀吗?但我们却偏偏认为他们是涵养最高，道德最纯洁的人!鲁迅禁不住对这种人怒形于色：秦山崩，黄河溢，隐士目无见，耳无闻!这种目不关注人间苦难，耳不听弱者呻吟的人物，不就是饭捅酒囊茶壶甚至权势的尿壶么!现在不少人飘飘然地要“告别鲁迅”，却又腻歪歪地对“茶壶”周作人大为钟情。这种人是难以让人生出敬意的。一个人让人尊敬是有条件的。在孔子那里，在他的学说之中，那种古典的崇高确实让我们这些聪明机灵的后来人愈显扁平而单薄。 孔子的哲学核心是“仁”。在《论语》中，“仁”以不同的面目，在不同的背景下出现了无数次。这些闪烁不定的面容并不是因为孔子的“仁’’没有“一以贯之’’的主旨，而恰恰说明了“仁”内涵的丰富。樊迟问“仁”，孔子答曰“爱人”；颜回问“仁”，孔子答曰：“克己”，曾子概括说，“夫子之道，忠恕而已”。朱熹解释说，尽自己的力量去办事叫忠，推己及人叫恕。这样看来，孔子的“仁”，也就是从人我双方立论，相当于我们今天常说的“人类共存意识”吧。“仁”的内涵里，主要的两方面就是“忠”和“恕”。有了这个“忠”，就会有足够的自我约束；有了这个“恕”，就会有足够的对别人的宽容。这个顶重要了。孟子后来讲“仁”，就不大讲“恕”了，这就一步一步走向专制。孟子就没有孔子可爱。当然，孔子的“仁”，不仅仅是指一个人应当具有的人格境界，而且还应该是一个社会政治应当具有的政治理念。是公理，是正义。因而，在非常时刻应当“杀身以成仁”，而决不能“求生以害仁”。他自己一生，倡导“仁”，实践“仁”，修自身为“仁”，又要改造社会政治为“仁”。修自身成“仁”，他是做到了，改造社会政治为“仁”，他失败了。但他“颠沛必于是造次必于是”，何曾有一丝一毫的媚俗之态!他正大光明，磊磊落落，他一意孤行，坦坦荡荡。他亦知道改造社会是不可能的，但他“知其不可而为之”，关键在于做!他肯定已经意识到了他在未来的影响，所以他要用自己的行为树立一个榜样，以自己的生命之汁点亮一盏明灯，使后世一切以各种借口逃避伦理责任的行为无所遁形。——既然他已经在知其不可的情形下做了．而且做得如此艰苦，如此卓绝，如此寂寞，又如此轰轰烈烈，如此失败，又如此辉煌灿烂。因失败而辉煌，我以为这是古典悲剧的基本定律，不失败何以感人心?不辉煌何以长人志?但这失败必须是大失败，必须是必然的失败，是自由在逻辑面前的失败，是个人意志在历史规律面前的失败，而且必须是主人公已经预知的失败。他已经预先知道结局了，但高傲的心性使他无法改变自己人生的方向。在古典悲剧中，生命的投人是人格成就的最后一道工序，如干将莫邪之铸剑，最后必以自身的血肉之躯投入熔炉，用自己的血光赋予宝剑以阳刚杀气。孔子的“得其真传”的弟子曾参，有一段话：“士不可不弘毅，任重而道远。仁以为己任，不亦重乎?死而后巳，不亦远乎?”我无法不为这句话而感动，虽然我已经被那些最靠近话筒，因而最有发言权的某些人的这个“后”那个“后”，还有什么“解构”，解构得没有什么完整的心智了。曾子的这段话包含着两个推论，所以我们可以把它译成问答句：士为什么要弘大坚定?因为他们任重道远。为什么说他们任重?因为他们是把仁当作自己的人生责任的；又为什么道远?因为他们除非死掉，不然就不能卸下这副担子。这就是自讨苦吃式的崇高。我上文说，让人尊敬是有条件的，不能因为你读 了不少书，甚至读了不少洋文书，知道各种主义，就能受人尊敬。你还得有所承担。孔子及其弟子们，在那么一个时代，就已经意识到担当道义是知识分子的最高使命甚至无法摆脱的宿命了，就已经知道执行文化批判而不是文化媚俗文化献媚是知识分子的基本职责了，他们怎能不伟大，又怎能不为这伟大而颠沛，造次! 那些冷了心肠的隐士讽刺孔子，还有些愤世嫉俗的道理。而下面这位“丈人”对孔子的批评就莫名其妙了： 子路路从而后，遇丈人。以杖荷條。 于路问曰：“子见夫子乎?” 丈人曰：“四体不勤，五谷不分，孰为夫子?”植其杖而罢(耘)。 子路拱而立。 止子路宿。杀鸡为泰而食之。见其二于焉。 子路曰：“不仕无义。……欲洁其身而乱大伦!君子之仕也，行其义也。道之不行，已知之矣。” 这一段中的“四体不勤，五谷不分”，后来成为不少人批评孔子的口实。是的，在一个小农意识很浓厚的国家里，这种情形较易发生，并且较易引来阵阵喝彩。甚至人们还能这样想：你孔子子四肢不勤劳，五谷分不清，你连一个农夫都比不上。这种说法会引来更多的喝彩，因为很多人一下子从孔子的缺点中找回了自己的自信心。——但我要说，这种批评的荒谬性太明显了。在春秋后期，我们缺少一位农夫吗?减少一位卓越的思想家，增添一名普通的农夫，我们就是这样算账的吗?我们这个民族的历史与文化会因此更加辉煌灿烂吗?我们这个“文明古国”就会更加文明吗?另外，我们民族在那个时代连养活一位像孔子这样的大思想家的经济能力都没有，还必须让他自己去耕种自存吗?或者，我们这个民族连给孔子这样的大思想家提供必要的生活条件都不愿意，而必欲使之和农夫一样才心满意足吗?这些问法可以换成现代式的：我们必须分给陈景润一块自留地，由他自己播种，收获，磨粉，蒸馒头，吃下去，然后再去桌子边求证他的哥德巴赫猜想吗?如果不是这样，他即使证出了l十2，由于他不会蒸馒头，于是我们就可以鄙夷他连一个馒头师傅都不如吗?我的这种问法不是没有道理的，20多年前．我们就这么干过。否则，要办那么多的“干校”干什么? 樊迟向他问稼问为圃，孔子怒不可遏，甚至在背后骂他是“小人”。又有不少人说这是孔子轻视体力劳动，现在的某些大学教材上就有这种说法。这种批评也太师心自用了。问如何种菜种小麦，需要问孔子吗?孔子的回答是“我不如老农民，我不如老菜农”，已经说得很明白了：你樊迟要学这些，你何必到我这儿来?你去问老农即是。要学腌泡菜蒸馒头切土豆丝，需要去中科院问博士生导师吗? 以上的问题还在于，培养一个老农易，至少在孔子那时，还不提倡科学种田时是这样。那时候就没有什么农业技术学校，但遍地是老农在种麦子种大头菜。培养一个知识分子就难了。孔子的时代，传播知识，提高人口素质，似乎比自己去亲自参加劳动更迫切。所以，孔子的这些言行，与轻视体力劳动如何扯得上。这一位“植其杖而芸(耘)”的“丈人”，耘来耘去，也就那一亩二分地，所养活的，不过就是他自己及家人。这又如何能与孔子相比呢?他自己的言行能够传留后世，还是沾的孔子的光呢。孔子所耕耘的是什么荒?是文化之荒!所培养的是什么苗?是文化之苗!柳绐徵《中国文化史》云：”孔子者中国文化之中心也，无孔子则无中国文化。自孔子以前数千年之文化赖孔于而传，自孔子以后数千年之文化赖孔于而开。” 孔子所给予我们这个民族的，甚至全世界的，又如何能估量?又如何是小农思想满脑子的人所能理喻、所能批评的? 所以，上述的那些对孔子的批评，让我联想到今天一些人对鲁迅的批评，以及他们莫名其妙的对于鲁迅的优胜感。鲁迅的某些缺点确实让某些人民弱的心性得到一种自信的证明。但他们对于鲁迅的批评，恰像旧时代老爷家中感觉很幸福从而很温柔的小妾，对现代独身女性的批评；又好比是青铜时代贵族几案上的玲珑的酒器或床底下温静的溺器。对铁器时代绿林好汉手中青锋长剑的批评。 我对古代的隐士评价不高。相应的，我对现代的周作人及其鼓吹者们也心存怀疑。我认为，一个人，比如这几年“告别鲁迅”而庚集到周作人羽翼下的一些人，他在这个社会里占有了比别人好一些的地位、财富、机会，使他能上大学读书，能明理，他理应对这个社会有所回报，有所补偿。按我们现在的大学招生数和报考数，有一个上大学的，就必有一个或更多上不了大学的。这种回报与补偿就是把自己的聪明才智贡献出来，使这个社会有所进步，人们的幸福能有所增进。也就是说。他的知识应该有益于社会，而不是把这种知识当成自己的文雅的小妾。我在一篇文章里，就认为周作人是把他的学识当小妾，只让她陪自己喝茶谈玄。而如果把知识当作取媚权力的手段，就更等而下之了。另一方面，出于某种自私的目的．掩盖自己的智慧。就是对社会的背叛：隐匿自己的发现，就是对社会的犯罪——当然．这种行为在专制社会里可能是迫不得已的。 孔子晚年，倦于奔波。鲁迅曾在一篇颇似游戏的文字中推测孔子晚年有严重的胃病和胃下垂。一个医生对一个常年在坎坷的道路上颠簸的人很容易下这个判断。总之，孔子老了，病了。不能再奔波了，况且奔波又有什么收获呢?于是，在离开鲁国十四年之后，靠弟子冉求的疏通，又回到了鲁国故乡。此时孔子已是知命了，不说心如死灰。但心如止水却是必然的。鲁君无意用他。他也懒洋洋的不求用了。回到自己阔别多年的老屋。撩去门楣窗棂上的蛛网，拂去案几上的积尘，他坐下来，心境一片茫然。这时，外面的世界更混乱了。乱臣贼子们活得更神气了。但也令他更无奈了。宝剑折断．铩羽而归，他还能做些什么呢?他打开了竹简。这是一个有世界意义的举动。孔子现实政治活动的失败使中国少了一位晏婴、子产或管仲式的人物，但却使世界从此有了一个伟大文化的源头。这活力绵绵不绝的文化之源，浩浩荡荡，渐远渐无穷，使整个东方世界都浸润其中。是的，当孔子的现实政治活动失败后．他埋头于古代典籍的整理；在被自己的时代拒绝之后，他成功地通过文化符号进入了未来的世纪；在被几个诸侯国的诸侯和政客拒绝后。他的影响力却遍及全世界。名声响彻天下。 孔子本来是想通过立功来传名后世的，像他终生倾慕的周公…样。但这一点已经毫无疑问地没有可能了。“君子疾没世而名不称焉!”(君子很惧怕死后没有名声留传啊)于是他使想通过立言来不朽。我们知道，在这一点上，他成功了，而且在立言中他还立了德。”三不朽”他完成了两项。据司马迁的记载，“六经”都是经他手订的。也正因了他的手，这些积满时光尘土的古典才成为“经”．而为后世不断地钻研．又在这不断的琢磨中发出历久弥新的光芒。那本“饥者歌其食，劳者歌其事”的三百零五首“诗”。记录着那么遥远时代的真切的痛苦。更是因为他的手订．由愚夫愚妇引车卖浆者流的歌吟一跃而成为六经之百。“子曰”与“诗云”并称。实际上，就是因了“孔子曰”．孔子的赞誉。《诗》中愚夫愚妇们的“云”。才成为中国古代文学的圣经。他对这三百首《诗》通过些什么呢?他和子夏讨论过“巧笑倩兮，美目盼兮”：他和子贡讨沦过“如切如磋，如琢如磨”；他说：“不学《诗》，无以言”，他还说。“诗，可以怨”!他把《诗》当作教材。传授结弟子 们，正是因为这种口耳相传式的传授．才使得《诗经》能避开暴君赢政的焚书之火和莽汉项羽的复仇之火．斯文不灭—他还庄重地为《诗》回护。说：《诗》三百，—言以蔽之．曰思无邪！”这就使后世很多对《诗经》暗怀不满的人。比如朱熹．只能做些鬼鬼祟祟的、歪曲的勾当。孔子是文学的守护神呢。原来他不仅是—位庄严谨恪的人。还是一位情感丰富的人!因此，他不仅要求人类要有道德。就是对人类的情感——包括对人性的弱点。他也有那么多善意的回护与爱惜!他要人们好德，但也不反对人们好色，“国风好色而不淫”，不过分，就行了嘛。说到这里。插入一件小事。跟孔子学语言修辞的子夏，有—个毛病．那就是吝啬。知生莫如师。孔子深知子夏这一‘毛病．于是就刻意为他遮掩。一次孔子出门．碰上下雨，而子夏有伞。孔子却不去借，甘冒雨淋之苦。有人间孔子为何不向子夏借伞，孔子说。子夏有这个小毛病，若向他借伞。借，他心里不痛快；不借，不是把他的缺点暴露给众人了吗?如果能掩盖住别人的缺点。我淋点雨算什么呢? 文学是人学，文学就是人性的表现。不能对人性的优点有极祟高的敬意．对人性的弱点有极宽厚的怜悯．是不可能理解文学的。我们再举一个相反的例子，朱熹。对这个人我老实说没有——丝一毫的好感。且不说他的那一套“存天理，灭人欲”的理论是多么仇视人性，我只想举他对《诗经》中一首诗的评论来说说。 《诗经·卫风》中有一首诗叫《氓》，是一位被遗弃女子的哀歌。这个女子坚持要明媒正娶地嫁给她所爱的男人(这就是“乐而不淫”)，做了妻子后她辛勤贤患。但最后还是被抛弃了。即便这样，她也依然那么理智、节制，哀而不伤。怨而不怒。老实说，我读到这首诗的最后“亦已焉哉”(唉，算了吧)．是颇失望的，我私下里希望她能报复对方一下。我知道这种想法不对，既不合法也不合理。但我觉得这才合情。美狄亚就实施了惨烈的报复。孔子也提倡“以直报怨”。但朱熹对这个不幸女子的评论，使我觉得他很卑鄙。很没有人性。他说：“此淫妇为人所弃．自叙其事以道其悔恨之意也。”(这个淫荡的女子被别人始乱终弃了．自己追叙自己的所作所为．倾吐出悔恨之意)读到这样的议论如果不觉得朱烹卑鄙下流．就不是正派人。因为朱熹凭空污人清白(在这首诗中一点也看不出这个女子有什么淫荡的地方)；他对一位多情的恋人(婚前)一个贤淑的妻子(婚后)毫无首肯之意，理学家之不懂欣赏女人．于此可见一斑，而理学家之仇视一切鲜活的女性，对人间痛苦毫无同情心也在此原形毕露。这些只知”以理杀人”的后儒们，他们何曾及得上孔子的一分一毫啊。 由于孔子丰富的文学情怀。他把人格修养的最高境界理解为一种自由的艺术境界，而不是严谨的道德境界。在这一点上他又和后世的道德家们大相径庭。我们也一直没注意这一点。孔子在道德的熔炉里冶炼自己．而最后出炉的结果却大出我们意料：他熔炼出的不是森森剑朝。而是更加的幽默生动。你看他说的：“志于道．据于德，依于仁、游于艺”，又说“兴于诗，立于礼，成于乐”。他最后的形象是”成于乐”而“游于艺”：他一下子变得亲近了．不再壁垒森严了。你看他：“闻《韶》，三月不知肉味”，这时他能是一位皱着眉头板着面孔不苟言笑的人么?他是一位手之舞之，足之蹈之的老顽童哩!他极爱音乐．即便在围困之中，也是每日“弦歌不衰”。只要附近没死丧，他每日都大声地唱歌。司马迁的《孔子世家》中记载了孔子与音乐的一件软事：他在师襄子那里学了一首曲子．一连弹了十数天还不换其他曲子、直到他从这首曲子里“听”出了那个肤色黝黑、身材硕长、眼神忧郁的文王的形象!“作《易》者，其有忧患乎！”文王可不就是一个满腹忧患的古之高人吗?孔子的精神通过飞翔的音符而与之相通了! 有这样的音乐修养与音乐情怀。“三百五篇孔子皆弦歌之”。这是多么宏伟壮丽的大乐章啊。我们今天已经不能再聆听孔子弦歌过的音乐了。“此曲只应天上有．人间哪得几回闻”。但那古老而简朴的文字仍留传下来。那远古时代活生生个体的欢乐与哀伤，希望与失望，怨愤与爱慕……仍然如此鲜活。是的，那远古的神经末梢仍在向我们传来敏锐而清晰的刺痛…… 《诗经》中有一百六十首都是采自民间。包括黄河流域。汉水、汝水流域。我们可以由此贴近这片辽阔土地上的风、水、丘垄与庄稼。贴近这片土地上的阳光、情感、悲欢与离合。班固与何休都提到当时有专门采诗的行人，摇着木铎顺着乡间小道去采诗。我有时痴想，没有比这更好的职业了。如果我在那时，我一定做个采诗者。不采诗还干什么呢?还有什么比这更快乐的工作呢? 冬日的蛰居过去了，春光融融，芳香萋萋。我立于道口，望农夫荷锄远来，而他的歌声亦悠扬而感伤…… 我在村落间徘徊．看顽童嬉闹：我亦走上田头。看麦苗油油，静观灌溉之水汩汩流淌。 那么多忧伤的故事啊。有一个人因想念远方的恋人而去了，从此杳无音信；一位多情的女子被人遗弃了．哭泣着回到娘家；而服役归来的人，拄杖立于田头，他的家园已成一片废墟，丘垄上葬着他的亲人…… 在远处飘来的歌声面前，我老泪纵横。 我是被《诗经》感动了。最幸福的时候就是被感动的时候。谁能说当孔子对这三百零五首诗逐一弦歌时．他不也是感怀万端呢?“四方有羡，我独居忧。民莫不逸，我独不敢休”(《十月之交》)，这样的句子，如此贴切他忧患人生的情怀．如此真切地反映他奔波为天下的辛苦，他能不感慨吗?而那一位走过周朝旧都．面对废墟上的野黍而“中心摇摇”悲不自禁的诗人，不更是他的同调吗?面对伟大朝代的文化废墟，他不更是忧患满怀吗?“知我者谓我心忧，不知我者谓我何求。悠悠苍天，此何人哉?”(《黍离》)，是啊，孔子，他是…位什么样的人呢？","categories":[{"name":"精华转载","slug":"精华转载","permalink":"http://billma.top/categories/%E7%B2%BE%E5%8D%8E%E8%BD%AC%E8%BD%BD/"}],"tags":[]},{"title":"洛谷P5380鸭旗解法","slug":"cppluogu-p5380","date":"2021-10-05T06:58:06.000Z","updated":"2023-12-12T11:52:55.956Z","comments":true,"path":"2021/10/05/cppluogu-p5380/","permalink":"http://billma.top/2021/10/05/cppluogu-p5380/","excerpt":"","text":"第一步 初始化就按上图的格式进行初始化棋盘，注意棋盘的方向与数组下标，代码如下： 123456789101112131415161718192021void begining()&#123; //Blue //underline character mapp[1][1][0]=5,mapp[1][2][0]=4,mapp[1][3][0]=3,mapp[1][4][0]=2,mapp[1][5][0]=1; mapp[1][6][0]=2,mapp[1][7][0]=3,mapp[1][8][0]=4,mapp[1][9][0]=5; //duck mapp[3][1][0]=6,mapp[3][9][0]=6; //soldier mapp[4][1][0]=7,mapp[4][3][0]=7,mapp[4][5][0]=7,mapp[4][7][0]=7,mapp[4][9][0]=7; //Red //underline character mapp[10][1][1]=5,mapp[10][2][1]=4,mapp[10][3][1]=3,mapp[10][4][1]=2,mapp[10][5][1]=1; mapp[10][6][1]=2,mapp[10][7][1]=3,mapp[10][8][1]=4,mapp[10][9][1]=5; //duck mapp[8][1][1]=6,mapp[8][9][1]=6; //soldier mapp[7][1][1]=7,mapp[7][3][1]=7,mapp[7][5][1]=7,mapp[7][7][1]=7;mapp[7][9][1]=7; &#125; 这里我调换了红蓝双方的顺序，所以就不用翻转棋盘。 第二步 基础操作函数：①attack 移动&#x2F;攻击因为移动也是一种特殊的攻击，所以也可以把移动归入攻击一栏,通过from，to参数，考虑攻击前后的敌我关系，具体代码如下： 12345void attack(int x1,int y1,int x2,int y2,int from,int to)&#123; mapp[x2][y2][from]=mapp[x1][y1][from]; mapp[x1][y1][from]=0; if(to!=-1)mapp[x2][y2][to]=0;&#125; ②getgroup 分组对于一个坐标的棋子，我们肯定要知道它属于哪一方，自然要写一个函数来获取分组。 12345int getgroup(int x,int y)&#123; if(mapp[x][y][0])return 0; else if(mapp[x][y][1])return 1; else return -1;&#125; ③getcaptain 获取主帅位置这一函数将在最后判断将军时用到。比较好理解。 1234567891011Node getcaptain(int gr)&#123; Node t; for(int i=1;i&lt;=10;i++)&#123; for(int j=1;j&lt;=9;j++)&#123; if(mapp[i][j][gr]==1)&#123; t.x=i,t.y=j; return t; &#125; &#125; &#125;&#125; 第三步 判断每个棋子移动的合法性这是整道题的重中之重，这里将一一讲解： ①captain 将的移动这是最为简单的移动之一，只要求移动前后的坐标差即可。 123456bool captain(int x1,int y1,int x2,int y2,int from,int to)&#123; int tx=abs(x1-x2),ty=abs(y1-y2); if(tx==1&amp;&amp;ty==0)return true; else if(tx==0&amp;&amp;ty==1)return true; else return false;&#125; ②guard 士的移动这个移动与将差不多，同样求坐标差 123456bool guard(int x1,int y1,int x2,int y2,int from,int to)&#123; int tx=abs(x1-x2),ty=abs(y1-y2); if(tx==1&amp;&amp;ty==1) return true; else return false;&#125; ③elephant 象的移动这个移动就有点复杂，注意要判断是否移动受阻，可以单独开一个数组判断障碍，这个思路就有点像大家初学BFS的时候模拟移动。 1234567891011121314bool elephant(int x1,int y1,int x2,int y2,int from,int to)&#123; int aimx[4]=&#123;-2,-2,2,2&#125;,aimy[4]=&#123;-2,2,-2,2&#125;; int stx[4]=&#123;-1,-1,1,1,&#125;,sty[4]=&#123;-1,1,-1,1&#125;; for(int i=0;i&lt;4;i++)&#123; int tx=x1+aimx[i],ty=y1+aimy[i]; if(tx==x2&amp;&amp;ty==y2)&#123; int ttx=x1+stx[i],tty=y1+sty[i]; if(mapp[ttx][tty][0]==0&amp;&amp;mapp[ttx][tty][1]==0)&#123; return true; &#125; &#125; &#125; return false;&#125; ④horse 马的移动与象差不多，只要注意马的移动的x,y轴要一一对应，而障碍位置就是马的上下左右4个点。 1234567891011121314bool horse(int x1,int y1,int x2,int y2,int from,int to)&#123; int aimx[8]=&#123;-2,-2,-1,1,2,2,1,-1&#125;,aimy[8]=&#123;-1,1,2,2,1,-1,-2,-2&#125;; int stx[8]=&#123;-1,-1,0,0,1,1,0,0&#125;,sty[8]=&#123;0,0,1,1,0,0,-1,-1&#125;; for(int i=0;i&lt;8;i++)&#123; int tx=x1+aimx[i],ty=y1+aimy[i]; if(tx==x2&amp;&amp;ty==y2)&#123; int ttx=x1+stx[i],tty=y1+sty[i]; if(mapp[ttx][tty][0]==0&amp;&amp;mapp[ttx][tty][1]==0)&#123; return true; &#125; &#125; &#125; return false;&#125; ⑤car 车的移动车的移动相对简单，只要一重循环模拟即可。注意一点：要先判断两点时候同行或者同列，否则模拟是无意义的。 1234567891011121314151617bool car(int x1,int y1,int x2,int y2,int from,int to)&#123; if(x1!=x2&amp;&amp;y1!=y2)return false; if(x1==x2)&#123; for(int i=min(y1,y2)+1;i&lt;=max(y1,y2)-1;i++)&#123; if(mapp[x1][i][0]||mapp[x1][i][1]) return false; &#125; &#125; if(y1==y2)&#123; for(int i=min(x1,x2)+1;i&lt;=max(x1,x2)-1;i++)&#123; if(mapp[i][y1][0]||mapp[i][y1][1])&#123; return false; &#125; &#125; &#125; return true;&#125; ⑥duck 鸭的移动鸭这个棋子是所有棋子中最难模拟的，但仔细分析，可以发现，鸭的障碍就是马对应方向的障碍与立足点，所以开2个数组去判断鸭的两层障碍即可。 12345678910111213141516bool duck(int x1,int y1,int x2,int y2,int from,int to)&#123; int aimx[8]=&#123;-3,-3,-2,2,3,3,2,-2&#125;,aimy[8]=&#123;-2,2,3,3,2,-2,-3,-3&#125;; int stx[8]=&#123;-2,-2,-1,1,2,2,1,-1&#125;,sty[8]=&#123;-1,1,2,2,1,-1,-2,-2&#125;; int subx[8]=&#123;-1,-1,0,0,1,1,0,0&#125;,suby[8]=&#123;0,0,1,1,0,0,-1,-1&#125;; for(int i=0;i&lt;8;i++)&#123; int tx=x1+aimx[i],ty=y1+aimy[i]; if(tx==x2&amp;&amp;ty==y2)&#123; int ttx=x1+stx[i],tty=y1+sty[i]; int tttx=x1+subx[i],ttty=y1+suby[i]; if(mapp[ttx][tty][0]==0&amp;&amp;mapp[ttx][tty][1]==0&amp;&amp;mapp[tttx][ttty][0]==0&amp;&amp;mapp[tttx][ttty][1]==0)&#123; return true; &#125; &#125; &#125; return false;&#125; ⑦soldier 兵的移动仔细观察，不难发现，兵的移动就是将的移动加上士的移动。所以直接调用上面的函数即可。 12345bool soldier(int x1,int y1,int x2,int y2,int from,int to)&#123; if(captain(x1,y1,x2,y2,from,to))return true; if(guard(x1,y1,x2,y2,from,to))return true; return false;&#125; 第三步 移动操作有了之前的几个函数做铺垫，这个操作就好写很多，先判断是否符合题目中要求，比如同方，起始点无己方棋子等等，然后一一判断是哪种棋子，调用对应的函数即可。如果合法，那么就移动&#x2F;对敌方棋子攻击，调用attack函数，否则输出无解，注意一点，在移动棋子前要先输出前两个信息，即移动的棋子和被攻击的棋子，因为在移动后信息会被改变。 最后输出后两个信息，在下文会讲到。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144void move(int x1,int y1,int x2,int y2,int from,int to)&#123; //nowgame(); if(from!=roun)&#123; cout&lt;&lt;&quot;Invalid command&quot;&lt;&lt;endl; return; &#125; //check the size if(x1&lt;1||x2&lt;1||x1&gt;10||x2&gt;10||y1&lt;1||y2&lt;1||y1&gt;9||y2&gt;9)&#123; cout&lt;&lt;&quot;Invalid command&quot;&lt;&lt;endl; return; &#125; //check the gruops if(from==to)&#123; cout&lt;&lt;&quot;Invalid command&quot;&lt;&lt;endl; return; &#125; //check the from if(from==-1)&#123; cout&lt;&lt;&quot;Invalid command&quot;&lt;&lt;endl; return; &#125; //check if the game is over if(flg==1)&#123; cout&lt;&lt;&quot;Invalid command&quot;&lt;&lt;endl; return; &#125; //captain if(mapp[x1][y1][from]==1)&#123; if(captain(x1,y1,x2,y2,from,to))&#123; int ta=mapp[x1][y1][from]; int tb=mapp[x2][y2][to]; cout&lt;&lt;group[from]&lt;&lt;&#x27; &#x27;&lt;&lt;name[ta]&lt;&lt;&#x27;;&#x27;; if(to==-1)cout&lt;&lt;&quot;NA;&quot;; else cout&lt;&lt;group[to]&lt;&lt;&#x27; &#x27;&lt;&lt;name[tb]&lt;&lt;&#x27;;&#x27;; attack(x1,y1,x2,y2,from,to); print(mapp[x1][y1][from],from,mapp[x2][y2][to],to,0); &#125; else print(mapp[x1][y1][from],from,mapp[x2][y2][to],to,1); &#125; //guard if(mapp[x1][y1][from]==2)&#123; if(guard(x1,y1,x2,y2,from,to))&#123; int ta=mapp[x1][y1][from]; int tb=mapp[x2][y2][to]; cout&lt;&lt;group[from]&lt;&lt;&#x27; &#x27;&lt;&lt;name[ta]&lt;&lt;&#x27;;&#x27;; if(to==-1)cout&lt;&lt;&quot;NA;&quot;; else cout&lt;&lt;group[to]&lt;&lt;&#x27; &#x27;&lt;&lt;name[tb]&lt;&lt;&#x27;;&#x27;; attack(x1,y1,x2,y2,from,to); print(mapp[x1][y1][from],from,mapp[x2][y2][to],to,0); &#125; else print(mapp[x1][y1][from],from,mapp[x2][y2][to],to,1); &#125; //elephant if(mapp[x1][y1][from]==3)&#123; if(elephant(x1,y1,x2,y2,from,to))&#123; int ta=mapp[x1][y1][from]; int tb=mapp[x2][y2][to]; cout&lt;&lt;group[from]&lt;&lt;&#x27; &#x27;&lt;&lt;name[ta]&lt;&lt;&#x27;;&#x27;; if(to==-1)cout&lt;&lt;&quot;NA;&quot;; else cout&lt;&lt;group[to]&lt;&lt;&#x27; &#x27;&lt;&lt;name[tb]&lt;&lt;&#x27;;&#x27;; attack(x1,y1,x2,y2,from,to); print(mapp[x1][y1][from],from,mapp[x2][y2][to],to,0); &#125; else print(mapp[x1][y1][from],from,mapp[x2][y2][to],to,1); &#125; //horse if(mapp[x1][y1][from]==4)&#123; if(horse(x1,y1,x2,y2,from,to))&#123; int ta=mapp[x1][y1][from]; int tb=mapp[x2][y2][to]; cout&lt;&lt;group[from]&lt;&lt;&#x27; &#x27;&lt;&lt;name[ta]&lt;&lt;&#x27;;&#x27;; if(to==-1)cout&lt;&lt;&quot;NA;&quot;; else cout&lt;&lt;group[to]&lt;&lt;&#x27; &#x27;&lt;&lt;name[tb]&lt;&lt;&#x27;;&#x27;; attack(x1,y1,x2,y2,from,to); print(mapp[x1][y1][from],from,mapp[x2][y2][to],to,0); &#125; else print(mapp[x1][y1][from],from,mapp[x2][y2][to],to,1); &#125; //car if(mapp[x1][y1][from]==5)&#123; if(car(x1,y1,x2,y2,from,to))&#123; int ta=mapp[x1][y1][from]; int tb=mapp[x2][y2][to]; cout&lt;&lt;group[from]&lt;&lt;&#x27; &#x27;&lt;&lt;name[ta]&lt;&lt;&#x27;;&#x27;; if(to==-1)cout&lt;&lt;&quot;NA;&quot;; else cout&lt;&lt;group[to]&lt;&lt;&#x27; &#x27;&lt;&lt;name[tb]&lt;&lt;&#x27;;&#x27;; attack(x1,y1,x2,y2,from,to); print(mapp[x1][y1][from],from,mapp[x2][y2][to],to,0); &#125; else print(mapp[x1][y1][from],from,mapp[x2][y2][to],to,1); &#125; //duck if(mapp[x1][y1][from]==6)&#123; if(duck(x1,y1,x2,y2,from,to))&#123; int ta=mapp[x1][y1][from]; int tb=mapp[x2][y2][to]; cout&lt;&lt;group[from]&lt;&lt;&#x27; &#x27;&lt;&lt;name[ta]&lt;&lt;&#x27;;&#x27;; if(to==-1)cout&lt;&lt;&quot;NA;&quot;; else cout&lt;&lt;group[to]&lt;&lt;&#x27; &#x27;&lt;&lt;name[tb]&lt;&lt;&#x27;;&#x27;; attack(x1,y1,x2,y2,from,to); print(mapp[x1][y1][from],from,mapp[x2][y2][to],to,0); &#125; else print(mapp[x1][y1][from],from,mapp[x2][y2][to],to,1); &#125; //soldier if(mapp[x1][y1][from]==7)&#123; if(soldier(x1,y1,x2,y2,from,to))&#123; int ta=mapp[x1][y1][from]; int tb=mapp[x2][y2][to]; cout&lt;&lt;group[from]&lt;&lt;&#x27; &#x27;&lt;&lt;name[ta]&lt;&lt;&#x27;;&#x27;; if(to==-1)cout&lt;&lt;&quot;NA;&quot;; else cout&lt;&lt;group[to]&lt;&lt;&#x27; &#x27;&lt;&lt;name[tb]&lt;&lt;&#x27;;&#x27;; attack(x1,y1,x2,y2,from,to); print(mapp[x1][y1][from],from,mapp[x2][y2][to],to,0); &#125; else print(mapp[x1][y1][from],from,mapp[x2][y2][to],to,1); &#125; &#125; 第四步 判断将军将军这个问题看似很难解决，其实换一种思路即可，假设每个敌方棋子都可以将军，然后调用之前的函数，判断假设是否成立，如果成立，说明存在将军，否则则不存在将军。 这样一来，代码就非常好写了：遍历每个点，对于有敌方棋子的点，就做出假设，然后判断假设。并且这里要用到之前的getcaptain函数来获取两方将的位置。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455bool cankill()&#123; Node blue,red; blue=getcaptain(0),red=getcaptain(1); for(int i=1;i&lt;=10;i++)&#123; for(int j=1;j&lt;=9;j++)&#123; if(mapp[i][j][0])&#123; if(mapp[i][j][0]==1) if(captain(i,j,red.x,red.y,0,1)) return true; if(mapp[i][j][0]==2) if(guard(i,j,red.x,red.y,0,1)) return true; if(mapp[i][j][0]==3) if(elephant(i,j,red.x,red.y,0,1)) return true; if(mapp[i][j][0]==4) if(horse(i,j,red.x,red.y,0,1)) return true; if(mapp[i][j][0]==5) if(car(i,j,red.x,red.y,0,1)) return true; if(mapp[i][j][0]==6) if(duck(i,j,red.x,red.y,0,1)) return true; if(mapp[i][j][0]==7) if(soldier(i,j,red.x,red.y,0,1)) return true; &#125; if(mapp[i][j][1])&#123; if(mapp[i][j][1]==1) if(captain(i,j,blue.x,blue.y,1,0)) return true; if(mapp[i][j][1]==2) if(guard(i,j,blue.x,blue.y,1,0)) return true; if(mapp[i][j][1]==3) if(elephant(i,j,blue.x,blue.y,1,0)) return true; if(mapp[i][j][1]==4) if(horse(i,j,blue.x,blue.y,1,0)) return true; if(mapp[i][j][1]==5) if(car(i,j,blue.x,blue.y,1,0)) return true; if(mapp[i][j][1]==6) if(duck(i,j,blue.x,blue.y,1,0)) return true; if(mapp[i][j][1]==7) if(soldier(i,j,blue.x,blue.y,1,0)) return true; &#125; &#125; &#125; return false;&#125; 第五步 判断游戏是否结束这个问题非常好解决，跑一遍二重循环，统计将的个数，如果小于2，游戏一定结束，注意游戏结束后要设置一个flg，使对接下来命令的处理都是无解。 代码如下： 1234567891011121314151617bool isend()&#123; int t=0; for(int k=0;k&lt;=1;k++)&#123; for(int i=1;i&lt;=10;i++)&#123; for(int j=1;j&lt;=9;j++)&#123; if(mapp[i][j][k]==1)t++; &#125; &#125; &#125; if(t&lt;2)&#123; flg=1; return true; &#125; else return false; &#125; 第六步 输出因为在move函数中已经将前两个信息输出，所以这里只要输出后两个信息即可，直接调用上面的函数，同时在输出的时候更新当前应当走棋的阵营。 对于不合法的调用，输出无解即可。 代码如下： 12345678910111213141516171819void print(int M_C,int M_G,int K_C,int K_G,int canmove)&#123; //canmove? if(canmove==1)&#123; cout&lt;&lt;&quot;Invalid command&quot;&lt;&lt;endl; return; &#125; roun=1-roun; //End? if(isend())&#123; cout&lt;&lt;&quot;no;yes&quot;&lt;&lt;endl; &#125; else &#123; if(cankill())cout&lt;&lt;&quot;yes;&quot;; else cout&lt;&lt;&quot;no;&quot;; cout&lt;&lt;&quot;no&quot;&lt;&lt;endl; &#125;&#125; Tip：主程序中对于每条指令，调用move函数即可。 完整代码献上完整代码，10K,396行: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396#include&lt;bits/stdc++.h&gt;using namespace std;//begining wordsint Q;struct Node&#123; int x,y;&#125;;int mapp[20][20][2];string name[10]=&#123;&quot;&quot;,&quot;captain&quot;,&quot;guard&quot;,&quot;elephant&quot;,&quot;horse&quot;,&quot;car&quot;,&quot;duck&quot;,&quot;soldier&quot;&#125;;string group[3]=&#123;&quot;red&quot;,&quot;blue&quot;&#125;;bool flg=0;bool roun=0;void begining()&#123; //Blue //underline character mapp[1][1][0]=5,mapp[1][2][0]=4,mapp[1][3][0]=3,mapp[1][4][0]=2,mapp[1][5][0]=1; mapp[1][6][0]=2,mapp[1][7][0]=3,mapp[1][8][0]=4,mapp[1][9][0]=5; //duck mapp[3][1][0]=6,mapp[3][9][0]=6; //soldier mapp[4][1][0]=7,mapp[4][3][0]=7,mapp[4][5][0]=7,mapp[4][7][0]=7,mapp[4][9][0]=7; //Red //underline character mapp[10][1][1]=5,mapp[10][2][1]=4,mapp[10][3][1]=3,mapp[10][4][1]=2,mapp[10][5][1]=1; mapp[10][6][1]=2,mapp[10][7][1]=3,mapp[10][8][1]=4,mapp[10][9][1]=5; //duck mapp[8][1][1]=6,mapp[8][9][1]=6; //soldier mapp[7][1][1]=7,mapp[7][3][1]=7,mapp[7][5][1]=7,mapp[7][7][1]=7;mapp[7][9][1]=7; &#125;void attack(int x1,int y1,int x2,int y2,int from,int to)&#123; mapp[x2][y2][from]=mapp[x1][y1][from]; mapp[x1][y1][from]=0; if(to!=-1)mapp[x2][y2][to]=0;&#125;int getgroup(int x,int y)&#123; if(mapp[x][y][0])return 0; else if(mapp[x][y][1])return 1; else return -1;&#125;Node getcaptain(int gr)&#123; Node t; for(int i=1;i&lt;=10;i++)&#123; for(int j=1;j&lt;=9;j++)&#123; if(mapp[i][j][gr]==1)&#123; t.x=i,t.y=j; return t; &#125; &#125; &#125;&#125;bool captain(int x1,int y1,int x2,int y2,int from,int to)&#123; int tx=abs(x1-x2),ty=abs(y1-y2); if(tx==1&amp;&amp;ty==0)return true; else if(tx==0&amp;&amp;ty==1)return true; else return false;&#125;bool guard(int x1,int y1,int x2,int y2,int from,int to)&#123; int tx=abs(x1-x2),ty=abs(y1-y2); if(tx==1&amp;&amp;ty==1) return true; else return false;&#125;bool elephant(int x1,int y1,int x2,int y2,int from,int to)&#123; int aimx[4]=&#123;-2,-2,2,2&#125;,aimy[4]=&#123;-2,2,-2,2&#125;; int stx[4]=&#123;-1,-1,1,1,&#125;,sty[4]=&#123;-1,1,-1,1&#125;; for(int i=0;i&lt;4;i++)&#123; int tx=x1+aimx[i],ty=y1+aimy[i]; if(tx==x2&amp;&amp;ty==y2)&#123; int ttx=x1+stx[i],tty=y1+sty[i]; if(mapp[ttx][tty][0]==0&amp;&amp;mapp[ttx][tty][1]==0)&#123; return true; &#125; &#125; &#125; return false;&#125;bool horse(int x1,int y1,int x2,int y2,int from,int to)&#123; int aimx[8]=&#123;-2,-2,-1,1,2,2,1,-1&#125;,aimy[8]=&#123;-1,1,2,2,1,-1,-2,-2&#125;; int stx[8]=&#123;-1,-1,0,0,1,1,0,0&#125;,sty[8]=&#123;0,0,1,1,0,0,-1,-1&#125;; for(int i=0;i&lt;8;i++)&#123; int tx=x1+aimx[i],ty=y1+aimy[i]; if(tx==x2&amp;&amp;ty==y2)&#123; int ttx=x1+stx[i],tty=y1+sty[i]; if(mapp[ttx][tty][0]==0&amp;&amp;mapp[ttx][tty][1]==0)&#123; return true; &#125; &#125; &#125; return false;&#125;bool car(int x1,int y1,int x2,int y2,int from,int to)&#123; if(x1!=x2&amp;&amp;y1!=y2)return false; if(x1==x2)&#123; for(int i=min(y1,y2)+1;i&lt;=max(y1,y2)-1;i++)&#123; if(mapp[x1][i][0]||mapp[x1][i][1]) return false; &#125; &#125; if(y1==y2)&#123; for(int i=min(x1,x2)+1;i&lt;=max(x1,x2)-1;i++)&#123; if(mapp[i][y1][0]||mapp[i][y1][1])&#123; return false; &#125; &#125; &#125; return true;&#125;bool duck(int x1,int y1,int x2,int y2,int from,int to)&#123; int aimx[8]=&#123;-3,-3,-2,2,3,3,2,-2&#125;,aimy[8]=&#123;-2,2,3,3,2,-2,-3,-3&#125;; int stx[8]=&#123;-2,-2,-1,1,2,2,1,-1&#125;,sty[8]=&#123;-1,1,2,2,1,-1,-2,-2&#125;; int subx[8]=&#123;-1,-1,0,0,1,1,0,0&#125;,suby[8]=&#123;0,0,1,1,0,0,-1,-1&#125;; for(int i=0;i&lt;8;i++)&#123; int tx=x1+aimx[i],ty=y1+aimy[i]; if(tx==x2&amp;&amp;ty==y2)&#123; int ttx=x1+stx[i],tty=y1+sty[i]; int tttx=x1+subx[i],ttty=y1+suby[i]; if(mapp[ttx][tty][0]==0&amp;&amp;mapp[ttx][tty][1]==0&amp;&amp;mapp[tttx][ttty][0]==0&amp;&amp;mapp[tttx][ttty][1]==0)&#123; return true; &#125; &#125; &#125; return false;&#125;bool soldier(int x1,int y1,int x2,int y2,int from,int to)&#123; if(captain(x1,y1,x2,y2,from,to))return true; if(guard(x1,y1,x2,y2,from,to))return true; return false;&#125;bool cankill()&#123; Node blue,red; blue=getcaptain(0),red=getcaptain(1); for(int i=1;i&lt;=10;i++)&#123; for(int j=1;j&lt;=9;j++)&#123; if(mapp[i][j][0])&#123; if(mapp[i][j][0]==1) if(captain(i,j,red.x,red.y,0,1)) return true; if(mapp[i][j][0]==2) if(guard(i,j,red.x,red.y,0,1)) return true; if(mapp[i][j][0]==3) if(elephant(i,j,red.x,red.y,0,1)) return true; if(mapp[i][j][0]==4) if(horse(i,j,red.x,red.y,0,1)) return true; if(mapp[i][j][0]==5) if(car(i,j,red.x,red.y,0,1)) return true; if(mapp[i][j][0]==6) if(duck(i,j,red.x,red.y,0,1)) return true; if(mapp[i][j][0]==7) if(soldier(i,j,red.x,red.y,0,1)) return true; &#125; if(mapp[i][j][1])&#123; if(mapp[i][j][1]==1) if(captain(i,j,blue.x,blue.y,1,0)) return true; if(mapp[i][j][1]==2) if(guard(i,j,blue.x,blue.y,1,0)) return true; if(mapp[i][j][1]==3) if(elephant(i,j,blue.x,blue.y,1,0)) return true; if(mapp[i][j][1]==4) if(horse(i,j,blue.x,blue.y,1,0)) return true; if(mapp[i][j][1]==5) if(car(i,j,blue.x,blue.y,1,0)) return true; if(mapp[i][j][1]==6) if(duck(i,j,blue.x,blue.y,1,0)) return true; if(mapp[i][j][1]==7) if(soldier(i,j,blue.x,blue.y,1,0)) return true; &#125; &#125; &#125; return false;&#125;bool isend()&#123; int t=0; for(int k=0;k&lt;=1;k++)&#123; for(int i=1;i&lt;=10;i++)&#123; for(int j=1;j&lt;=9;j++)&#123; if(mapp[i][j][k]==1)t++; &#125; &#125; &#125; if(t&lt;2)&#123; flg=1; return true; &#125; else return false; &#125;void print(int M_C,int M_G,int K_C,int K_G,int canmove)&#123; //canmove? if(canmove==1)&#123; cout&lt;&lt;&quot;Invalid command&quot;&lt;&lt;endl; return; &#125; roun=1-roun; //End? if(isend())&#123; cout&lt;&lt;&quot;no;yes&quot;&lt;&lt;endl; &#125; else &#123; if(cankill())cout&lt;&lt;&quot;yes;&quot;; else cout&lt;&lt;&quot;no;&quot;; cout&lt;&lt;&quot;no&quot;&lt;&lt;endl; &#125;&#125;void move(int x1,int y1,int x2,int y2,int from,int to)&#123; //nowgame(); if(from!=roun)&#123; cout&lt;&lt;&quot;Invalid command&quot;&lt;&lt;endl; return; &#125; //check the size if(x1&lt;1||x2&lt;1||x1&gt;10||x2&gt;10||y1&lt;1||y2&lt;1||y1&gt;9||y2&gt;9)&#123; cout&lt;&lt;&quot;Invalid command&quot;&lt;&lt;endl; return; &#125; //check the gruops if(from==to)&#123; cout&lt;&lt;&quot;Invalid command&quot;&lt;&lt;endl; return; &#125; //check the from if(from==-1)&#123; cout&lt;&lt;&quot;Invalid command&quot;&lt;&lt;endl; return; &#125; //check if the game is over if(flg==1)&#123; cout&lt;&lt;&quot;Invalid command&quot;&lt;&lt;endl; return; &#125; //captain if(mapp[x1][y1][from]==1)&#123; if(captain(x1,y1,x2,y2,from,to))&#123; int ta=mapp[x1][y1][from]; int tb=mapp[x2][y2][to]; cout&lt;&lt;group[from]&lt;&lt;&#x27; &#x27;&lt;&lt;name[ta]&lt;&lt;&#x27;;&#x27;; if(to==-1)cout&lt;&lt;&quot;NA;&quot;; else cout&lt;&lt;group[to]&lt;&lt;&#x27; &#x27;&lt;&lt;name[tb]&lt;&lt;&#x27;;&#x27;; attack(x1,y1,x2,y2,from,to); print(mapp[x1][y1][from],from,mapp[x2][y2][to],to,0); &#125; else print(mapp[x1][y1][from],from,mapp[x2][y2][to],to,1); &#125; //guard if(mapp[x1][y1][from]==2)&#123; if(guard(x1,y1,x2,y2,from,to))&#123; int ta=mapp[x1][y1][from]; int tb=mapp[x2][y2][to]; cout&lt;&lt;group[from]&lt;&lt;&#x27; &#x27;&lt;&lt;name[ta]&lt;&lt;&#x27;;&#x27;; if(to==-1)cout&lt;&lt;&quot;NA;&quot;; else cout&lt;&lt;group[to]&lt;&lt;&#x27; &#x27;&lt;&lt;name[tb]&lt;&lt;&#x27;;&#x27;; attack(x1,y1,x2,y2,from,to); print(mapp[x1][y1][from],from,mapp[x2][y2][to],to,0); &#125; else print(mapp[x1][y1][from],from,mapp[x2][y2][to],to,1); &#125; //elephant if(mapp[x1][y1][from]==3)&#123; if(elephant(x1,y1,x2,y2,from,to))&#123; int ta=mapp[x1][y1][from]; int tb=mapp[x2][y2][to]; cout&lt;&lt;group[from]&lt;&lt;&#x27; &#x27;&lt;&lt;name[ta]&lt;&lt;&#x27;;&#x27;; if(to==-1)cout&lt;&lt;&quot;NA;&quot;; else cout&lt;&lt;group[to]&lt;&lt;&#x27; &#x27;&lt;&lt;name[tb]&lt;&lt;&#x27;;&#x27;; attack(x1,y1,x2,y2,from,to); print(mapp[x1][y1][from],from,mapp[x2][y2][to],to,0); &#125; else print(mapp[x1][y1][from],from,mapp[x2][y2][to],to,1); &#125; //horse if(mapp[x1][y1][from]==4)&#123; if(horse(x1,y1,x2,y2,from,to))&#123; int ta=mapp[x1][y1][from]; int tb=mapp[x2][y2][to]; cout&lt;&lt;group[from]&lt;&lt;&#x27; &#x27;&lt;&lt;name[ta]&lt;&lt;&#x27;;&#x27;; if(to==-1)cout&lt;&lt;&quot;NA;&quot;; else cout&lt;&lt;group[to]&lt;&lt;&#x27; &#x27;&lt;&lt;name[tb]&lt;&lt;&#x27;;&#x27;; attack(x1,y1,x2,y2,from,to); print(mapp[x1][y1][from],from,mapp[x2][y2][to],to,0); &#125; else print(mapp[x1][y1][from],from,mapp[x2][y2][to],to,1); &#125; //car if(mapp[x1][y1][from]==5)&#123; if(car(x1,y1,x2,y2,from,to))&#123; int ta=mapp[x1][y1][from]; int tb=mapp[x2][y2][to]; cout&lt;&lt;group[from]&lt;&lt;&#x27; &#x27;&lt;&lt;name[ta]&lt;&lt;&#x27;;&#x27;; if(to==-1)cout&lt;&lt;&quot;NA;&quot;; else cout&lt;&lt;group[to]&lt;&lt;&#x27; &#x27;&lt;&lt;name[tb]&lt;&lt;&#x27;;&#x27;; attack(x1,y1,x2,y2,from,to); print(mapp[x1][y1][from],from,mapp[x2][y2][to],to,0); &#125; else print(mapp[x1][y1][from],from,mapp[x2][y2][to],to,1); &#125; //duck if(mapp[x1][y1][from]==6)&#123; if(duck(x1,y1,x2,y2,from,to))&#123; int ta=mapp[x1][y1][from]; int tb=mapp[x2][y2][to]; cout&lt;&lt;group[from]&lt;&lt;&#x27; &#x27;&lt;&lt;name[ta]&lt;&lt;&#x27;;&#x27;; if(to==-1)cout&lt;&lt;&quot;NA;&quot;; else cout&lt;&lt;group[to]&lt;&lt;&#x27; &#x27;&lt;&lt;name[tb]&lt;&lt;&#x27;;&#x27;; attack(x1,y1,x2,y2,from,to); print(mapp[x1][y1][from],from,mapp[x2][y2][to],to,0); &#125; else print(mapp[x1][y1][from],from,mapp[x2][y2][to],to,1); &#125; //soldier if(mapp[x1][y1][from]==7)&#123; if(soldier(x1,y1,x2,y2,from,to))&#123; int ta=mapp[x1][y1][from]; int tb=mapp[x2][y2][to]; cout&lt;&lt;group[from]&lt;&lt;&#x27; &#x27;&lt;&lt;name[ta]&lt;&lt;&#x27;;&#x27;; if(to==-1)cout&lt;&lt;&quot;NA;&quot;; else cout&lt;&lt;group[to]&lt;&lt;&#x27; &#x27;&lt;&lt;name[tb]&lt;&lt;&#x27;;&#x27;; attack(x1,y1,x2,y2,from,to); print(mapp[x1][y1][from],from,mapp[x2][y2][to],to,0); &#125; else print(mapp[x1][y1][from],from,mapp[x2][y2][to],to,1); &#125; &#125;int main()&#123; begining(); cin&gt;&gt;Q; for(int i=1;i&lt;=Q;i++)&#123; int x1,y1,x2,y2; cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2; x1++,y1++,x2++,y2++; move(x1,y1,x2,y2,getgroup(x1,y1),getgroup(x2,y2)); &#125; return 0;&#125;","categories":[{"name":"竞赛解法","slug":"竞赛解法","permalink":"http://billma.top/categories/%E7%AB%9E%E8%B5%9B%E8%A7%A3%E6%B3%95/"}],"tags":[]},{"title":"2021南航苏州附中第45届校运会","slug":"21sportsmeet","date":"2021-10-01T10:51:06.000Z","updated":"2023-12-12T11:52:55.954Z","comments":true,"path":"2021/10/01/21sportsmeet/","permalink":"http://billma.top/2021/10/01/21sportsmeet/","excerpt":"","text":"原地址：ClickHere","categories":[{"name":"南航苏州附中校园活动","slug":"南航苏州附中校园活动","permalink":"http://billma.top/categories/%E5%8D%97%E8%88%AA%E8%8B%8F%E5%B7%9E%E9%99%84%E4%B8%AD%E6%A0%A1%E5%9B%AD%E6%B4%BB%E5%8A%A8/"}],"tags":[]},{"title":"南航苏州附中建党百年朗诵活动","slug":"2109poemsay","date":"2021-09-12T10:51:37.000Z","updated":"2023-12-12T11:52:55.954Z","comments":true,"path":"2021/09/12/2109poemsay/","permalink":"http://billma.top/2021/09/12/2109poemsay/","excerpt":"","text":"1.十人集体诗歌朗诵感谢以下参与人员参与录制： 汤骏懿 姚远 顾天欣 崔可欣 曹艺舟 祝中翔 杨海佳 沈思遥 王韬越 张翌晨 导演：马泊宁 姚远 拍摄+后期剪辑：马泊宁 陈星宇 特别感谢后勤小组：何昊 金弈 蒯翔 顾俊贤 陈星宇 视频播放 三连地址点击这里给作者给予支持：点击这里 2.陈星宇讲故事主讲：陈星宇 导演：马泊宁 拍摄+后期剪辑：马泊宁 陈星宇 特别感谢后勤小组： 张祉珺 视频播放 三连地址点击这里给作者给予支持：点击这里 3.张祉珺讲故事主讲：张祉珺 导演：马泊宁 拍摄+后期剪辑：马泊宁 陈星宇 特别感谢后勤小组： 陈星宇 视频播放 三连地址点击这里给作者给予支持：点击这里 4.幕后花絮 点击这里给作者给予支持：点击这里 感谢观看！","categories":[{"name":"南航苏州附中校园活动","slug":"南航苏州附中校园活动","permalink":"http://billma.top/categories/%E5%8D%97%E8%88%AA%E8%8B%8F%E5%B7%9E%E9%99%84%E4%B8%AD%E6%A0%A1%E5%9B%AD%E6%B4%BB%E5%8A%A8/"}],"tags":[]},{"title":"python之matplotlib详细教程","slug":"python-matplotlib","date":"2021-08-26T11:44:55.000Z","updated":"2023-12-12T11:52:55.960Z","comments":true,"path":"2021/08/26/python-matplotlib/","permalink":"http://billma.top/2021/08/26/python-matplotlib/","excerpt":"","text":"安装前提：你已经安装了python并且在安装时勾选了Add Python to PATH 打开cmd，输入如下指令：（不要复制粘贴） 12pip install matplotlibpip install numpy 安装完后打开python，就可以开始了！ 头文件12import matplotlib.pyplot as pltimport numpy as np 1请求一个新的figure对象1plt.figure() 1.2Axes在拥有Figure对象之后，在作画前我们还需要轴，没有轴的话就没有绘图基准，所以需要添加Axes。也可以理解成为真正可以作画的纸。 12345fig = plt.figure()ax = fig.add_subplot(111)ax.set(xlim=[0.5, 4.5], ylim=[-2, 8], title=&#x27;An Example Axes&#x27;, ylabel=&#x27;Y-Axis&#x27;, xlabel=&#x27;X-Axis&#x27;)plt.show() 上的代码，在一幅图上添加了一个Axes，然后设置了这个Axes的X轴以及Y轴的取值范围（这些设置并不是强制的，后面会再谈到关于这些设置） 对于上面的fig.add_subplot(111)就是添加Axes的，参数的解释的在画板的第1行第1列的第一个位置生成一个Axes对象来准备作画。也可以通过fig.add_subplot(2, 2, 1)的方式生成Axes，前面两个参数确定了面板的划分，例如 2， 2会将整个面板划分成 2 * 2 的方格，第三个参数取值范围是 [1, 2*2] 表示第几个Axes。如下面的例子： 1234fig = plt.figure()ax1 = fig.add_subplot(221)ax2 = fig.add_subplot(222)ax3 = fig.add_subplot(224) 1.3 Multiple Axes可以发现我们上面添加 Axes 似乎有点弱鸡，所以提供了下面的方式一次性生成所有 Axes： 12345fig, axes = plt.subplots(nrows=2, ncols=2)axes[0,0].set(title=&#x27;Upper Left&#x27;)axes[0,1].set(title=&#x27;Upper Right&#x27;)axes[1,0].set(title=&#x27;Lower Left&#x27;)axes[1,1].set(title=&#x27;Lower Right&#x27;) fig 还是我们熟悉的画板， axes 成了我们常用二维数组的形式访问，这在循环绘图时，额外好用。 1.4 Axes Vs .pyplot相信不少人看过下面的代码，很简单并易懂，但是下面的作画方式只适合简单的绘图，快速的将图绘出。在处理复杂的绘图工作时，我们还是需要使用 Axes 来完成作画的。 123plt.plot([1, 2, 3, 4], [10, 20, 25, 30], color=&#x27;lightblue&#x27;, linewidth=3)plt.xlim(0.5, 4.5)plt.show() 2. 基本绘图2D2.1 线plot()函数画出一系列的点，并且用线将它们连接起来。看下例子： 1234567x = np.linspace(0, np.pi)y_sin = np.sin(x)y_cos = np.cos(x)ax1.plot(x, y_sin)ax2.plot(x, y_sin, &#x27;go--&#x27;, linewidth=2, markersize=12)ax3.plot(x, y_cos, color=&#x27;red&#x27;, marker=&#x27;+&#x27;, linestyle=&#x27;dashed&#x27;) 在上面的三个Axes上作画。plot，前面两个参数为x轴、y轴数据。ax2的第三个参数是 MATLAB风格的绘图，对应ax3上的颜色，marker，线型。 另外，我们可以通过关键字参数的方式绘图，如下例： 123456789101112131415x = np.linspace(0, 10, 200)data_obj = &#123;&#x27;x&#x27;: x, &#x27;y1&#x27;: 2 * x + 1, &#x27;y2&#x27;: 3 * x + 1.2, &#x27;mean&#x27;: 0.5 * x * np.cos(2*x) + 2.5 * x + 1.1&#125;fig, ax = plt.subplots()#填充两条线之间的颜色ax.fill_between(&#x27;x&#x27;, &#x27;y1&#x27;, &#x27;y2&#x27;, color=&#x27;yellow&#x27;, data=data_obj)# Plot the &quot;centerline&quot; with `plot`ax.plot(&#x27;x&#x27;, &#x27;mean&#x27;, color=&#x27;black&#x27;, data=data_obj)plt.show() 发现上面的作图，在数据部分只传入了字符串，这些字符串对一个这 data_obj 中的关键字，当以这种方式作画时，将会在传入给 data 中寻找对应关键字的数据来绘图。 2.2 散点图只画点，但是不用线连接起来。 1234x = np.arange(10)y = np.random.randn(10)plt.scatter(x, y, color=&#x27;red&#x27;, marker=&#x27;+&#x27;)plt.show() 2.3 条形图条形图分两种，一种是水平的，一种是垂直的，见下例子： 123456789101112np.random.seed(1)x = np.arange(5)y = np.random.randn(5)fig, axes = plt.subplots(ncols=2, figsize=plt.figaspect(1./2))vert_bars = axes[0].bar(x, y, color=&#x27;lightblue&#x27;, align=&#x27;center&#x27;)horiz_bars = axes[1].barh(x, y, color=&#x27;lightblue&#x27;, align=&#x27;center&#x27;)#在水平或者垂直方向上画线axes[0].axhline(0, color=&#x27;gray&#x27;, linewidth=2)axes[1].axvline(0, color=&#x27;gray&#x27;, linewidth=2)plt.show() 条形图还返回了一个Artists 数组，对应着每个条形，例如上图 Artists 数组的大小为5，我们可以通过这些 Artists 对条形图的样式进行更改，如下例： 123456789fig, ax = plt.subplots()vert_bars = ax.bar(x, y, color=&#x27;lightblue&#x27;, align=&#x27;center&#x27;)# We could have also done this with two separate calls to `ax.bar` and numpy boolean indexing.for bar, height in zip(vert_bars, y): if height &lt; 0: bar.set(edgecolor=&#x27;darkred&#x27;, color=&#x27;salmon&#x27;, linewidth=3)plt.show() 2.4 直方图直方图用于统计数据出现的次数或者频率，有多种参数可以调整，见下例： 1234567891011121314151617181920212223np.random.seed(19680801)n_bins = 10x = np.random.randn(1000, 3)fig, axes = plt.subplots(nrows=2, ncols=2)ax0, ax1, ax2, ax3 = axes.flatten()colors = [&#x27;red&#x27;, &#x27;tan&#x27;, &#x27;lime&#x27;]ax0.hist(x, n_bins, density=True, histtype=&#x27;bar&#x27;, color=colors, label=colors)ax0.legend(prop=&#123;&#x27;size&#x27;: 10&#125;)ax0.set_title(&#x27;bars with legend&#x27;)ax1.hist(x, n_bins, density=True, histtype=&#x27;barstacked&#x27;)ax1.set_title(&#x27;stacked bar&#x27;)ax2.hist(x, histtype=&#x27;barstacked&#x27;, rwidth=0.9)ax3.hist(x[:, 0], rwidth=0.9)ax3.set_title(&#x27;different sample sizes&#x27;)fig.tight_layout()plt.show() 参数中density控制Y轴是概率还是数量，与返回的第一个的变量对应。histtype控制着直方图的样式，默认是 ‘bar’，对于多个条形时就相邻的方式呈现如子图1， ‘barstacked’ 就是叠在一起，如子图2、3。 rwidth 控制着宽度，这样可以空出一些间隙，比较图2、3. 图4是只有一条数据时。 2.5 饼图12345678910111213labels = &#x27;Frogs&#x27;, &#x27;Hogs&#x27;, &#x27;Dogs&#x27;, &#x27;Logs&#x27;sizes = [15, 30, 45, 10]explode = (0, 0.1, 0, 0) # only &quot;explode&quot; the 2nd slice (i.e. &#x27;Hogs&#x27;)fig1, (ax1, ax2) = plt.subplots(2)ax1.pie(sizes, labels=labels, autopct=&#x27;%1.1f%%&#x27;, shadow=True)ax1.axis(&#x27;equal&#x27;)ax2.pie(sizes, autopct=&#x27;%1.2f%%&#x27;, shadow=True, startangle=90, explode=explode, pctdistance=1.12)ax2.axis(&#x27;equal&#x27;)ax2.legend(labels=labels, loc=&#x27;upper right&#x27;)plt.show() 饼图自动根据数据的百分比画饼.。labels是各个块的标签，如子图一。autopct&#x3D;%1.1f%%表示格式化百分比精确输出，explode，突出某些块，不同的值突出的效果不一样。pctdistance&#x3D;1.12百分比距离圆心的距离，默认是0.6. 2.6 箱形图为了专注于如何画图，省去数据的处理部分。 data 的 shape 为 (n, )， data2 的 shape 为 (n, 3)。 123fig, (ax1, ax2) = plt.subplots(2)ax1.boxplot(data)ax2.boxplot(data2, vert=False) #控制方向 2.7 泡泡图散点图的一种，加入了第三个值 s 可以理解成普通散点，画的是二维，泡泡图体现了Z的大小，如下例： 1234567891011np.random.seed(19680801)N = 50x = np.random.rand(N)y = np.random.rand(N)colors = np.random.rand(N)area = (30 * np.random.rand(N))**2 # 0 to 15 point radiiplt.scatter(x, y, s=area, c=colors, alpha=0.5)plt.show() 2.8 等高线（轮廓图）有时候需要描绘边界的时候，就会用到轮廓图，机器学习用的决策边界也常用轮廓图来绘画，见下例： 1234567fig, (ax1, ax2) = plt.subplots(2)x = np.arange(-5, 5, 0.1)y = np.arange(-5, 5, 0.1)xx, yy = np.meshgrid(x, y, sparse=True)z = np.sin(xx**2 + yy**2) / (xx**2 + yy**2)ax1.contourf(x, y, z)ax2.contour(x, y, z) 上面画了两个一样的轮廓图，contourf会填充轮廓线之间的颜色。数据x, y, z通常是具有相同 shape 的二维矩阵。x, y 可以为一维向量，但是必需有 z.shape &#x3D; (y.n, x.n) ，这里 y.n 和 x.n 分别表示x、y的长度。Z通常表示的是距离X-Y平面的距离，传入X、Y则是控制了绘制等高线的范围。 3 布局、图例说明、边界等3.1区间上下限当绘画完成后，会发现X、Y轴的区间是会自动调整的，并不是跟我们传入的X、Y轴数据中的最值相同。为了调整区间我们使用下面的方式： 12345ax.set_xlim([xmin, xmax]) #设置X轴的区间ax.set_ylim([ymin, ymax]) #Y轴区间ax.axis([xmin, xmax, ymin, ymax]) #X、Y轴区间ax.set_ylim(bottom=-10) #Y轴下限ax.set_xlim(right=25) #X轴上限 12345678x = np.linspace(0, 2*np.pi)y = np.sin(x)fig, (ax1, ax2) = plt.subplots(2)ax1.plot(x, y)ax2.plot(x, y)ax2.set_xlim([-1, 6])ax2.set_ylim([-1, 3])plt.show() 可以看出修改了区间之后影响了图片显示的效果。 3.2 图例说明我们如果我们在一个Axes上做多次绘画，那么可能出现分不清哪条线或点所代表的意思。这个时间添加图例说明，就可以解决这个问题了，见下例： 1234567fig, ax = plt.subplots()ax.plot([1, 2, 3, 4], [10, 20, 25, 30], label=&#x27;Philadelphia&#x27;)ax.plot([1, 2, 3, 4], [30, 23, 13, 4], label=&#x27;Boston&#x27;)ax.scatter([1, 2, 3, 4], [20, 10, 30, 15], label=&#x27;Point&#x27;)ax.set(ylabel=&#x27;Temperature (deg C)&#x27;, xlabel=&#x27;Time&#x27;, title=&#x27;A tale of two cities&#x27;)ax.legend()plt.show() 在绘图时传入 label 参数，并最后调用ax.legend()显示体力说明，对于 legend 还是传入参数，控制图例说明显示的位置： 123456789101112Location String Location Code‘best’ 0‘upper right’ 1‘upper left’ 2‘lower left’ 3‘lower right’ 4‘right’ 5‘center left’ 6‘center right’ 7‘lower center’ 8‘upper center’ 9‘center’ 10 3.3 区间分段默认情况下，绘图结束之后，Axes 会自动的控制区间的分段。见下例： 123456789101112data = [(&#x27;apples&#x27;, 2), (&#x27;oranges&#x27;, 3), (&#x27;peaches&#x27;, 1)]fruit, value = zip(*data)fig, (ax1, ax2) = plt.subplots(2)x = np.arange(len(fruit))ax1.bar(x, value, align=&#x27;center&#x27;, color=&#x27;gray&#x27;)ax2.bar(x, value, align=&#x27;center&#x27;, color=&#x27;gray&#x27;)ax2.set(xticks=x, xticklabels=fruit)#ax.tick_params(axis=&#x27;y&#x27;, direction=&#x27;inout&#x27;, length=10) #修改 ticks 的方向以及长度plt.show() 上面不仅修改了X轴的区间段，并且修改了显示的信息为文本。 3.4 布局当我们绘画多个子图时，就会有一些美观的问题存在，例如子图之间的间隔，子图与画板的外边间距以及子图的内边距，下面说明这个问题： 1234567fig, axes = plt.subplots(2, 2, figsize=(9, 9))fig.subplots_adjust(wspace=0.5, hspace=0.3, left=0.125, right=0.9, top=0.9, bottom=0.1)#fig.tight_layout() #自动调整布局，使标题之间不重叠plt.show() 通过fig.subplots_adjust()我们修改了子图水平之间的间隔wspace&#x3D;0.5，垂直方向上的间距hspace&#x3D;0.3，左边距left&#x3D;0.125 等等，这里数值都是百分比的。以 [0, 1] 为区间，选择left、right、bottom、top 注意 top 和 right 是 0.9 表示上、右边距为百分之10。不确定如果调整的时候，fig.tight_layout()是一个很好的选择。之前说到了内边距，内边距是子图的，也就是 Axes 对象，所以这样使用 ax.margins(x&#x3D;0.1, y&#x3D;0.1)，当值传入一个值时，表示同时修改水平和垂直方向的内边距。 调整使他们使用一样的X、Y轴： 1234fig, (ax1, ax2) = plt.subplots(1, 2, sharex=True, sharey=True)ax1.plot([1, 2, 3, 4], [1, 2, 3, 4])ax2.plot([3, 4, 5, 6], [6, 5, 4, 3])plt.show() 3.5 轴相关改变边界的位置，去掉四周的边框： 1234567891011121314151617181920212223fig, ax = plt.subplots()ax.plot([-2, 2, 3, 4], [-10, 20, 25, 5])ax.spines[&#x27;top&#x27;].set_visible(False) #顶边界不可见ax.xaxis.set_ticks_position(&#x27;bottom&#x27;) # ticks 的位置为下方，分上下的。ax.spines[&#x27;right&#x27;].set_visible(False) #右边界不可见ax.yaxis.set_ticks_position(&#x27;left&#x27;) # &quot;outward&quot;# 移动左、下边界离 Axes 10 个距离#ax.spines[&#x27;bottom&#x27;].set_position((&#x27;outward&#x27;, 10))#ax.spines[&#x27;left&#x27;].set_position((&#x27;outward&#x27;, 10))# &quot;data&quot;# 移动左、下边界到 (0, 0) 处相交ax.spines[&#x27;bottom&#x27;].set_position((&#x27;data&#x27;, 0))ax.spines[&#x27;left&#x27;].set_position((&#x27;data&#x27;, 0))# &quot;axes&quot;# 移动边界，按 Axes 的百分比位置#ax.spines[&#x27;bottom&#x27;].set_position((&#x27;axes&#x27;, 0.75))#ax.spines[&#x27;left&#x27;].set_position((&#x27;axes&#x27;, 0.3))plt.show()","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://billma.top/tags/python/"}]},{"title":"最长公共子串问题的后缀数组","slug":"lcs-suffix-array","date":"2021-08-26T07:57:30.000Z","updated":"2023-12-12T11:52:55.958Z","comments":true,"path":"2021/08/26/lcs-suffix-array/","permalink":"http://billma.top/2021/08/26/lcs-suffix-array/","excerpt":"","text":"最长公共子串最长公共子串(Longest Common Substring ,简称LCS)问题，是指求给定的一组字符串长度最大的共有的子串的问题。例如字符串”abcb”,“bca”,“acbc”的LCS就是”bc”。 求多串的LCS，显然穷举法是极端低效的算法。改进一些的算法是用一个串的每个后缀对其他所有串进行部分匹配，用KMP算法，时间复杂度为O(NL^2)，其中N为字符串个数，L为每个串的长度。更优秀的有广义后缀树的方法，时间可以达到 O(NL)。本文介绍一种基于后缀数组的LCS解法，利用二分查找技术，时间复杂度可以达到O(NLlogL)。 最长公共子串问题的后缀数组解法关于后缀数组的构建方法以及Height数组的性质，本文不再具体介绍，可以参阅IOI国家集训队2004年论文《后缀数组》(许智磊)和IOI国家集训队2009年论文《后缀数组——处理字符串的有力工具》(罗穗骞)。 回顾一下后缀数组，SA[i]表示排名第i的后缀的位置，Height[i]表示后缀SA[i]和SA[i-1]的最长公共前缀(Longest Common Prefix,LCP)，简记为Height[i]&#x3D;LCP(SA[i],SA[i-1])。连续的一段后缀SA[i..j]的最长公共前缀，就是H[i-1..j]的最小值，即LCP(SA[i..j])&#x3D;Min(H[i-1..j])。 求N个串的最长公共子串，可以转化为求一些后缀的最长公共前缀的最大值，这些后缀应分属于N个串。具体方法如下： 设N个串分别为S1,S2,S3,…,SN，首先建立一个串S，把这N个串用不同的分隔符连接起来。S&#x3D;S1[P1]S2[P2]S3…SN-1[PN-1]SN，P1,P2,…PN-1应为不同的N-1个不在字符集中的字符，作为分隔符(后面会解释为什么)。 接下来，求出字符串S的后缀数组和Height数组，可以用倍增算法，或DC3算法。 然后二分枚举答案A，假设N个串可以有长度为A的公共字串，并对A的可行性进行验证。如果验证A可行，A’(A’&lt; A)也一定可行，尝试增大A，反之尝试缩小A。最终可以取得A的最大可行值，就是这N个串的最长公共子串的长度。可以证明，尝试次数是O(logL)的。 于是问题就集中到了，如何验证给定的长度A是否为可行解。方法是，找出在Height数组中找出连续的一段Height[i..j]，使得i&lt;&#x3D;k&lt;&#x3D;j均满足Height[k]&gt;&#x3D;A，并且i-1&lt;&#x3D;k&lt;&#x3D;j中，SA[k]分属于原有N个串S1..SN。如果能找到这样的一段，那么A就是可行解，否则A不是可行解。 具体查找i..j时，可以先从前到后枚举i的位置，如果发现Height[i]&gt;&#x3D;A，则开始从i向后枚举j的位置，直到找到了Height[j+1] &lt; A，判断[i..j]这个区间内SA是否分属于S1..SN。如果满足，则A为可行解，然后直接返回，否则令i&#x3D;j+1继续向后枚举。S中每个字符被访问了O(1)次，S的长度为NL+N-1，所以验证的时间复杂度为O(NL)。 到这里，我们就可以理解为什么分隔符P1..PN-1必须是不同的N-1个不在字符集中的字符了，因为这样才能保证S的后缀的公共前缀不会跨出一个原有串的范围。 后缀数组是一种处理字符串的强大的数据结构，配合LCP函数与Height数组的性质，后缀数组更是如虎添翼。利用后缀数组，容易地求出了多个串的LCS，而且时空复杂度也相当优秀了。虽然比起后缀树的解法有所不如，但其简明的思路和容易编程的特点却在实际的应用中并不输于后缀树。","categories":[{"name":"编程算法","slug":"编程算法","permalink":"http://billma.top/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"C语言中跨文件的全局变量","slug":"c-global-variables-in-multiple-files","date":"2021-08-19T08:07:04.000Z","updated":"2023-12-12T11:52:55.954Z","comments":true,"path":"2021/08/19/c-global-variables-in-multiple-files/","permalink":"http://billma.top/2021/08/19/c-global-variables-in-multiple-files/","excerpt":"","text":"首先看一段代码 func.c 123456int buf = 0;void func() &#123; buf = 2; /*Do something else*/&#125; main.c 1234567891011# include &lt;stdio.h&gt;int buf;void func();int main() &#123; buf = 1; func(); printf(&quot;%d\\n&quot;, buf); return 0;&#125; 编译两个文件，输出的结果是怎样的呢？一眼看上去，可能会输出1，因为两个全局变量buf在不同文件中，又没有extern声明，显然是两个嘛。然而实际上它的运行结果却是2，这说明了这两个文件中引用到的其实是一个变量！ 这是为什么呢？原因是在编译时，C语言编译器将全局符号标记为strong和weak两类： 函数和初始化的全局符号被标记为strong未初始化的全局符号被标记为weak连接时，连接器对多重定义的全局符号的解析原则如下： 同一个符号不允许有多个strong定义；假如一个符号有一个strong定义和多个weak定义，那么采用该符号的strong定义；假如一个符号有多个weak定义，那么选取任意一个weak定义由于两个变量一个初始化了，一个没有初始化，所以一个是strong，一个是weak，所以连接器在符号解析时会把他们当成一个。 如果我们把main.c中的buf也初始化了： 1234567891011# include &lt;stdio.h&gt;int buf = 0;void func();int main() &#123; buf = 1; func(); printf(&quot;%d\\n&quot;, buf); return 0;&#125; 再次编译就会发现 12345duplicate symbol _buf in: /var/folders/44/_cc501qx1jd1p5bfrjbk6b100000gn/T//ccZ87C6g.o /var/folders/44/_cc501qx1jd1p5bfrjbk6b100000gn/T//ccZlES8n.old: 1 duplicate symbol for architecture x86_64collect2: ld returned 1 exit status 这是因为两个全局变量都是strong的。","categories":[{"name":"编程算法","slug":"编程算法","permalink":"http://billma.top/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"computer,cpp","slug":"computer-cpp","permalink":"http://billma.top/tags/computer-cpp/"}]},{"title":"remote  ：Support for password authentication was removed on August 13, 2021.","slug":"github-tokenerror","date":"2021-08-15T07:39:00.000Z","updated":"2023-12-12T12:24:03.142Z","comments":true,"path":"2021/08/15/github-tokenerror/","permalink":"http://billma.top/2021/08/15/github-tokenerror/","excerpt":"","text":"1.问题背景-background如果你在七夕（没错就是2021年8月14日）的这一天去访问了全球最大的同性交友网站，又刚好去更新提交代码，或者你创建了一个新的仓库送给自己，又刚好想把这个仓库送给github，你就刚好会遇到这个问题：remote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead.大概意思就是你原先的密码凭证从2021年8月13日开始就不能用了，必须使用个人访问令牌（personal access token），就是把你的密码替换成token！ Github 官方解释 We described our motivation as we announced similar changes to authenticating with the API as follows: In recent years, GitHub customers have benefited from a number of security enhancements to GitHub.com, such as two-factor authentication, sign-in alerts, verified devices, preventing the use of compromised passwords, and WebAuthn support. These features make it more difficult for an attacker to take a password that’s been reused across multiple websites and use it to try to gain access to your GitHub account. Despite these improvements, for historical reasons customers without two-factor authentication enabled have been able to continue to authenticate Git and API operations using only their GitHub username and password. Beginning August 13, 2021, we will no longer accept account passwords when authenticating Git operations and will require the use of token-based authentication, such as a personal access token (for developers) or an OAuth or GitHub App installation token (for integrators) for all authenticated Git operations on GitHub.com. You may also continue using SSH keys where you prefer. Tokens offer a number of security benefits over password-based authentication: 1.Unique – tokens are specific to GitHub and can be generated per use or per device 2.Revocable – tokens can can be individually revoked at any time without needing to update unaffected credentials 3.Limited – tokens can be narrowly scoped to allow only the access necessary for the use case 4.Random – tokens are not subject to the types of dictionary or brute force attempts that simpler passwords that you need to remember or enter regularly might be 大概意思就是：为了保证各位程序员的账户安全，我们已于2021年7月14日禁止大家在git及第三方应用上通过密码授权GitHub。以后将使用token令牌代替密码。（话说能活跃在全球最大同性交友网站的程序猿能有什么秘密值得如此加密。。。） 2.什么是token令牌？token令牌相当于在第三方接口代替你密码的一个玩意，有点像强密码。但是，token令牌并不是只能有唯一一个的。你可以拥有多个令牌，给不同的第三方接口不同的令牌，而每个令牌都被赋予了不同的权限和使用期限。也就是说，在令牌没赋予的权利将不会给第三方接口和git。当然，token令牌在你设定的期限之后，对应的第三方接口和git就需要你重新给一个令牌，否则也无法使用。令牌也可以随时更改权限和删除。 3.如何申请token令牌？登陆你的GitHub（注意，在github.com登录你的账户时还是用你的密码，不是令牌) 点击头像。随后点击settings。 往下拉，你会在左侧看到一个Developer settings。点击它。 左侧有Personal access tokens。点击它。 点击右侧generate new token。 Note是你令牌的名称（不是令牌密码），随便填一个。 expiration是令牌有效期限。No expiration代表永久令牌。 下面是选择相应的权限。一般就选择repo 和delete_repo，其他按需勾选。 拉到最下面，点击generate token，随后跳出来一个界面，有一串绿底字符串即为你的token令牌。 警告！！在这里你一定要将其复制并保存好！建议新建一个txt文件将令牌放入其中！因为这个令牌只会出现一次，你关闭了这个网页，以后GitHub就再也不会告诉你这个令牌了！妥善保管！（妥善保管！两情若是久长时，又岂在朝朝暮暮？） 返回刚才的界面，你可以查看已经创建的token和给予的权限与有效期。你可以随时更改，管理，删除它们（但是不会显示该令牌）。 随后回到你的git或第三方接口，账号还是输入你的username(用户名)，password就输入你复制的令牌。随后登陆就成功了。 果然，全球最大的同性交流网站不是吹的，大七夕节非得找个伴侣，它要过七夕谁也拦不住呀！","categories":[{"name":"日常经验","slug":"日常经验","permalink":"http://billma.top/categories/%E6%97%A5%E5%B8%B8%E7%BB%8F%E9%AA%8C/"}],"tags":[]},{"title":"C++中fstream的用法","slug":"cpp-fstream","date":"2021-08-04T06:48:06.000Z","updated":"2023-12-12T11:52:55.955Z","comments":true,"path":"2021/08/04/cpp-fstream/","permalink":"http://billma.top/2021/08/04/cpp-fstream/","excerpt":"","text":"写在前面：啥是fstreamofstream是从内存到硬盘，ifstream是从硬盘到内存，其实所谓的流缓冲就是内存空间; 在C++中，有一个stream这个类，所有的I&#x2F;O都以这个“流”类为基础的，包括我们要认识的文件I&#x2F;O，stream这个类有两个重要的运算符： 1、插入器(&lt;&lt;) 向流输出数据比如说系统有一个默认的标准输出流(cout)，一般情况下就是指的显示器，所以，cout&lt;&lt;“Write Stdout”&lt;&lt;’\\n’;就表示把字符串”Write Stdout”和换行字符(‘\\n’)输出到标准输出流。 2、析取器(&gt;&gt;) 从流中输入数据比如说系统有一个默认的标准输入流(cin)，一般情况下就是指的键盘，所以，cin&gt;&gt;x;就表示从标准输入流中读取一个指定类型(即变量x的类型)的数据。 在C++中，对文件的操作是通过stream的子类fstream(file stream)来实现的，所以，要用这种方式操作文件，就必须加入头文件fstream.h。下面就把此类的文件操作过程一一道来。 一、打开文件在fstream类中，有一个成员函数open()，就是用来打开文件的，其原型是： 1void open(const char* filename,int mode,int access); 参数： 12345678910111213filename： 要打开的文件名mode： 要打开文件的方式access： 打开文件的属性打开文件的方式在类ios(是所有流式I/O类的基类)中定义，常用的值如下：ios::app： 以追加的方式打开文件ios::ate： 文件打开后定位到文件尾，ios:app就包含有此属性ios::binary： 以二进制方式打开文件，缺省的方式是文本方式。两种方式的区别见前文ios::in： 文件以输入方式打开（文件数据输入到内存）ios::out： 文件以输出方式打开（内存数据输出到文件）ios::nocreate： 不建立文件，所以文件不存在时打开失败ios::noreplace：不覆盖文件，所以打开文件时如果文件存在失败ios::trunc： 如果文件存在，把文件长度设为0 可以用“或”把以上属性连接起来，如ios::out|ios::binary 打开文件的属性取值是： 0：普通文件，打开访问 1：只读文件 2：隐含文件 4：系统文件 可以用“或”或者“+”把以上属性连接起来，如3或1|2就是以只读和隐含属性打开文件。 例如：以二进制输入方式打开文件c:\\config.sys 1fstream file1; file1.open(“c:\\config.sys”,ios::binary|ios::in,0); 如果open函数只有文件名一个参数，则是以读&#x2F;写普通文件打开，即： 123file1.open(“c:\\config.sys”);/*等价于*/file1.open(“c:\\config.sys”,ios::in|ios::out,0); 另外，fstream还有和open()一样的构造函数，对于上例，在定义的时侯就可以打开文件了： 1fstream file1(“c:\\config.sys”); 特别提出的是，fstream有两个子类：ifstream(input file stream)和ofstream(outpu file stream)，ifstream默认以输入方式打开文件，而ofstream默认以输出方式打开文件。 12ifstream file2(“c:\\pdos.def”);//以输入方式打开文件 ofstream file3(“c:\\x.123”);//以输出方式打开文件 所以，在实际应用中，根据需要的不同，选择不同的类来定义：如果想以输入方式打开，就用ifstream来定义；如果想以输出方式打开，就用ofstream来定义；如果想以输入&#x2F;输出方式来打开，就用fstream来定义。 二、关闭文件打开的文件使用完成后一定要关闭，fstream提供了成员函数close()来完成此操作，如：file1.close();就把file1相连的文件关闭。 三、读写文件 读写文件分为文本文件和二进制文件的读取，对于文本文件的读取比较简单，用插入器和析取器就可以了；而对于二进制的读取就要复杂些，下要就详细的介绍这两种方式 1、文本文件的读写 文本文件的读写很简单：用插入器(&lt;&lt;)向文件输出；用析取器(&gt;&gt;)从文件输入。假设file1是以输入方式打开，file2以输出打开。示例如下： 12file2&lt;&lt;“I Love You”;//向文件写入字符串&quot;I Love You&quot; int i; file1&gt;&gt;i;//从文件输入一个整数值。 这种方式还有一种简单的格式化能力，比如可以指定输出为16进制等等，具体的格式有以下一些 操纵符 功能 输入&#x2F;输出 dec 格式化为十进制数值数据 输入和输出 endl 输出一个换行符并刷新此流 输出 ends 输出一个空字符 输出 hex 格式化为十六进制数值数据 输入和输出 oct 格式化为八进制数值数据 输入和输出 setpxecision(int p) 设置浮点数的精度位数 输出 比如要把123当作十六进制输出： 1file1&lt;&lt;hex&lt;&lt;123; 要把3.1415926以5位精度输出： 1file1&lt;&lt;setpxecision(5)&lt;&lt;3.1415926。 2、二进制文件的读写put()put()函数向流写入一个字符，其原型是 1ofstream &amp;put(char ch) 使用也比较简单，如 1file1.put(‘c’); 就是向流写一个字符’c’。 get()get()函数比较灵活，有3种常用的重载形式： 一种就是和put()对应的形式： 1ifstream &amp;get(char &amp;ch); 功能是从流中读取一个字符，结果保存在引用ch中，如果到文件尾，返回空字符。如 1file2.get(x); 表示从文件中读取一个字符，并把读取的字符保存在x中。 另一种重载形式的原型是： 1int get(); 这种形式是从流中返回一个字符，如果到达文件尾，返回EOF，如 1x=file2.get(); 和上例功能是一样的。 还有一种形式的原型是： 1ifstream &amp;get(char *buf,int num,char delim=&#x27;\\n&#x27;); 这种形式把字符读入由 buf 指向的数组，直到读入了 num 个字符或遇到了由 delim 指定的字符，如果没使用 delim 这个参数，将使用缺省值换行符’\\n’。例如： 1file2.get(str1,127,‘A’); //从文件中读取字符到字符串str1，当遇到字符’A’或读取了127个字符时终止。 读写数据块要读写二进制数据块，使用成员函数read()和write()成员函数，它们原型如下： 1read(unsigned char *buf,int num); write(const unsigned char*buf,int num); num 个字符到 buf 指向的缓存中，如果在还未读入 num 个字符时就到了文件尾，可以用成员函数 int gcount();来取得实际读取的字符数；而``` write() ```从buf 指向的缓存写 num 个字符到文件中，值得注意的是缓存的类型是 ```unsigned char *```，有时可能需要类型转换。123456789101112例：```C++unsigned char str1[]=“I Love You”;int n[5];ifstream in(“xxx.xxx”); ofstream out(“yyy.yyy”);out.write(str1,strlen(str1));//把字符串str1全部写到yyy.yyy中 in.read((unsigned char*)n,sizeof(n));//从xxx.xxx中读取指定个整数，注意类型转换 in.close();out.close(); 四、检测EOF成员函数eof()用来检测是否到达文件尾，如果到达文件尾返回非0值，否则返回0。原型是int eof(); 例： 1if(in.eof()) ShowMessage(&quot;已经到达文件尾！&quot;); 五、文件定位和C的文件操作方式不同的是，C++ I&#x2F;O系统管理两个与一个文件相联系的指针。一个是读指针，它说明输入操作在文件中的位置；另一个是写指针，它下次写操作的位置。每次执行输入或输出时，相应的指针自动变化。所以，C++的文件定位分为读位置和写位置的定位，对应的成员函数是seekg()和seekp()。seekg()是设置读位置， seekp是设置写位置。它们最通用的形式如下： 1istream &amp;seekg(streamoff offset,seek_dir origin); ostream &amp;seekp(streamoff offset,seek_dir origin); streamoff定义于 iostream.h 中，定义有偏移量 offset 所能取得的最大值，seek_dir 表示移动的基准位置，是一个有以下值的枚举： 123ios::beg //文件开头ios::cur //文件当前位置 ios::end //文件结尾 这两个函数一般用于二进制文件，因为文本文件会因为系统对字符的解释而可能与预想的值不同。例： 1file1.seekg(1234,ios::cur); //把文件的读指针从当前位置向后移1234个字节 file2.seekp(1234,ios::beg); //把文件的写指针从文件开头向后移1234个字节 六.fstream的用法开一个文件1234fstream f; f.open(“1.txt”, ios::in | ios::binary); if (!f.is_open()) // 检查文件是否成功打开 cout &lt;&lt; “cannot open file.” &lt;&lt; endl; ios::in与ios::bianry均为int型，定义文件打开的方式。ios::in – 打开文件用于读。ios::out – 打开文件用于写，如果文件不存在，则新建一个；存在则清空其内容。ios::binary – 以二进制bit流方式进行读写，默认是ios::text，但最好指定这种读写方式，即使要读写的是文本。因为在ios::text模式下，在写入时’\\ n’字符将转换成两个字符：回车+换行（HEX: 0D 0A) 写入，读入时作逆转换，这容易引起不必要的麻烦。ios::app – 打开文件在文件尾进行写入，即使使用了seekp改变了写入位置，仍将在文件尾写入。ios::ate – 打开文件在文件尾进行写入，但seekp有效。 读写位置的改变f.seekg(0, ios::beg); &#x2F;&#x2F; 改变读入位置g mean Get f.seekp(0, ios::end); &#x2F;&#x2F; 改变写入位置 p mean Put 第一个参数是偏移量offset(long)，第二个参数是offset相对的位置，三个值： ios::beg – 文件头 ios::end – 文件尾 ios::cur – 当前位置 文件读写12char s[50]; f.read(s, 49); s[50] = ‘\\0’; // 注意要自己加上字符串结束符char *s = “hello”; f.write(s, strlen(s)); 七、补充记得读写完成后用f.close()关闭文件。 例子 下面的程序用于删除带有行号的源程序中的行号。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;fstream&gt;using namespace std;//定义要删除的行号格式，下面定义的是型如: #0001 的行号const int LINE_NUM_LENGTH = 5;const char LINE_NUM_START = &#x27;#&#x27;;int main(int argc, char *argv[])&#123; fstream f; char *s = NULL; int n; for (int i = 1; i &lt; argc; i++) &#123; cout &lt;&lt; &quot;Processing file &quot; &lt;&lt; argv[i] &lt;&lt; &quot;......&quot;; f.open(argv[i], ios::in | ios::binary); if (!f.is_open()) &#123; cout &lt;&lt; &quot;CANNOT OPEN&quot;&lt;&lt; endl; continue; &#125; f.seekg(0, ios::end); n = f.tellg(); // 文件大小 s = new char[n+1]; f.seekg(0, ios::beg); f.read(s, n); s[n] = &#x27;\\0&#x27;; f.close(); // 采用一种简单的判断，遇到LINE_NUM_START后接一个数字， // 则认为它是一个行号. for (int j = 0; j &lt; n; j++) &#123; if (s[j] == LINE_NUM_START &amp;&amp; (s[j+1] &gt;= &#x27;0&#x27; &amp;&amp; s[j+1] &lt;= &#x27;9&#x27;)) &#123; for (int k = j; k &lt; j + LINE_NUM_LENGTH; k++) s[k] = &#x27; &#x27;; &#125; &#125; f.open(argv[i], ios::out | ios::binary); if (!f.is_open()) &#123; cout &lt;&lt; &quot;CANNOT OPEN&quot; &lt;&lt; endl; delete[] s; continue; &#125; f.write(s, n); f.close(); cout &lt;&lt; &quot;OK&quot; &lt;&lt; endl; delete[] s; &#125; return 0;&#125;","categories":[{"name":"编程算法","slug":"编程算法","permalink":"http://billma.top/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"C++ 中string用法详解","slug":"cpp-string","date":"2021-07-31T23:26:08.000Z","updated":"2023-12-12T11:52:55.956Z","comments":true,"path":"2021/08/01/cpp-string/","permalink":"http://billma.top/2021/08/01/cpp-string/","excerpt":"","text":"本文根据 CC BY-NC-SA 4.0 许可协议参考Nicolai M.Josuttis的文章并进行小部分转载 C++ 语言是个十分优秀的语言，但优秀并不表示完美。还是有许多人不愿意使用C或者C++，为什么？原因众多，其中之一就是C&#x2F;C++的文本处理功能太麻烦，用起来很不方便。 举例来说，如果文本格式是：用户名 电话号码，文件名name.txt 12345Tom 23245332 Jenny 22231231 Heny 22183942 Tom 23245332 … 现在我们需要对用户名排序，且只输出不同的姓名。 那么在shell 编程中，可以这样用： 1awk &#x27;&#123;print $1&#125;&#x27; name.txt | sort | uniq 如果使用C&#x2F;C++ 就麻烦了，他需要做以下工作： 先打开文件，检测文件是否打开，如果失败，则退出。 声明一个足够大得二维字符数组或者一个字符指针数组 读入一行到字符空间 然后分析一行的结构，找到空格，存入字符数组中。 关闭文件 写一个排序函数，或者使用写一个比较函数，使用sort()排序 遍历数组，比较是否有相同的，如果有，则要删除，copy… 输出信息 你可以用C++或者C语言去实现这个流程。如果一个人的主要工作就是处理这种类似的文本(例如做apache的日志统计和分析),你说他会喜欢C&#x2F;C++么？ 当然，有了STL，这些处理会得到很大的简化。我们可以使用 fstream来代替麻烦的fopen fread fclose, 用vector来代替数组。最重要的是用 string来代替char * 数组，使用sort排序算法来排序，用unique 函数来去重。听起来好像很不错。看看下面代码(例程1）： 123456789101112131415161718#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;fstream&gt;using namespace std;int main()&#123; ifstream in(&quot;name.txt&quot;); string strtmp; vector&lt;string&gt; vect; while(getline(in, strtmp, &#x27;\\n&#x27;)) vect.push_back(strtmp.substr(0, strtmp.find(&#x27; &#x27;))); sort(vect.begin(), vect.end()); vector&lt;string&gt;::iterator it=unique(vect.begin(), vect.end()); copy(vect.begin(), it, ostream_iterator&lt;string&gt;(cout, &quot;\\n&quot;)); return 0;&#125; 也还不错吧，至少会比想象得要简单得多！（代码里面没有对错误进行处理，只是为了说明问题，不要效仿). 当然，在这个文本格式中，不用vector而使用map会更有扩充性，例如，还可通过人名找电话号码等等，但是使用了map就不那么好用sort了。你可以用map试一试。 这里string的作用不只是可以存储字符串，还可以提供字符串的比较，查找等。在sort和unique函数中就默认使用了less 和equal_to函数, 上面的一段代码，其实使用了string的以下功能： 存储功能，在getline() 函数中 查找功能，在find() 函数中 子串功能，在substr() 函数中 string operator &lt; , 默认在sort() 函数中调用 string operator &#x3D;&#x3D; , 默认在unique() 函数中调用 总之，有了string 后，C++的字符文本处理功能总算得到了一定补充，加上配合STL其他容器使用，其在文本处理上的功能已经与perl, shell, php的距离缩小很多了。 因此掌握string 会让你的工作事半功倍。 1.string使用其实，string并不是一个单独的容器，只是basic_string 模板类的一个typedef 而已，相对应的还有wstring, 你在string 头文件中你会发现下面的代码: 1234extern &quot;C++&quot; &#123;typedef basic_string &lt;char&gt; string;typedef basic_string &lt;wchar_t&gt; wstring;&#125; // extern &quot;C++&quot; 由于只是解释string的用法，如果没有特殊的说明，本文并不区分string 和 basic_string的区别。 string 其实相当于一个保存字符的序列容器，因此除了有字符串的一些常用操作以外，还有包含了所有的序列容器的操作。字符串的常用操作包括：增加、删除、修改、查找比较、链接、输入、输出等。详细函数列表参看附录。不要害怕这么多函数，其实有许多是序列容器带有的，平时不一定用的上。 如果你要想了解所有函数的详细用法，你需要查看basic_string，或者下载STL编程手册。这里通过实例介绍一些常用函数。 1.1 充分使用string 操作符string 重载了许多操作符，包括 +, +&#x3D;, &lt;, &#x3D;, , [], «, »等，正式这些操作符，对字符串操作非常方便。先看看下面这个例子： 123456789101112131415161718192021222324252627282930313233#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; string strinfo=&quot;Please input your name:&quot;; cout &lt;&lt; strinfo ; cin &gt;&gt; strinfo; if( strinfo == &quot;winter&quot; ) cout &lt;&lt; &quot;you are winter!&quot;&lt;&lt;endl; else if( strinfo != &quot;wende&quot; ) cout &lt;&lt; &quot;you are not wende!&quot;&lt;&lt;endl; else if( strinfo &lt; &quot;winter&quot;) cout &lt;&lt; &quot;your name should be ahead of winter&quot;&lt;&lt;endl; else cout &lt;&lt; &quot;your name should be after of winter&quot;&lt;&lt;endl; strinfo += &quot; , Welcome to China!&quot;; cout &lt;&lt; strinfo&lt;&lt;endl; cout &lt;&lt;&quot;Your name is :&quot;&lt;&lt;endl; string strtmp = &quot;How are you? &quot; + strinfo; for(int i = 0 ; i &lt; strtmp.size(); i ++) cout&lt;&lt;strtmp[i]; return 0;&#125;/*下面是程序的输出Please input your name:Heroyou are not wende!Hero , Welcome to China!How are you? Hero , Welcome to China!*/ 有了这些操作符，在STL中仿函数都可以直接使用string作为参数，例如 less, great, equal_to 等，因此在把string作为参数传递的时候，它的使用和int 或者float等已经没有什么区别了。例如，你可以使用： 1map&lt;string, int&gt; mymap; //以上默认使用了 less&lt;string&gt; 有了 operator + 以后，你可以直接连加，例如： 123string strinfo=&quot;Winter&quot;;string strlast=&quot;Hello &quot; + strinfo + &quot;!&quot;;string strtest=&quot;Hello &quot; + strinfo + &quot; Welcome&quot; + &quot; to China&quot; + &quot; !&quot;; 看见其中的特点了吗？只要你的等式里面有一个 string 对象，你就可以一直连续”+”，但有一点需要保证的是，在开始的两项中，必须有一项是 string 对象。其原理很简单： 系统遇到”+“号，发现有一项是string 对象。 系统把另一项转化为一个临时 string 对象。 执行 operator + 操作，返回新的临时string 对象。 如果又发现”+“号，继续第一步操作。 由于这个等式是由左到右开始检测执行，如果开始两项都是const char，程序自己并没有定义两个const char 的加法，编译的时候肯定就有问题了。 有了操作符以后，assign(), append(), compare(), at()等函数，除非有一些特殊的需求时，一般是用不上。当然at()函数还有一个功能，那就是检查下标是否合法，如果是使用： 123string str=&quot;winter&quot;;//下面一行有可能会引起程序中断错误str[100]=&#x27;!&#x27;;//下面会抛出异常:throws: out_of_rangecout&lt;&lt;str.at(100)&lt;&lt;endl; 了解了吗？如果你希望效率高，还是使用[]来访问，如果你希望稳定性好，最好使用at()来访问。 1.2 眼花缭乱的string find 函数由于查找是使用最为频繁的功能之一，string 提供了非常丰富的查找函数。其列表如下： 函数名 描述 find 查找 rfind 反向查找 find_first_of 查找包含子串中的任何字符，返回第一个位置 find_first_not_of 查找不包含子串中的任何字符，返回第一个位置 find_last_of 查找包含子串中的任何字符，返回最后一个位置 find_last_not_of 查找不包含子串中的任何字符，返回最后一个位置以上函数都是被重载了4次，以下是以find_first_of 函数为例说明他们的参数，其他函数和其参数一样，也就是说总共有24个函数 ： 1234size_type find_first_of(const basic_string&amp; s, size_type pos = 0)size_type find_first_of(const charT* s, size_type pos, size_type n)size_type find_first_of(const charT* s, size_type pos = 0)size_type find_first_of(charT c, size_type pos = 0) 所有的查找函数都返回一个size_type类型，这个返回值一般都是所找到字符串的位置，如果没有找到，则返回string::npos。有一点需要特别注意，所有和string::npos的比较一定要用string::size_type来使用，不要直接使用int 或者unsigned int等类型。其实string::npos表示的是-1, 看看头文件： 1234template &lt;class _CharT, class _Traits, class _Alloc&gt;const basic_string&lt;_CharT,_Traits,_Alloc&gt;::size_typebasic_string&lt;_CharT,_Traits,_Alloc&gt;::npos= basic_string&lt;_CharT,_Traits,_Alloc&gt;::size_type) -1; find 和 rfind 都还比较容易理解，一个是正向匹配，一个是逆向匹配，后面的参数pos都是用来指定起始查找位置。对于find_first_of 和find_last_of 就不是那么好理解。 find_first_of 是给定一个要查找的字符集，找到这个字符集中任何一个字符所在字符串中第一个位置。或许看一个例子更容易明白。 有这样一个需求：过滤一行开头和结尾的所有非英文字符。看看用string 如何实现： 12345678910111213141516171819202122#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; string strinfo=&quot; //*---Hello Word!......------&quot;; string strset=&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot;; int first = strinfo.find_first_of(strset); if(first == string::npos) &#123; cout&lt;&lt;&quot;not find any characters&quot;&lt;&lt;endl; return -1; &#125; int last = strinfo.find_last_of(strset); if(last == string::npos) &#123; cout&lt;&lt;&quot;not find any characters&quot;&lt;&lt;endl; return -1; &#125; cout &lt;&lt; strinfo.substr(first, last - first + 1)&lt;&lt;endl; return 0;&#125; 这里把所有的英文字母大小写作为了需要查找的字符集，先查找第一个英文字母的位置，然后查找最后一个英文字母的位置，然后用substr 来的到中间的一部分，用于输出结果。下面就是其结果：Hello Word前面的符号和后面的符号都没有了。像这种用法可以用来查找分隔符，从而把一个连续的字符串分割成为几部分，达到 shell 命令中的 awk 的用法。特别是当分隔符有多个的时候，可以一次指定。例如有这样的需求： 1234张三|3456123, 湖南李四,4564234| 湖北王小二, 4433253|北京... 我们需要以 “|” “,“为分隔符，同时又要过滤空格，把每行分成相应的字段。 1.3 string insert, replace, erase 了解了string 的操作符，查找函数和substr，其实就已经了解了string的80%的操作了。insert函数, replace函数和erase函数在使用起来相对简单。下面以一个例子来说明其应用。 string只是提供了按照位置和区间的replace函数，而不能用一个string字串来替换指定string中的另一个字串。这里写一个函数来实现这个功能： 1234567891011void string_replace(string &amp; strBig, const string &amp; strsrc, const string &amp;strdst)&#123; string::size_type pos=0; string::size_type srclen=strsrc.size(); string::size_type dstlen=strdst.size(); while( (pos=strBig.find(strsrc, pos)) != string::npos) &#123; strBig.replace(pos, srclen, strdst); pos += dstlen; &#125;&#125; 看看如何调用： 1234567891011#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; string strinfo=&quot;This is Winter, Winter is a programmer. Do you know Winter?&quot;; cout&lt;&lt;&quot;Orign string is :\\n&quot;&lt;&lt;strinfo&lt;&lt;endl; string_replace(strinfo, &quot;Winter&quot;, &quot;wende&quot;); cout&lt;&lt;&quot;After replace Winter with wende, the string is :\\n&quot;&lt;&lt;strinfo&lt;&lt;endl; return 0;&#125; 其输出结果： 1234Orign string is :This is Winter, Winter is a programmer. Do you know Winter?After replace Winter with wende, the string is :This is wende, wende is a programmer. Do you know wende? 如果不用replace函数，则可以使用erase和insert来替换，也能实现string_replace函数的功能： 123456789101112void string_replace(string &amp; strBig, const string &amp; strsrc, const string &amp;strdst)&#123; string::size_type pos=0; string::size_type srclen=strsrc.size(); string::size_type dstlen=strdst.size(); while( (pos=strBig.find(strsrc, pos)) != string::npos) &#123; strBig.erase(pos, srclen); strBig.insert(pos, strdst); pos += dstlen; &#125;&#125; 当然，这种方法没有使用replace来得直接. 2 string 和C-style字符串现在看了这么多例子，发现const char* 可以和string 直接转换，例如我们在上面的例子中，使用 string_replace(strinfo, &quot;Winter&quot;, &quot;wende&quot;);来代用void string_replace(string &amp; strBig, const string &amp; strsrc, const string &amp;strdst)在C语言中只有char* 和 const char*，为了使用起来方便，string提供了三个函数满足其要求： const charTc_str() constconst charT data() constsize_type copy(charT* buf, size_type n, size_type pos &#x3D; 0) const其中： c_str 直接返回一个以\\0结尾的字符串。 data 直接以数组方式返回string的内容，其大小为size()的返回值，结尾并没有\\0字符。 copy 把string的内容拷贝到buf空间中。 你或许会问，c_str()的功能包含data()，那还需要data()函数干什么？看看源码： 12345678const charT* c_str() const&#123; if (length () == 0) return &quot;&quot;; terminate (); return data ();&#125; 原来c_str()的流程是：先调用terminate()，然后在返回data()。因此如果你对效率要求比较高，而且你的处理又不一定需要以\\0的方式结束，你最好选择data()。但是对于一般的C函数中，需要以const char*为输入参数，你就要使用c_str()函数。 对于c_str() data()函数，返回的数组都是由string本身拥有，千万不可修改其内容。其原因是许多string实现的时候采用了引用机制，也就是说，有可能几个string使用同一个字符存储空间。而且你不能使用sizeof(string)来查看其大小。详细的解释和实现查看Effective STL的条款15：小心string实现的多样性。 另外在你的程序中，只在需要时才使用c_str()或者data()得到字符串，每调用一次，下次再使用就会失效，如： 1234567891011string strinfo(&quot;this is Winter&quot;);...//最好的方式是:foo(strinfo.c_str());//也可以这么用:const char* pstr=strinfo.c_str();foo(pstr);//不要再使用了pstr了, 下面的操作已经使pstr无效了。strinfo += &quot; Hello!&quot;;foo(pstr);//错误！ 会遇到什么错误？当你幸运的时候pstr可能只是指向&quot;this is Winter Hello!“的字符串，如果不幸运，就会导致程序出现其他问题，总会有一些不可遇见的错误。总之不会是你预期的那个结果。 3 string 和 Charactor Traits 了解了string的用法，该详细看看string的真相了前面提到string 只是basic_string的一个typedef。看看basic_string 的参数： 123456789101112131415161718192021222324252627282930313233template &lt;class charT, class traits = char_traits&lt;charT&gt;,class Allocator = allocator&lt;charT&gt; &gt;class basic_string&#123;//...&#125;char_traits不仅是在basic_string 中有用，在basic_istream 和 basic_ostream中也需要用到。 就像Steve Donovan在过度使用C++模板中提到的，这些确实有些过头了，要不是系统自己定义了相关的一些属性，而且用了个typedef，否则还真不知道如何使用。但复杂总有复杂道理。有了char_traits，你可以定义自己的字符串类型。当然，有了char_traits &lt; char &gt; 和char_traits &lt; wchar_t &gt; 你的需求使用已经足够了，为了更好的理解string ，咱们来看看char_traits都有哪些要求。如果你希望使用你自己定义的字符，你必须定义包含下列成员的结构： 表达式 描述```C++char_type 字符类型int_type int 类型pos_type 位置类型off_type 表示位置之间距离的类型state_type 表示状态的类型assign(c1,c2) 把字符c2赋值给c1eq(c1,c2) 判断c1,c2 是否相等lt(c1,c2) 判断c1是否小于c2length(str) 判断str的长度compare(s1,s2,n) 比较s1和s2的前n个字符copy(s1,s2, n) 把s2的前n个字符拷贝到s1中move(s1,s2, n) 把s2中的前n个字符移动到s1中assign(s,n,c) 把s中的前n个字符赋值为cfind(s,n,c) 在s的前n个字符内查找ceof() 返回end-of-fileto_int_type(c) 将c转换成int_typeto_char_type(i) 将i转换成char_typenot_eof(i) 判断i是否为EOFeq_int_type(i1,i2) 判断i1和i2是否相等 想看看实际的例子，你可以看看sgi STL的char_traits结构源码. 现在默认的string版本中，并不支持忽略大小写的比较函数和查找函数，如果你想练练手，你可以试试改写一个char_traits , 然后生成一个case_string类, 也可以在string 上做继承，然后派生一个新的类，例如：ext_string，提供一些常用的功能，例如： 定义分隔符。给定分隔符，把string分为几个字段。 提供替换功能。例如，用winter, 替换字符串中的wende 大小写处理。例如，忽略大小写比较，转换等 整形转换。例如把”123”字符串转换为123数字。 这些都是常用的功能，如果你有兴趣可以试试。其实有人已经实现了，看看Extended STL string。如果你想偷懒，下载一个头文件就可以用，有了它确实方便了很多。要是有人能提供一个支持正则表达式的string，我会非常乐意用。 4.string 建议使用string 的方便性就不用再说了，这里要重点强调的是string的安全性。 string并不是万能的，如果你在一个大工程中需要频繁处理字符串，而且有可能是多线程，那么你一定要慎重(当然，在多线程下你使用任何STL容器都要慎重)。 string的实现和效率并不一定是你想象的那样，如果你对大量的字符串操作，而且特别关心其效率，那么你有两个选择，首先，你可以看看你使用的STL版本中string实现的源码；另一选择是你自己写一个只提供你需要的功能的类。 string的c_str()函数是用来得到C语言风格的字符串，其返回的指针不能修改其空间。而且在下一次使用时重新调用获得新的指针。 string的data()函数返回的字符串指针不会以’\\0’结束，千万不可忽视。 尽量去使用操作符，这样可以让程序更加易懂 5 小结 难怪有人说：string 使用方便功能强，我们一直用它！ 6 附录1234567891011121314151617181920212223242526272829303132333435363738394041string 函数列表 函数名 描述begin 得到指向字符串开头的Iteratorend 得到指向字符串结尾的Iteratorrbegin 得到指向反向字符串开头的Iteratorrend 得到指向反向字符串结尾的Iteratorsize 得到字符串的大小length 和size函数功能相同max_size 字符串可能的最大大小capacity 在不重新分配内存的情况下，字符串可能的大小empty 判断是否为空operator[] 取第几个元素，相当于数组c_str 取得C风格的const char* 字符串data 取得字符串内容地址operator= 赋值操作符reserve 预留空间swap 交换函数insert 插入字符append 追加字符push_back 追加字符operator+= += 操作符erase 删除字符串clear 清空字符容器中所有内容resize 重新分配空间assign 和赋值操作符一样replace 替代copy 字符串到空间find 查找rfind 反向查找find_first_of 查找包含子串中的任何字符，返回第一个位置find_first_not_of 查找不包含子串中的任何字符，返回第一个位置find_last_of 查找包含子串中的任何字符，返回最后一个位置find_last_not_of 查找不包含子串中的任何字符，返回最后一个位置substr 得到字串compare 比较字符串operator+ 字符串链接operator== 判断是否相等operator!= 判断是否不等于operator&lt; 判断是否小于operator&gt;&gt; 从输入流中读入字符串operator&lt;&lt; 字符串写入输出流getline 从输入流中读入一行 之所以抛弃char*的字符串而选用C++标准程序库中的string类，是因为他和前者比较起来，不必担心内存是否足够、字符串长度等等，而且作为一个类出现，他集成的操作函数足以完成我们大多数情况下(甚至是100%)的需要。我们可以用 &#x3D; 进行赋值操作，&#x3D;&#x3D; 进行比较，+ 做串联（是不是很简单?）。我们尽可以把它看成是C++的基本数据类型。 好了，进入正题……… 首先，为了在我们的程序中使用string类型，我们必须包含头文件&lt;cstring&gt;。 1．声明一个C++字符串声明一个字符串变量很简单：string Str;这样我们就声明了一个字符串变量，但既然是一个类，就有构造函数和析构函数。上面的声明没有传入参数，所以就直接使用了string的默认的构造函数，这个函数所作的就是把Str初始化为一个空字符串。String类的构造函数和析构函数如下： 12345678910a) string s; //生成一个空字符串sb) string s(str) //拷贝构造函数 生成str的复制品c) string s(str,stridx) //将字符串str内“始于位置stridx”的部分当作字符串的初值d) string s(str,stridx,strlen) //将字符串str内“始于stridx且长度顶多strlen”的部分作为字符串的初值e) string s(cstr) //将C字符串作为s的初值f) string s(chars,chars_len) //将C字符串前chars_len个字符作为字符串s的初值。g) string s(num,c) //生成一个字符串，包含num个c字符h) string s(beg,end) //以区间beg;end(不包含end)内的字符作为字符串s的初值i) s.~string() //销毁所有字符，释放内存 都很简单，我就不解释了。 2．字符串操作函数这里是C++字符串的重点，我先把各种操作函数罗列出来，不喜欢把所有函数都看完的人可以在这里找自己喜欢的函数，再到后面看他的详细解释。 12345678910111213141516171819202122232425a) =,assign() //赋以新值b) swap() //交换两个字符串的内容c) +=,append(),push_back() //在尾部添加字符d) insert() //插入字符e) erase() //删除字符f) clear() //删除全部字符g) replace() //替换字符h) + //串联字符串i) ==,!=,&lt;,&lt;=,&gt;,&gt;=,compare() //比较字符串j) size(),length() //返回字符数量k) max_size() //返回字符的可能最大个数l) empty() //判断字符串是否为空m) capacity() //返回重新分配之前的字符容量n) reserve() //保留一定量内存以容纳一定数量的字符o) [ ], at() //存取单一字符p) &gt;&gt;,getline() //从stream读取某值q) &lt;&lt; //将谋值写入streamr) copy() //将某值赋值为一个C_strings) c_str() //将内容以C_string返回t) data() //将内容以字符数组形式返回u) substr() //返回某个子字符串v)查找函数w)begin() end() //提供类似STL的迭代器支持x) rbegin() rend() //逆向迭代器y) get_allocator() //返回配置器 2．1 C++字符串和C字符串的转换C++提供的由C++字符串得到对应的C_string的方法是使用data()、c_str()和copy()，其中，data()以字符数组的形式返回字符串内容，但并不添加’\\0’。c_str()返回一个以‘\\0’结尾的字符数组，而copy()则把字符串的内容复制或写入既有的c_string 或字符数组内。C++字符串并不以’\\0’结尾。我的建议是在程序中能使用C++字符串就使用，除非万不得已不选用c_string。由于只是简单介绍，详细介绍掠过，谁想进一步了解使用中的注意事项可以给我留言(到我的收件箱)。我详细解释。 2．2 大小和容量函数 一个C++字符串存在三种大小：a)现有的字符数，函数是size()和length()，他们等效。Empty()用来检查字符串是否为空。 b)max_size() 这个大小是指当前C++字符串最多能包含的字符数，很可能和机器本身的限制或者字符串所在位置连续内存的大小有关系。我们一般情况下不用关心他，应该大小足够我们用的。但是不够用的话，会抛出length_error异常c)capacity()重新分配内存之前 string所能包含的最大字符数。这里另一个需要指出的是reserve()函数，这个函数为string重新分配内存。重新分配的大小由其参数决定，默认参数为0，这时候会对string进行非强制性缩减。 还有必要再重复一下C++字符串和C字符串转换的问题，许多人会遇到这样的问题，自己做的程序要调用别人的函数、类什么的（比如数据库连接函数 Connect(char*,char*)），但别人的函数参数用的是char形式的，而我们知道，c_str()、data()返回的字符数组由该字符串拥有，所以是一种const char,要想作为上面提及的函数的参数，还必须拷贝到一个char*,而我们的原则是能不使用C字符串就不使用。那么，这时候我们的处理方式是：如果此函数对参数(也就是char*)的内容不修改的话，我们可以这样Connect((char*)UserID.c_str(), (char*)PassWD.c_str()),但是这时候是存在危险的，因为这样转换后的字符串其实是可以修改的（有兴趣地可以自己试一试），所以我强调除非函数调用的时候不对参数进行修改，否则必须拷贝到一个char上去。当然，更稳妥的办法是无论什么情况都拷贝到一个char上去。同时我们也祈祷现在仍然使用C字符串进行编程的高手们（说他们是高手一点儿也不为过，也许在我们还穿开裆裤的时候他们就开始编程了，哈哈…）写的函数都比较规范，那样我们就不必进行强制转换了。 2．3元素存取 我们可以使用下标操作符[] 和函数at()对元素包含的字符进行访问。但是应该注意的是操作符[]并不检查索引是否有效（有效索引 0~str.length()），如果索引失效，会引起未定义的行为。而at()会检查，如果使用at()的时候索引无效，会抛出 out_of_range异常。 有一个例外不得不说，const string a;的操作符[]对索引值是a.length()仍然有效，其返回值是’\\0’。其他的各种情况，a.length()索引都是无效的。举例如下： 12345678910111213const string Cstr(“const string”);string Str(“string”);Str[3]; //okStr.at(3); //okStr[100]; //未定义的行为Str.at(100); //throw out_of_rangeStr[Str.length()] //未定义行为Cstr[Cstr.length()] //返回 ‘\\0’Str.at(Str.length());//throw out_of_rangeCstr.at(Cstr.length()) ////throw out_of_range 我不赞成类似于下面的引用或指针赋值： char&amp; r=s[2]; char* p= &amp;s[3]; 因为一旦发生重新分配，r,p立即失效。避免的方法就是不使用。 2．4比较函数 C++字符串支持常见的比较操作符（&gt;,&gt;&#x3D;,&lt;,&lt;&#x3D;,&#x3D;&#x3D;,!&#x3D;），甚至支持string与C-string的比较(如 str&lt;”hello”)。在使用&gt;,&gt;&#x3D;,&lt;,&lt;&#x3D;这些操作符的时候是根据“当前字符特性”将字符按字典顺序进行逐一得比较。字典排序靠前的字符小，比较的顺序是从前向后比较，遇到不相等的字符就按这个位置上的两个字符的比较结果确定两个字符串的大小。同时，string(“aaaa”) &lt;string(aaaaa)。 另一个功能强大的比较函数是成员函数compare()。他支持多参数处理，支持用索引值和长度定位子串来进行比较。他返回一个整数来表示比较结果，返回值意义如下：0-相等 〉0-大于 &lt;0-小于。举例如下： 1234567string s(“abcd”);s.compare(“abcd”); //返回0s.compare(“dcba”); //返回一个小于0的值s.compare(“ab”); //返回大于0的值s.compare(s); //相等s.compare(0,2,s,2,2); //用”ab”和”cd”进行比较 小于零s.compare(1,2,”bcx”,2); //用”bc”和”bc”比较。 怎么样？功能够全的吧！什么？还不能满足你的胃口？好吧，那等着，后面有更个性化的比较算法。先给个提示，使用的是STL的比较算法。什么？对STL一窍不通？你重修吧！ 2．5 更改内容 这在字符串的操作中占了很大一部分。 首先讲赋值，第一个赋值方法当然是使用操作符&#x3D;，新值可以是string(如：s&#x3D;ns) 、c_string(如：s&#x3D;”gaint”)甚至单一字符（如：s&#x3D;’j’）。还可以使用成员函数assign()，这个成员函数可以使你更灵活的对字符串赋值。还是举例说明吧： 123456s.assign(str); //直接s.assign(str,1,3);//如果str是”iamangel” 就是把”ama”赋给字符串s.assign(str,2,string::npos);//把字符串str从索引值2开始到结尾赋给ss.assign(“gaint”); //不说s.assign(“nico”,5);//把’n’ ‘I’ ‘c’ ‘o’ ‘\\0’赋给字符串s.assign(5,’x’);//把五个x赋给字符串 把字符串清空的方法有三个：s&#x3D;””;s.clear();s.erase();(我越来越觉得举例比说话让别人容易懂！)。 string提供了很多函数用于插入（insert）、删除（erase）、替换（replace）、增加字符。 先说增加字符（这里说的增加是在尾巴上），函数有 +&#x3D;、append()、push_back()。举例如下： 12345678910111213s+=str;//加个字符串s+=”my name is jiayp”;//加个C字符串s+=’a’;//加个字符s.append(str);s.append(str,1,3);//不解释了 同前面的函数参数assign的解释s.append(str,2,string::npos)//不解释了s.append(“my name is jiayp”);s.append(“nico”,5);s.append(5,’x’);s.push_back(‘a’);//这个函数只能增加单个字符 对STL熟悉的理解起来很简单 也许你需要在string中间的某个位置插入字符串，这时候你可以用insert()函数，这个函数需要你指定一个安插位置的索引，被插入的字符串将放在这个索引的后面。 12s.insert(0,”my name”);s.insert(1,str); 这种形式的insert()函数不支持传入单个字符，这时的单个字符必须写成字符串形式(让人恶心)。既然你觉得恶心，那就不得不继续读下面一段话：为了插入单个字符，insert()函数提供了两个对插入单个字符操作的重载函数：insert(size_type index,size_type num,chart c)和insert(iterator pos,size_type num,chart c)。其中size_type是无符号整数，iterator是char*,所以，你这么调用insert函数是不行的：insert(0,1,’j’);这时候第一个参数将转换成哪一个呢？所以你必须这么写：insert((string::size_type)0,1,’j’)！第二种形式指出了使用迭代器安插字符的形式，在后面会提及。顺便提一下，string有很多操作是使用STL的迭代器的，他也尽量做得和STL靠近。 删除函数erase()的形式也有好几种（真烦！），替换函数replace()也有好几个。举例吧： 1234string s=”il8n”;s.replace(1,2,”nternationalizatio”);//从索引1开始的2个替换成后面的C_strings.erase(13);//从索引13开始往后全删除s.erase(7,5);//从索引7开始往后删5个 2．6提取子串和字符串连接 题取子串的函数是：substr(),形式如下： 123s.substr();//返回s的全部内容s.substr(11);//从索引11往后的子串s.substr(5,6);//从索引5开始6个字符 把两个字符串结合起来的函数是+。（谁不明白请致电120） 2．7输入输出操作 1．» 从输入流读取一个string。 2．« 把一个string写入输出流。 另一个函数就是getline(),他从输入流读取一行内容，直到遇到分行符或到了文件尾。 2．8搜索与查找 查找函数很多，功能也很强大，包括了： 123456find()rfind()find_first_of()find_last_of()find_first_not_of()find_last_not_of() 这些函数返回符合搜索条件的字符区间内的第一个字符的索引，没找到目标就返回npos。所有的函数的参数说明如下： 第一个参数是被搜寻的对象。第二个参数（可有可无）指出string内的搜寻起点索引，第三个参数（可有可无）指出搜寻的字符个数。比较简单，不多说 不理解的可以向我提出，我再仔细的解答。当然，更加强大的STL搜寻在后面会有提及。 最后再说说npos的含义，string::npos的类型是string::size_type,所以，一旦需要把一个索引与npos相比，这个索引值必须是string::size)type类型的，更多的情况下，我们可以直接把函数和npos进行比较（如：if(s.find(“jia”)&#x3D;&#x3D;string::npos)）。","categories":[{"name":"编程算法","slug":"编程算法","permalink":"http://billma.top/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"我的第一篇博客","slug":"myfirstblog","date":"2021-07-09T20:23:52.000Z","updated":"2023-12-12T11:52:55.958Z","comments":true,"path":"2021/07/10/myfirstblog/","permalink":"http://billma.top/2021/07/10/myfirstblog/","excerpt":"","text":"首先,欢迎各位到访我的空间一直没时间打理这个博客,时至今日,终于在凌晨从百忙中完成了我的第一篇博客.这就算我的第一篇博客吧.","categories":[],"tags":[]}],"categories":[{"name":"精华转载","slug":"精华转载","permalink":"http://billma.top/categories/%E7%B2%BE%E5%8D%8E%E8%BD%AC%E8%BD%BD/"},{"name":"日常经验","slug":"日常经验","permalink":"http://billma.top/categories/%E6%97%A5%E5%B8%B8%E7%BB%8F%E9%AA%8C/"},{"name":"竞赛解法","slug":"竞赛解法","permalink":"http://billma.top/categories/%E7%AB%9E%E8%B5%9B%E8%A7%A3%E6%B3%95/"},{"name":"南航苏州附中校园活动","slug":"南航苏州附中校园活动","permalink":"http://billma.top/categories/%E5%8D%97%E8%88%AA%E8%8B%8F%E5%B7%9E%E9%99%84%E4%B8%AD%E6%A0%A1%E5%9B%AD%E6%B4%BB%E5%8A%A8/"},{"name":"编程算法","slug":"编程算法","permalink":"http://billma.top/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python","slug":"python","permalink":"http://billma.top/tags/python/"},{"name":"computer,cpp","slug":"computer-cpp","permalink":"http://billma.top/tags/computer-cpp/"}]}