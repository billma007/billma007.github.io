<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Bill Ma&#39;s Blog</title>
  
  <subtitle>Welcome!</subtitle>
  <link href="https://billma.top/atom.xml" rel="self"/>
  
  <link href="https://billma.top/"/>
  <updated>2021-08-23T12:23:10.000Z</updated>
  <id>https://billma.top/</id>
  
  <author>
    <name>Bill Ma</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>不同的C++中求解A+B的方法</title>
    <link href="https://billma.top/2021/08/23/a-b-problem/"/>
    <id>https://billma.top/2021/08/23/a-b-problem/</id>
    <published>2021-08-23T11:59:56.000Z</published>
    <updated>2021-08-23T12:23:10.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-基础算法"><a href="#1-基础算法" class="headerlink" title="1.基础算法"></a>1.基础算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> a,b;</span><br><span class="line"> cin&gt;&gt;a;</span><br><span class="line"> cin&gt;&gt;b;</span><br><span class="line"> cout&lt;&lt;a+b&lt;&lt;endl;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a+b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-Link-Cut-Tree"><a href="#2-Link-Cut-Tree" class="headerlink" title="2.Link-Cut Tree"></a>2.Link-Cut Tree</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data,rev,sum;</span><br><span class="line">    node *son[<span class="number">2</span>],*pre;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isroot</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setson</span><span class="params">(node *child,<span class="keyword">int</span> lr)</span></span>;</span><br><span class="line">&#125;lct[<span class="number">233</span>];</span><br><span class="line"><span class="keyword">int</span> top,a,b;</span><br><span class="line"><span class="function">node *<span class="title">getnew</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node *now=lct+ ++top;</span><br><span class="line">    now-&gt;data=x;</span><br><span class="line">    now-&gt;pre=now-&gt;son[<span class="number">1</span>]=now-&gt;son[<span class="number">0</span>]=lct;</span><br><span class="line">    now-&gt;sum=<span class="number">0</span>;</span><br><span class="line">    now-&gt;rev=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">node::judge</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> pre-&gt;son[<span class="number">1</span>]==<span class="keyword">this</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">node::isroot</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pre==lct)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> !(pre-&gt;son[<span class="number">1</span>]==<span class="keyword">this</span>||pre-&gt;son[<span class="number">0</span>]==<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">node::pushdown</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>==lct||!rev)<span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">swap</span>(son[<span class="number">0</span>],son[<span class="number">1</span>]);</span><br><span class="line">    son[<span class="number">0</span>]-&gt;rev^=<span class="number">1</span>;</span><br><span class="line">    son[<span class="number">1</span>]-&gt;rev^=<span class="number">1</span>;</span><br><span class="line">    rev=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">node::update</span><span class="params">()</span></span>&#123;sum=son[<span class="number">1</span>]-&gt;sum+son[<span class="number">0</span>]-&gt;sum+data;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">node::setson</span><span class="params">(node *child,<span class="keyword">int</span> lr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">pushdown</span>();</span><br><span class="line">    child-&gt;pre=<span class="keyword">this</span>;</span><br><span class="line">    son[lr]=child;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">update</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(node *now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node *father=now-&gt;pre,*grandfa=father-&gt;pre;</span><br><span class="line">    <span class="keyword">if</span>(!father-&gt;<span class="built_in">isroot</span>()) grandfa-&gt;<span class="built_in">pushdown</span>();</span><br><span class="line">    father-&gt;<span class="built_in">pushdown</span>();now-&gt;<span class="built_in">pushdown</span>();</span><br><span class="line">    <span class="keyword">int</span> lr=now-&gt;<span class="built_in">judge</span>();</span><br><span class="line">    father-&gt;<span class="built_in">setson</span>(now-&gt;son[lr^<span class="number">1</span>],lr);</span><br><span class="line">    <span class="keyword">if</span>(father-&gt;<span class="built_in">isroot</span>()) now-&gt;pre=grandfa;</span><br><span class="line">    <span class="keyword">else</span> grandfa-&gt;<span class="built_in">setson</span>(now,father-&gt;<span class="built_in">judge</span>());</span><br><span class="line">    now-&gt;<span class="built_in">setson</span>(father,lr^<span class="number">1</span>);</span><br><span class="line">    father-&gt;<span class="built_in">update</span>();now-&gt;<span class="built_in">update</span>();</span><br><span class="line">    <span class="keyword">if</span>(grandfa!=lct) grandfa-&gt;<span class="built_in">update</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(node *now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(now-&gt;<span class="built_in">isroot</span>())<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(;!now-&gt;<span class="built_in">isroot</span>();<span class="built_in">rotate</span>(now))</span><br><span class="line">    <span class="keyword">if</span>(!now-&gt;pre-&gt;<span class="built_in">isroot</span>())</span><br><span class="line">    now-&gt;<span class="built_in">judge</span>()==now-&gt;pre-&gt;<span class="built_in">judge</span>()?<span class="built_in">rotate</span>(now-&gt;pre):<span class="built_in">rotate</span>(now);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node *<span class="title">access</span><span class="params">(node *now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node *last=lct;</span><br><span class="line">    <span class="keyword">for</span>(;now!=lct;last=now,now=now-&gt;pre)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">splay</span>(now);</span><br><span class="line">        now-&gt;<span class="built_in">setson</span>(last,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">changeroot</span><span class="params">(node *now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">access</span>(now)-&gt;rev^=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">splay</span>(now);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(node *x,node *y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">changeroot</span>(x);</span><br><span class="line">    x-&gt;pre=y;</span><br><span class="line">    <span class="built_in">access</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cut</span><span class="params">(node *x,node *y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">changeroot</span>(x);</span><br><span class="line">    <span class="built_in">access</span>(y);</span><br><span class="line">    <span class="built_in">splay</span>(x);</span><br><span class="line">    x-&gt;<span class="built_in">pushdown</span>();</span><br><span class="line">    x-&gt;son[<span class="number">1</span>]=y-&gt;pre=lct;</span><br><span class="line">    x-&gt;<span class="built_in">update</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(node *x,node *y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">changeroot</span>(x);</span><br><span class="line">    node *now=<span class="built_in">access</span>(y);</span><br><span class="line">    <span class="keyword">return</span> now-&gt;sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">    node *A=<span class="built_in">getnew</span>(a);</span><br><span class="line">    node *B=<span class="built_in">getnew</span>(b);</span><br><span class="line">        <span class="built_in">connect</span>(A,B);</span><br><span class="line">        <span class="built_in">cut</span>(A,B);</span><br><span class="line">        <span class="built_in">connect</span>(A,B);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">query</span>(A,B)); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-SFPA"><a href="#3-SFPA" class="headerlink" title="3.SFPA"></a>3.SFPA</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m,a,b,op,head[<span class="number">200009</span>],next[<span class="number">200009</span>],dis[<span class="number">200009</span>],len[<span class="number">200009</span>],v[<span class="number">200009</span>],l,r,team[<span class="number">200009</span>],pd[<span class="number">100009</span>],u,v1,e;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lt</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    op++,v[op]=y;</span><br><span class="line">    next[op]=head[x],head[x]=op,len[op]=z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> f)</span><span class="comment">//SPFA……</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">200009</span>;i++)&#123;dis[i]=<span class="number">999999999</span>;&#125;</span><br><span class="line">    l=<span class="number">0</span>,r=<span class="number">1</span>,team[<span class="number">1</span>]=s,pd[s]=<span class="number">1</span>,dis[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l!=r)</span><br><span class="line">    &#123;</span><br><span class="line">        l=(l+<span class="number">1</span>)%<span class="number">90000</span>,u=team[l],pd[u]=<span class="number">0</span>,e=head[u];</span><br><span class="line">        <span class="keyword">while</span>(e!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            v1=v[e];</span><br><span class="line">            <span class="keyword">if</span>(dis[v1]&gt;dis[u]+len[e])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v1]=dis[u]+len[e];</span><br><span class="line">                <span class="keyword">if</span>(!pd[v1])</span><br><span class="line">                &#123;</span><br><span class="line">                    r=(r+<span class="number">1</span>)%<span class="number">90000</span>,</span><br><span class="line">                    team[r]=v1,</span><br><span class="line">                    pd[v1]=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            e=next[e];</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[f];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">    <span class="built_in">lt</span>(<span class="number">1</span>,<span class="number">2</span>,a);<span class="built_in">lt</span>(<span class="number">2</span>,<span class="number">3</span>,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in">SPFA</span>(<span class="number">1</span>,<span class="number">3</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-Floyed"><a href="#4-Floyed" class="headerlink" title="4.Floyed"></a>4.Floyed</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n=<span class="number">3</span>,a,b,dis[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dis[i][j]=<span class="number">2147483647</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dis[<span class="number">1</span>][<span class="number">2</span>]=a,dis[<span class="number">2</span>][<span class="number">3</span>]=b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[i][j]=<span class="built_in">min</span>(dis[i][j],dis[i][k]+dis[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dis[<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-递归算法"><a href="#5-递归算法" class="headerlink" title="5.递归算法"></a>5.递归算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a,b,c;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">dg</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a&lt;=<span class="number">5</span>)&#123;<span class="keyword">return</span> a;&#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">dg</span>(a/<span class="number">2</span>)+<span class="built_in">dg</span>(a-a/<span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    c=<span class="built_in">dg</span>(a)+<span class="built_in">dg</span>(b);</span><br><span class="line">    cout&lt;&lt;c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-高精度计算"><a href="#6-高精度计算" class="headerlink" title="6.高精度计算"></a>6.高精度计算</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a1[<span class="number">1000</span>],b1[<span class="number">1000</span>];</span><br><span class="line">      <span class="keyword">int</span> a[<span class="number">1000</span>]=&#123;<span class="number">0</span>&#125;,b[<span class="number">1000</span>]=&#123;<span class="number">0</span>&#125;,c[<span class="number">1000</span>]=&#123;<span class="number">0</span>&#125;,la,lb,lc,i,x;</span><br><span class="line">      cin&gt;&gt;a1&gt;&gt;b1;</span><br><span class="line">      la=<span class="built_in">strlen</span>(a1);</span><br><span class="line">      lb=<span class="built_in">strlen</span>(b1);</span><br><span class="line">      <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=la<span class="number">-1</span>;i++)&#123;a[la-i]=a1[i]<span class="number">-48</span>;&#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=lb<span class="number">-1</span>;i++)&#123;b[lb-i]=b1[i]<span class="number">-48</span>;&#125;</span><br><span class="line">      lc=<span class="number">1</span>,x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(lc&lt;=la||lc&lt;=lb)&#123;c[lc]=a[lc]+b[lc]+x,x=c[lc]/<span class="number">10</span>,c[lc]%=<span class="number">10</span>,lc++;&#125;</span><br><span class="line">    c[lc]=x;</span><br><span class="line">    <span class="keyword">if</span>(c[lc]==<span class="number">0</span>)&#123;lc--;&#125;</span><br><span class="line">    <span class="keyword">for</span>(i=lc;i&gt;=<span class="number">1</span>;i--)&#123;cout&lt;&lt;c[i];&#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-压位高精"><a href="#7-压位高精" class="headerlink" title="7.压位高精"></a>7.压位高精</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p 8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> carry 100000000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn=<span class="number">50001</span>;  </span><br><span class="line"><span class="keyword">char</span> s1[Maxn],s2[Maxn];  </span><br><span class="line"><span class="keyword">int</span> a[Maxn],b[Maxn],ans[Maxn];  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">char</span> s[],<span class="keyword">int</span> n[])</span>   </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">char</span> temp[Maxn];   </span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(s+<span class="number">1</span>),cur=<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span>(len/p)</span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">strncpy</span>(temp,s+len-p+<span class="number">1</span>,p);</span><br><span class="line">        n[++cur]=<span class="built_in">atoi</span>(temp); </span><br><span class="line">        len-=p;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span>(len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(temp,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(temp));  </span><br><span class="line">        <span class="built_in">strncpy</span>(temp,s+<span class="number">1</span>,len);  </span><br><span class="line">        n[++cur]=<span class="built_in">atoi</span>(temp);   </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> b[],<span class="keyword">int</span> c[],<span class="keyword">int</span> l1,<span class="keyword">int</span> l2)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,l3=<span class="built_in">max</span>(l1,l2);  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=l3;i++)</span><br><span class="line">    &#123;  </span><br><span class="line">        c[i]=a[i]+b[i]+x;  </span><br><span class="line">        x=c[i]/carry;</span><br><span class="line">        c[i]%=carry;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">while</span>(x&gt;<span class="number">0</span>)&#123;c[++l3]=x%<span class="number">10</span>;x/=<span class="number">10</span>;&#125;  </span><br><span class="line">    <span class="keyword">return</span> l3;</span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> len)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a[len]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=len<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)<span class="built_in">printf</span>(<span class="string">&quot;%0*d&quot;</span>,p,a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>,s1+<span class="number">1</span>,s2+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> la=<span class="built_in">change</span>(s1,a);</span><br><span class="line">    <span class="keyword">int</span> lb=<span class="built_in">change</span>(s2,b);</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">add</span>(a,b,ans,la,lb);    </span><br><span class="line">    <span class="built_in">print</span>(ans,len);</span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="8-树状数组"><a href="#8-树状数组" class="headerlink" title="8.树状数组"></a>8.树状数组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&amp;(-a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">2</span>,m=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ans[m+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> a[n+<span class="number">1</span>],c[n+<span class="number">1</span>],s[n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> o=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(c));</span><br><span class="line">    s[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        s[i]=s[i<span class="number">-1</span>]+a[i];</span><br><span class="line">        c[i]=s[i]-s[i-<span class="built_in">lowbit</span>(i)];<span class="comment">//树状数组创建前缀和优化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> q=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(q==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="keyword">int</span> x,y;</span><br><span class="line">           cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">           <span class="keyword">int</span> j=x;</span><br><span class="line">           <span class="keyword">while</span>(j&lt;=n)</span><br><span class="line">           &#123;</span><br><span class="line">               c[j]+=y;</span><br><span class="line">               j+=<span class="built_in">lowbit</span>(j);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x=<span class="number">1</span>,y=<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> s1=<span class="number">0</span>,s2=<span class="number">0</span>,p=x<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(p&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                s1+=c[p];</span><br><span class="line">                p-=<span class="built_in">lowbit</span>(p);</span><br><span class="line">            &#125;</span><br><span class="line">            p=y;</span><br><span class="line">            <span class="keyword">while</span>(p&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                s2+=c[p];</span><br><span class="line">                p-=<span class="built_in">lowbit</span>(p);</span><br><span class="line">            &#125;    </span><br><span class="line">            o++;</span><br><span class="line">            ans[o]=s2-s1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=o;i++)</span><br><span class="line">        cout&lt;&lt;ans[i]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-粗暴模拟人工运算"><a href="#9-粗暴模拟人工运算" class="headerlink" title="9.粗暴模拟人工运算"></a>9.粗暴模拟人工运算</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> fu=<span class="number">1</span>,f=<span class="number">1</span>,a,b,c=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="keyword">if</span>(a&lt;<span class="number">0</span>&amp;&amp;b&gt;<span class="number">0</span>)fu=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;<span class="number">0</span>&amp;&amp;b&lt;<span class="number">0</span>)fu=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span>(a&lt;<span class="number">0</span>&amp;&amp;b&lt;<span class="number">0</span>)f=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="number">0</span>)&#123;cout&lt;&lt;b;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)&#123;cout&lt;&lt;a;<span class="keyword">return</span> <span class="number">0</span>;&#125; </span><br><span class="line">    a=<span class="built_in">abs</span>(a);</span><br><span class="line">    b=<span class="built_in">abs</span>(b);</span><br><span class="line">    <span class="keyword">if</span>(a&gt;b&amp;&amp;fu==<span class="number">3</span>)f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(b&gt;a&amp;&amp;fu==<span class="number">3</span>)f=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(b&gt;a&amp;&amp;fu==<span class="number">2</span>)f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(b&lt;a&amp;&amp;fu==<span class="number">2</span>)f=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(fu==<span class="number">1</span>)c=a+b;</span><br><span class="line">    <span class="keyword">if</span>(fu&gt;<span class="number">1</span>)c=<span class="built_in">max</span>(a,b)-<span class="built_in">min</span>(a,b);</span><br><span class="line">    c*=f;</span><br><span class="line">    cout&lt;&lt;c;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-Dijkstra-STL的优先队列优化"><a href="#10-Dijkstra-STL的优先队列优化" class="headerlink" title="10.Dijkstra+STL的优先队列优化"></a>10.Dijkstra+STL的优先队列优化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">405</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,w;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edge[N*N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> dis[N*N];</span><br><span class="line"><span class="keyword">bool</span> vis[N*N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dis[a]&gt;dis[b];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;,cmp&gt; dijQue;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    dijQue.<span class="built_in">push</span>(start);</span><br><span class="line">    dis[start]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!dijQue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u=dijQue.<span class="built_in">top</span>();</span><br><span class="line">        dijQue.<span class="built_in">pop</span>();</span><br><span class="line">        vis[u]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(u==end)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;edge[u].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> v=edge[u][i].v;</span><br><span class="line">            <span class="keyword">if</span>(dis[v]==<span class="number">-1</span> || dis[v]&gt;dis[u]+edge[u][i].w) &#123;</span><br><span class="line">                dis[v]=dis[u]+edge[u][i].w;</span><br><span class="line">                <span class="keyword">if</span>(!vis[v]) &#123;</span><br><span class="line">                    vis[v]=<span class="literal">true</span>;</span><br><span class="line">                    dijQue.<span class="built_in">push</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[end];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">    Edge Qpush;</span><br><span class="line">    </span><br><span class="line">    Qpush.v=<span class="number">1</span>;</span><br><span class="line">    Qpush.w=a;</span><br><span class="line">    edge[<span class="number">0</span>].<span class="built_in">push_back</span>(Qpush);</span><br><span class="line">    </span><br><span class="line">    Qpush.v=<span class="number">2</span>;</span><br><span class="line">    Qpush.w=b;</span><br><span class="line">    edge[<span class="number">1</span>].<span class="built_in">push_back</span>(Qpush);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in">Dijkstra</span>(<span class="number">0</span>,<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-分治算法（二分法）"><a href="#11-分治算法（二分法）" class="headerlink" title="11.分治算法（二分法）"></a>11.分治算法（二分法）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a,b,c;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;<span class="keyword">long</span> <span class="keyword">long</span> l=-<span class="built_in"><span class="keyword">int</span></span>(<span class="number">1e9</span>)&lt;&lt;<span class="number">1</span>,r=<span class="built_in"><span class="keyword">int</span></span>(<span class="number">1e9</span>)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">     <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">     <span class="keyword">while</span>(r-l&gt;<span class="number">1</span>)&#123;c=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">         <span class="keyword">if</span>(c-b&lt;a)l=c;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span>(c-b&gt;a)r=c;</span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,c),<span class="number">0</span>;</span><br><span class="line">     &#125;<span class="keyword">if</span>(l!=r)<span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,r),<span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="12-位运算"><a href="#12-位运算" class="headerlink" title="12.位运算"></a>12.位运算</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> m, n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;m, &amp;n);</span><br><span class="line">    <span class="keyword">int</span> u = m &amp; n;</span><br><span class="line">    <span class="keyword">int</span> v = m ^ n;</span><br><span class="line">    <span class="keyword">while</span> (u) &#123;</span><br><span class="line">        <span class="keyword">int</span> s = v;</span><br><span class="line">        <span class="keyword">int</span> t = u &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        u = s &amp; t;</span><br><span class="line">        v = s ^ t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-线段树"><a href="#13-线段树" class="headerlink" title="13.线段树"></a>13.线段树</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val,l,r;</span><br><span class="line">&#125;;</span><br><span class="line">node t[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>],f[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> node)</span></span>&#123;</span><br><span class="line">    t[node].l=l;t[node].r=r;t[node].val=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        f[l]=node;</span><br><span class="line">        t[node].val=a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(l,mid,node*<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">build</span>(mid+<span class="number">1</span>,r,node*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">    t[node].val=t[node*<span class="number">2</span>].val+t[node*<span class="number">2</span>+<span class="number">1</span>].val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node==<span class="number">1</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> fa=node&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    t[fa].val=t[fa*<span class="number">2</span>].val+t[fa*<span class="number">2</span>+<span class="number">1</span>].val;</span><br><span class="line">    <span class="built_in">update</span>(fa);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[node].l==l&amp;&amp;t[node].r==r)&#123;</span><br><span class="line">        <span class="keyword">return</span> t[node].val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> lc=node*<span class="number">2</span>;<span class="keyword">int</span> rc=lc+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(t[lc].r&gt;=l)&#123;</span><br><span class="line">        <span class="keyword">if</span>(t[lc].r&gt;=r)&#123;</span><br><span class="line">            sum+=<span class="built_in">find</span>(l,r,lc);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            sum+=<span class="built_in">find</span>(l,t[lc].r,lc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t[rc].l&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(t[rc].l&lt;=l)&#123;</span><br><span class="line">            sum+=<span class="built_in">find</span>(l,r,rc);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            sum+=<span class="built_in">find</span>(t[rc].l,r,rc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in">find</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14-快读"><a href="#14-快读" class="headerlink" title="14.快读"></a>14.快读</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f=<span class="number">1</span>,x=<span class="number">0</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in">read</span>()+<span class="built_in">read</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-基础算法&quot;&gt;&lt;a href=&quot;#1-基础算法&quot; class=&quot;headerlink&quot; title=&quot;1.基础算法&quot;&gt;&lt;/a&gt;1.基础算法&lt;/h3&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutte</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>csp</title>
    <link href="https://billma.top/2021/08/23/pictures/csp/"/>
    <id>https://billma.top/2021/08/23/pictures/csp/</id>
    <published>2021-08-23T11:40:05.000Z</published>
    <updated>2021-08-23T12:07:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文适合普及组到提高组的同学学习，并且尽量做到优秀的排版和通俗易懂，少用缩写。</p><p>标有 $\checkmark$ 的为常考/出现过，标有“补”为拓展内容，标有 $\bigstar$ 为<strong>每年几乎必考</strong>，加粗的内容为提炼过后的重点。</p><p>建议先预习<a href="https://ti.luogu.com.cn/problemset/1034/training">CSP 2020 入门组第一轮</a>/<a href="https://ti.luogu.com.cn/problemset/1035/training">CSP 2020 提高组第一轮</a>/<a href="https://ti.luogu.com.cn/problemset/1033/training">CSP 2020 第一轮（初赛）模拟</a>的前 $15$ 题。</p><p>迄今为止，初赛分为两个部分：</p><ol><li>基础题：考察计算机科学和算法的基础，或许会有一些简单的数学。</li><li>程序题：读程序写结果（$3$ 题）+补全程序（$2$ 题），难度依次递增。</li></ol><p>这里只介绍基础题的部分，程序题由于知识点过散，需要大家自己多做题。</p><p>如果有对文章的建议/问题均欢迎在下方留言！</p><hr /><p>$$\Large\mathtt{\text{CSP初赛通过指南-基础篇}}$$$$\mathtt{CSP\,\,\,PRE-KNOWLEDGE}$$</p><p>$$\tiny\text{本文内容较多，如果是想查找某一个特定的词语，可以在浏览器中使用 Ctrl + F 进行页面内搜索。}$$</p><hr /><p>$$\large\texttt{计算机}$$</p><ul><li><p>计算机的分类 $\checkmark$</p><ul><li><p>按年代分类</p></li><li><p>$1946\,\texttt{至}\,1958\,\,\,\,\,\,\,\texttt{电子管}$</p></li><li><p>$1959\,\texttt{至}\,1964\,\,\,\,\,\,\,\texttt{晶体管}$</p></li><li><p>$1965\,\texttt{至}\,1970\,\,\,\,\,\,\,\texttt{集成电路}$</p></li><li><p>$1971\,\texttt{至}\,N/A\,\,\,\,\,\,\,\texttt{超大规模集成电路}$</p></li><li><p>按性能分类</p></li></ul><p>巨型机&gt;大/中型机&gt;小型机&gt;微型机=工作站。</p><ul><li><p>巨型机：<strong>速度极快，容量极高，体积极大</strong>。用于<strong>计算地震/太空/天气预报</strong>等复杂用途，我国的有：银河/天河等。</p></li><li><p>大/中型机：<strong>速度快，容量极高，体积大</strong>。主要用于<strong>顶尖科研领域</strong>。</p></li><li><p>小型机：<strong>速度快，容量高，体积中</strong>。主要用于<strong>单位服务器/其他领域</strong>。</p></li><li><p>微型机：<strong>速度快，容量中，体积小</strong>。主要用于<strong>个人工作/处理数据，$20$ 世纪 $70$ 年代后非常普及（电脑大部分都是微型机）</strong>。</p></li><li><p>工作站：<strong>速度快，容量中，体积小</strong>。用于<strong>辅助微型机工作</strong>。</p></li></ul></li><li><p>空间换算 $\bigstar$</p><p>$8Bit(\text{比特}) = 1B(Byte/\text{字节})$</p><p>$1024B = 1K(B)(Kilobyte)$</p><p>$1024K(B) = 1M(B)(Millonbyte)$</p><p>$1024M(B) = 1G(B)(Gigabyte)$</p><p>$1024G(B)=1T(B)(Terabyte)$</p><p>$\cdots$</p><p>往上还有 $PB$ 等，不会考。</p><p>表示 $KB/MB/\cdots$ 时 $B$ 可加可不加。</p></li><li><p>重要贡献人员 $\bigstar$</p><ul><li><p>艾伦·图灵（英）：计算机科学/人工智能之父，<strong>首次提出了计算机科学理论</strong>。计算机界的最高奖项“图灵奖”以他命名，被称为“计算机界的诺贝尔奖”。</p></li><li><p>冯·诺依曼（美）：现代计算机之父，<strong>首次提出了存储程序控制原理</strong>，称为“冯·诺依曼结构”。</p></li><li><p>Ada·Lovelace：第一位程序员/第一位软件设计工程师。  </p></li></ul><p>补：Ada 同时是美国军方发明的语言，为了纪念第一个女程序员</p><ul><li><p>习题</p><ul><li><a href="https://www.luogu.com.cn/paste/5zjsbw4l">CSP 2019 入门组第一轮-T15</a> </li></ul></li></ul></li><li><p>计算机的构成 $\checkmark$</p><p>要想实现计算机的基础功能，计算机必须由<strong>运算器、控制器、存储器、输入设备、输出设备</strong>构成，缺少一个就无法正常启动计算机，即为“冯·诺依曼结构”。</p><ul><li><p>CPU（Central Processing Unit）：中央处理器，由<strong>运算器（计算）+控制器（指挥）+寄存器</strong>组成。</p></li><li><p>运算器=算术逻辑运算单元（ALU）及浮点运算单元（FPU）</p></li><li><p>存储器=内存储器+外存储器</p></li></ul><p><strong>计算机的核心部件</strong>，被称为计算机的“大脑”，又称“微处理器”。</p><ul><li><p>内存储器：简称“内存”，用于<strong>电脑内部</strong>的存储。相对外存而言，<strong>读写速度快，但是存储空间小</strong>，并且存储在 RAM 里的数据<strong>断电后会丢失</strong>。注意与“外存（硬盘等）”区分开。</p></li><li><p>RAM（Random Access Memory）：随机存取存储器，与CPU直接交互数据，可随时读写，<strong>断电数据全部丢失</strong>。</p></li><li><p>ROM（Read-Only Memory）：只读存储器，只能读出无法写入信息。信息一旦写入后就固定下来，<strong>断电数据不会丢失</strong>，故又称为固定存储器。</p></li><li><p>外存储器：简称“外存”，用于处置长期保存的数据，一般<strong>处于电脑外部</strong>，<strong>断电后数据不会丢失</strong>。相对内存而言，外存<strong>读写速度慢，但存储容量大</strong>。主要包括硬盘、光盘、U 盘（USB闪存盘）等类型。</p></li><li><p>输入设备：在计算机与人交互时，<strong>接受外部命令或者需要加工的数据</strong>。常用的输入数据包括键盘、鼠标、麦克风、摄像头等。</p></li><li><p>输出设备：在计算机与人交互时，<strong>将处理结果以人类能够识别/感受的方式呈现出来</strong>的设备。常有的输出设备包括显示器、音响、打印机等。</p></li></ul><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/fa9691s0.png" alt="" /></p><p>如上图，为各个设备之间的关系，不同设备用不同颜色进行表示。</p></li><li><p>关于CPU $\checkmark$</p><ul><li><p>访问速度：寄存器&gt;高速缓存&gt;内存&gt;外存。</p></li><li><p>历史：出现于 $20$ 世纪 $70$ 年代。</p></li><li><p>断电后数据保留于 ROM 和外存。</p></li></ul></li><li><p>文件扩展名（注意不是“拓展名”） $\checkmark$</p><ul><li><p>图像存储：jp(e)g/png/pic/bmp/gif。</p></li><li><p>音频存储：mp3/wav。</p></li><li><p>视频存储：mp4/avi/mpeg/flv/rmvb/rpm。</p></li></ul></li><li><p>计算机语言常识 $\bigstar$</p><ul><li><p>机器语言/机器码：最早的语言，计算机<strong>唯一能识别的语言</strong>，<strong>由二进制数字 $0/1$ 组成</strong>，速度快，难度高。</p></li><li><p>汇编语言：用符号代替二进制数，<strong>计算机不能直接识别</strong>，需要用编译器进行编译，难度依然很大，目前除了对性能要求极高外不被使用。</p></li><li><p>高级语言：如今的编程语言（C++，JAVA等），需要用编译器，难度小，分为编译方式和解释方式两种编译方式。</p><ul><li><p>编译方式（C++）：先对整个程序进行编译（会进行多次分析），再执行程序。速度快（进行多次编译对程序进行优化）。</p></li><li><p>解释方式（Python/PHP）：扫描一行解释一行，速度慢（无法进行优化）。</p></li></ul></li><li><p>习题：</p><ul><li><a href="https://www.luogu.com.cn/paste/3eb3hn06">CSP 2020 入门组第一轮-T2</a></li></ul></li></ul></li><li><p>ASCII码常识 $\checkmark$</p><p>ASCII码（American Standard Code for Information Interchange）是<strong>美国国家交换标准代码</strong>，现成为<strong>世界交换代码标准</strong>。</p><p>ASCII码是一种用 $8$ 个比特组成的二进制编码（即<strong>一个字节</strong>），用于表示 $128$ 个国际通用字符。</p><ul><li><p>数字 $0$ 到 $9$：第 $48$ 至 $57$ 位。</p></li><li><p>$26$ 个字母：小写：第 $97$ 至 $122$ 位，大写：第 $65$ 至 $90$ 位。</p></li><li><p>通用符号（可见的，如 +/-）：$32$ 个。</p></li><li><p>控制符号（不可见的，如空格/回车）。</p></li></ul><p>补：$2^8 = 256$，$2^7 = 128$，这是因为多余的一位被多数系统当做<strong>校验码</strong>，以提高字符传输的可靠性。所以只能表示 $2^7 = 128$ 个字符。</p><p>补：一个汉字在计算机中占 $2$ 个字节。</p></li><li><p>计算机病毒 $\checkmark$</p><p>病毒具有<strong>隐蔽性、潜伏性、传播性、激发性、破坏性、危害性</strong>。</p><p>可通过网络/硬盘传播，主要针对软件系统，用于获利。</p><p>注意：如果只对一台机器进行攻击，被称为<strong>黑客/hacker</strong>而不是病毒。</p></li><li><p>机器数与真值 $\bigstar$</p><p>计算机中要处理的整数有“无符号”和“有符号”之分，“无符号”整数顾名思义就是<strong>不考虑正负的整数</strong>，可以直接用二进制表示，故只讨论“有符号”整数。</p><ul><li><p>原码：原码将一个整数表示成符号位+二进制串。符号位上，$0$ 表示正数，$1$ 表示负数。</p><p>但是，用这种方法表示的数进行两个异号数相加或两个同号数相减时很不方便，而且 $0$ 的表示不唯一，于是引入了“反码”和“补码”。</p></li></ul><p>补：原码中，$0$ 的表示有两种: $+0$ 或 $-0$，两种的区别在于符号位，$+0$ 表示为 $00000000$，$-0$ 表示为 $10000000$。</p><ul><li><p>反码：对于一个正数，<strong>反码就是其原码</strong>；<strong>对于一个负数，反码就是除符号位外，原码的各位全部取反</strong>，即 $0$ 变 $1$，$1$ 变 $0$。</p><p>如：$x_{\text{原}}=01000101, x_{\text{反}}=01000101$。</p><p>$\,\,\,\,\,\,\,\,\,\,x_{\text{原}}=11000101, x_{\text{反}}=10111010$。</p><p>补：多数计算机不采用反码表示数值。</p></li><li><p>补码：对于一个正数，<strong>补码就是其原码</strong>；对于一个负数，<strong>补码等于反码+1</strong>。</p><p>如：$x_{\text{原}}=01000101, x_{\text{补}}=01000101$。</p><p>$\,\,\,\,\,\,\,\,\,\,x_{\text{原}}=11000101, x_{\text{补}}=10111011$。</p><p>补：在多数计算机系统中，数值由补码表示。是因为使用补码可以将符号位和数值统一处理；同时，加法和减法也可以统一处理。</p><p>补：在介绍补码如何优化加减法前，先介绍一下“模”的概念：“模”是指一个计量系统的计数范围。计算机也可以看成一个计量机器，因为计算机的存储和处理的位数是有限的，因此它也有一个计量范围，都存在一个“模”。</p><p>“模”实质上是计量器产生“溢出”的量，它的值在计量器上表示不出来，计量器上只能表示出模的余数。任何有模的计量器，均可化减法为加法运算，即<strong>取反后加1</strong>。</p><p>减法问题如果要化成加法问题，只需把减数用相应的补数表示就可以了。把补数用到计算机对数值的处理上，就是补码。</p></li></ul></li><li><p>进制 $\bigstar$</p><ul><li><p>十进制转 $n$ 进制（以二进制为例）</p><p>把十进制数每次除 $n$ 求余数，然后把余数逆序写出来。</p><p>例如 $13_{(10)}$，先 $\div 2$，商 $6$ 余 $1$。</p><p>$6 \div 2 = 3 \cdots\cdots 0$</p><p>$3 \div 2 = 1 \cdots\cdots 1$</p><p>$1 \div 2 = 0 \cdots\cdots 1$</p><p>$13_{(10)}=1101_{(2)}$</p></li><li><p>$n$ 进制转十进制（以二进制为例）</p><p>按位转换，第 $i$ 位的数字乘以要转换的进制的 $n−1$ 次幂即可。</p><p>$\,\,\,\,\,1\qquad\,\,\,\,\,\,\,\,0\qquad\,\,\,\,\,\,\,\,0\qquad\,\,\,\,\,\,\,\,1\qquad\,\,\,\,\,\,\,\,0\qquad\,\,\,\,\,\,\,\,1\qquad\,\,\,\,\,\,\,\,1\qquad\,\,\,\,\,\,\,\,0$</p><p>$1\times2^7+0\times2^6+0\times2^5+1\times2^4+0\times2^3+1\times2^2+1\times2^1+0\times2^0=150$</p></li><li><p>$n$ 进制转 $m$ 进制</p><p>以十进制作为中转，先将 $n$ 进制转为十进制，再将十进制转为 $m$ 进制。</p></li><li><p>常用进制的英文</p><ul><li><p>$16$ 进制：H(Hexadecimal)</p></li><li><p>$10$ 进制：D(Decimal)</p></li><li><p>$8$ 进制：O(Octonary)</p></li><li><p>$2$ 进制：B(Binary) </p></li></ul></li><li><p>习题</p><ul><li><a href="https://www.luogu.com.cn/paste/38793dua">CSP 2020 入门组第一轮-T9</a></li></ul></li></ul></li><li><p>逻辑运算</p><ul><li><p>逻辑非：$!$ 或 $\neg$，操作数的反值（$!1=0,!0=1$）。</p></li><li><p>逻辑与：$\&amp;\&amp;$ 或 $\land$，全部操作数都为真，结果才为真（$1\land1=1,1\land 0=0,0\land 1=1,0 \land 0=0$）。</p></li><li><p>逻辑或：$||$ 或 $\lor$，至少一个操作数为真，结果才为真（$1\lor 1=1,1\lor 0=1,0\lor 1=1,0\lor 0=0$）</p></li><li><p>运算优先级：逻辑非&gt;逻辑与&gt;逻辑或</p></li><li><p>习题</p><ul><li><p><a href="https://www.luogu.com.cn/paste/la9yoxz4">CSP 2019 入门组第一轮-T2</a> </p></li><li><p><a href="https://www.luogu.com.cn/paste/rn6zj7ef">CSP 2020 第一轮（初赛）模拟-T9</a> </p></li><li><p><a href="https://www.luogu.com.cn/paste/akdn4zs4">CSP 2020 入门组第一轮-T3</a>   </p></li></ul></li></ul></li><li><p>逻辑表达式：由逻辑运算组合而成，返回值只有 T（True） 和F（False），C++ 中 $0$ 表示假、非 $0$ 表示真。</p><p>如果逻辑表达式由多个组合，需要<strong>从右往左</strong>依次判断，最后得出答案。这种性质被称为<strong>右结合性</strong>。</p><p>例如：<code>&lt;表达式1&gt;?&lt;表达式2&gt;:&lt;表达式3&gt;?&lt;表达式4&gt;:&lt;表达式5&gt;</code>。</p><p>执行的时候是从3开始判断是否为真，然后从右往左执行每一个表达式，依次向上回溯，最后得出答案。 </p></li></ul><hr /><p>$$\large\texttt{数据结构}$$</p><ul><li><p>图论</p><ul><li><p>基本概念/术语 $\checkmark$</p><ul><li><p>顶点/节点（Vertex/Node），简称点。</p></li><li><p>边（Edge）：节点之间的连线。</p></li><li><p>完全图：<strong>任意两点都有边相连</strong>，一个 $n$ 个节点完全图的边数 $ = \dfrac{n(n+1)}{2}$ 。</p></li><li><p>简单路径：两点之间通过<strong>不重复</strong>的边相连。</p></li><li><p>连通图：<strong>任意两点都可以直接/间接到达</strong>，注意区别于完全图，<strong>完全图属于连通图，连通图不一定属于完全图</strong>。</p></li><li><p>有向图：边是有方向的（$e = u\rightarrow v$）。</p></li><li><p>无向图：边是无方向的（$e = u\leftrightarrow v$）。</p></li><li><p>环：对于一个回路 $w$，若 $v_0=v_k$ 是该<strong>回路点序列中唯一重复出现的点对</strong>，则 $w$ 是一个环。</p></li></ul><p>特别的，如果环 $w$ 只有一个点，则被称为“自环，即 $e=(u,v), u=v$。</p><ul><li><p>入度：以顶点 $v$ 为<strong>终点</strong>的边的条数为该节点的入度。</p></li><li><p>出度：以顶点 $v$ 为<strong>起点</strong>的边的条数为该节点的出度。</p></li></ul></li><li><p>树 $\bigstar$</p><ul><li><p>基本概念/术语</p></li><li><p>树：一个长得像真实生活中的树的图，任意两点之间的简单路径有且只有一条。树是一棵连通且无环的图，边数 $=n−1$。</p></li><li><p>根节点：树最上层的节点，一棵树<strong>有且只有一个</strong>。</p></li><li><p>深度：到根结点的路径上的边数。</p></li><li><p>高度：所有结点的深度的最大值。</p></li><li><p>叶节点：没有子结点的结点。</p></li><li><p>父亲：对于除根以外的每个结点，从该结点到根路径上的第二个结点。<strong>根结点没有父结点</strong>。</p></li><li><p>祖先：一个结点到根结点的路径上，除了它本身外的结点。根结点的祖先集合为空。</p></li><li><p>子节点：如果 $u$ 是 $v$ 的父亲，那么 $v$ 是 $u$ 的子结点。子结点的顺序一般不加以区分，二叉树是一个例外，<strong>有左儿子/右儿子之分</strong>。</p></li><li><p>兄弟：同一个父亲的多个子结点互为兄弟。</p></li><li><p>后代：如果 $u$ 是 $v$ 的祖先，那么 $v$ 是 $u$ 的后代。</p></li><li><p>子树：删掉与父亲相连的边后，该结点所在的子图。</p></li></ul><p><img src="https://oi-wiki.org/graph/images/tree-definition.svg" alt="" /><img src="https://oi-wiki.org/graph/images/tree-definition-subtree.svg" alt="" /></p></li><li><p>二叉树</p><ul><li><p>前/先序遍历：根 $\rightarrow$ 左子树/儿子 $\rightarrow$ 右子树/儿子。</p></li><li><p>中序遍历：左子树/儿子 $\rightarrow$ 根 $\rightarrow$ 右子树/儿子。</p></li><li><p>后序遍历：左子树/儿子 $\rightarrow$ 右子树/儿子 $\rightarrow$ 根。</p></li><li><p>遍历的特殊结论</p><ul><li><p>前/先序遍历 + 中序遍历 = 确定二叉树。</p></li><li><p>后序遍历 + 中序遍历 = 确定二叉树。</p></li></ul></li><li><p>特殊的二叉树及其性质</p></li><li><p>满二叉树/完美二叉树：<strong>所有叶结点的深度均相同的二叉树</strong>称为满二叉树/完美二叉树。</p></li><li><p>完全二叉树：只有最下面两层结点的度数可以小于 $2$，且最下面一层的结点都集中在该层的最左侧。</p></li></ul><p><img src="https://oi-wiki.org/graph/images/tree-binary-complete.svg" alt="" /><img src="https://oi-wiki.org/graph/images/tree-binary-perfect.svg" alt="" /></p><ul><li>对于一棵满二叉树/完美二叉树，其深度为 $k$，则其节点总数为 $2^k-1$，此结论可逆。</li></ul></li><li><p>习题</p></li><li><p><a href="https://www.luogu.com.cn/paste/75gd1rkz">CSP 2019 入门组第一轮-T8</a></p></li></ul></li><li><p>栈</p><ul><li><p>定义/术语</p><ul><li><p>定义：有一叠碗，每一次取的时候取最上面的出来，放的时候放到最上面，先进来的后出去，后进来的先出去，这就是<strong>后进先出（last in first out）表</strong>，简称 LIFO 表。</p></li><li><p>栈顶：栈最顶端的元素。</p></li><li><p>栈底：栈最底端的元素。</p><p><img src="https://oi-wiki.org/ds/images/stack.svg" alt="" /></p></li></ul></li><li><p>操作</p><ul><li><p><code>push(x)</code> 往栈顶前添加一个元素 $x$。</p></li><li><p><code>pop()</code> 从栈顶弹出（删除）一个元素。</p></li><li><p><code>top()</code> 返回栈顶的值。</p></li><li><p><code>empty()</code> 返回是否为空。（<strong>$1$ 为空，$0$ 为非空</strong>） </p></li><li><p><code>size()</code> 返回栈里的元素个数。</p></li></ul></li></ul></li><li><p>队列</p><ul><li><p>定义/术语</p><ul><li><p>定义： 与生活中的队列相同，一条队伍，没有人会插队，大家都按队伍的规矩排好。先进来的先出去，后进来的后出去，这就是<strong>先进先出（first in first out）表</strong>，简称 FIFO 表。</p></li><li><p>队首/队头：队列的第一项。</p></li><li><p>队尾：队列的最后一项。</p></li><li><p>操作</p></li><li><p><code>push(x)</code> 往队尾后添加一个元素 $x$。</p></li><li><p><code>pop()</code> 从队首弹出（删除）一个元素。</p></li><li><p><code>front()</code> 返回队首的值。</p></li><li><p><code>empty()</code> 返回是否为空。（<strong>$1$ 为空，$0$ 为非空</strong>） </p></li><li><p><code>size()</code> 返回队列里的元素个数。</p></li></ul></li></ul></li><li><p>链表</p><ul><li><p>定义/特点</p><ul><li><p>定义：链表和数组都可用于存储数据，其中链表通过指针来连接元素，而数组则是把所有元素按次序依次存储。</p></li><li><p>链表可以方便地删除、插入数据，操作次数是 $O(1)$，但是访问任意数据时操作次数是 $O(n)$。</p></li><li><p><strong>链表不可以随机访问任意数据！</strong></p></li></ul></li><li><p>习题</p><ul><li><a href="https://www.luogu.com.cn/paste/myi7asg0">CSP 2019 入门组第一轮-T6</a></li></ul></li></ul></li><li><p>字符串</p><ul><li><p>定义：字符串就是一串字符组成的串。</p></li><li><p>子串：子串被定义为<strong>字符串中任意个连续的字符组成的子序列</strong>，子串个数 $=\dfrac{n(n+1)}{2}+1$，非空子串的个数 $=\dfrac{n(n+1)}{2}$（无非就是少了空子串的 $+1$）</p></li></ul></li></ul><hr /><p>$$\large\texttt{数学}$$</p><ul><li><p>最大公约数/最小公倍数 $\checkmark$</p><ul><li><p>最大公约数：两/多个数之间最大的共有因数。</p></li><li><p>最小公倍数：两/多个数之间最小的共有倍数。 </p><ul><li><p>具体求法</p><ul><li>短除法：先用这几个数的公约数连续去除，一直除到所有的商互质为止，然后把所有的除数连乘起来，所得的积就是这几个数的最大公约数。具体写法如下图：</li></ul><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/kkjybbz5.png" alt="" /></p><p>可以得到规律：最大公约数为<strong>左侧能被所有数字整除的数的乘积（此处只有 $2$。$3$ 不是是因为 $50$ 不能整除 $3$）</strong>；最小公倍数为<strong>左侧和下侧所有数的乘积</strong>。</p><p>显然，短除法并<strong>不适合较大的数字</strong>，运算会特别麻烦，出错率高。所以<strong>辗转相除法</strong>就应运而生了。</p><ul><li><p>辗转相除法（欧几里得算法）：辗转相除法是用来求<strong>两个正整数最大公约数</strong>的算法。以除数和余数反复做除法运算，当余数为 $0$ 时，取当前算式除数为最大公约数。</p><p>例如：求 $437$ 和 $323$ 的最大公约数。</p><p>$437\div 323=1\cdots\cdots114$</p><p>$323\div 114=2\cdots\cdots95$</p><p>$114\div 95=1\cdots\cdots19$</p><p>$95\div 19=5(\cdots\cdots0)$</p><p>$\therefore \gcd(437,323)=19$</p></li></ul></li></ul></li><li><p>习题</p><ul><li><a href="https://www.luogu.com.cn/paste/uvi1yrbu">CSP 2019 入门组第一轮-T10</a></li></ul></li></ul></li><li><p>排列组合 $\checkmark$</p><ul><li><p>加法原理：完成一项工作有 $n$ 种方法，$a_i(1\le i \le n)$ 代表完成第 $i$ 类方法的数目，共有 $S=a_1+a_2+\cdots+a_{n-1}+a_n$ 种不同的方法。</p></li><li><p>乘法原理：完成一项工作有 $n$ 个步骤，$a_i(1\le i \le n)$ 代表完成第 $i$ 个步骤的数目，共有 $S=a_1\times a_2\times \cdots\times a_{n-1}\times a_n$ 种不同的方法。</p></li><li><p>排列（Arrangement/Permutation）</p><ul><li><p>定义：从 $n$ 个不同元素中，任取 $m$（$m\le n$）个元素按照一定的顺序排成一列，读做从 $n$ 个不同元素中取出 $m$ 个元素的一个排列，记为 $A_n^m$（或 $P_n^m$）。</p></li><li><p>计算公式：$A_n^m=n(n-1)(n-2)\cdots(n-m+1)=\dfrac{n!}{(n-m)!}$</p><p>其中， $!$ 表示阶乘，例如 $6!=1\times 2 \times 3\times 4\times 5\times 6$，<strong>特别规定 $0!=1$</strong>。</p></li><li><p>证明：第 $1$ 个位置可以选 $n$ 个元素，第 $2$ 个位置由于先前已经选了一个，还可以选 $(n-1)$ 个元素，以此类推，第 $m$ 个可以选 $(n-m+1)$ 个元素。又根据上述的<strong>乘法原理</strong>，将所有的选法串联起来，因此得到上式。</p></li><li><p>全排列：排列的一种特殊情况，此时 $m=n,n-m=0$，刚刚规定过 $0!=1$，所以 $A_n^0=n!=1\times 2\times 3\cdots \times n$。</p></li></ul></li><li><p>组合（Combination）</p><ul><li><p>定义：从 $n$ 个不同元素中，任取 $m$($m\le n$) 个元素组成一个集合，读做从 $n$ 个不同元素中取出 $m$ 个元素的组合。即<strong>不关心被选元素的顺序</strong>。记为 $C_n^m$。</p></li><li><p>公式：$C_n^m=\dfrac{A_n^m}{m!}=\dfrac{n!}{m!(n-m)!}$</p></li><li><p>证明：如果 $n$ 个元素中选 $m$ 个且关心顺序，为 $A_n^m$。<strong>但是此时不关心顺序了，就需要去掉重复的</strong>，同样选出来的 $m$ 个元素，还要进行全排列，即除掉 $m!$，因此展开后得到上式。</p></li></ul><p>组合数也常用 $\dbinom{n}{m}$ 表示，读作“$n$ 选 $m$”，更为清晰明了。</p></li><li><p>排列组合九大解题技巧（按理解难度排序）</p><ul><li><p>先选后排：<strong>先将元素选出来，再进行排列</strong>，非常有效的降低问题的复杂度。 </p></li><li><p>特殊优先：<strong>特殊元素，优先处理；特殊位置，优先考虑</strong>。</p></li><li><p>分排用直排：$n$ 个元素，从中选出 $m$ 个，将这 $m$ 个元素排成若干排。分排问题的排列可以看做一排，避免考虑了复杂的前后排列，简化了问题。</p><p>$S=A_n^m$ </p></li><li><p>分类法：当<strong>计算符合条件的数目比计算不符合条件数目简单时</strong>，将问题分成若干类，逐个求解，与“排除法”相对。</p></li><li><p>排除法：当<strong>计算符合条件的数目比计算不符合条件数目复杂时</strong>，简称<strong>正难则反</strong>。排除不符合要求的，剩下的就是符合题目要求的。与“分类法”相对。</p></li><li><p>捆绑法：$n$ 个不同元素排成一列，要求 $m$ 个元素必须相邻。<strong>可以特殊优先，把 $m$ 个元素捆绑在一块单独处理</strong>。</p><p>$S=A_{n-m+1}^{n-m+1}\times A_m^m$</p></li><li><p>插空法：$n$ 个不同元素排成一列，要求 $m$ 个元素不能相邻。<strong>先把不用特殊处理的元素进行排列，再把甲乙进行插空。</strong></p><p>$S=A_{n-m}^{n-m}\times A_{n-1}^{m}$</p></li><li><p>隔板法/插板法：将 $n$ 个<strong>相同元素</strong>分成 $m$ 组，每组至少有一个元素。<strong>相当于把 $m-1$ 个隔板插到 $n$ 个元素形成的 $n-1$ 个空隙里</strong>。</p><p>$S=C_{n-1}^{m-1}$</p></li><li><p>定序： $n$ 个元素的全排列中有 $m$ 个元素必须定序排列，这 $m$ 个元素相邻或不相邻不受限制。</p><p>$S=\dfrac{A_n^n}{A_m^m}$</p></li></ul></li><li><p>习题</p><ul><li><p><a href="https://www.luogu.com.cn/paste/4zbhz6jq">CSP 2019 入门组第一轮-T7</a></p></li><li><p><a href="https://www.luogu.com.cn/paste/brwxax1m">CSP 2019 入门组第一轮-T13</a>（本题强烈建议重点复习）</p></li><li><p><a href="https://www.luogu.com.cn/paste/ib40cuzn">CSP 2020 第一轮（初赛）模拟-T11</a></p></li><li><p><a href="https://www.luogu.com.cn/paste/0o3mku6i">CSP 2020 入门组第一轮-T14</a></p></li></ul></li></ul></li><li><p>质数</p><ul><li><p>定义：在大于 $1$ 的自然数中，除了 $1$ 和它本身以外不再有其他因数的自然数。否则称为合数。</p><p>特别的，<strong>$1$ 既不是质数也不是合数</strong>。</p></li><li><p>$100$ 以内的质数（共 $25$ 个）：$2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97$，$91$ 是合数，但容易误以为是质数。   </p></li><li><p>习题</p><ul><li><a href="https://www.luogu.com.cn/paste/04rhey3z">CSP 2019 入门组第一轮-T9</a></li></ul></li></ul></li></ul><hr /><p>$$\large\texttt{杂项}$$</p><ul><li><p>IP $\checkmark$</p><ul><li>IPv4：四个十进制数，以 <code>.</code> 隔开，每一个数字取 $0-255$，例如 <code>12.34.56.78</code>。</li></ul><p>补：IP 分割成 $4$ 份是为了方便管理。相信大家都听说过洛谷“封IP（段）”这个惩罚，每一位代表着你身处于哪一段。如：需要把 <code>12.34.56.0</code> 到 <code>12.34.56.255</code> 内的 IP 全部封号，只需要封 <code>12.34.56.*</code> 即可达到操作。</p><ul><li>IPv6：六个十六进制数，以 <code>:</code> 隔开，主要是<strong>防止 IPv4 不够用</strong>。</li></ul></li><li><p>缩写 $\checkmark$</p><ul><li><p>记忆方法：英语好的同学建议记下英文全称，英语不好的话可以记下释义。</p></li><li><p>局域网：LAN（Local Area Network），小范围的网络，$1km$ 以内传输效率极高，结构简单。</p></li><li><p>城域网：MAN（Metropolitan Area Network），数千米至数十千米内。</p></li><li><p>广域网：WAN（Wide Area Network），数十千米至数千千米以上。</p></li><li><p>随机存储器：RAM（Random Access Memory）。</p></li><li><p>只读存储器：ROM（Read Only Memory）。</p></li><li><p>万维网：WWW（World Wide Web）。</p></li><li><p>文件传输协议：FTP（File Transfer Protocol）。</p></li><li><p>超文本传输协议：HTTP（S）（Hyper Text Transfer Prtcl（over Securesocket ayer）），带 “S”的为增加了传输加密和身份认证。</p></li></ul></li><li><p>关于 NOIP $\bigstar$</p><ul><li><p>NOIP（National Olympiad in Informatics in Provinces），全国青少年信息学奥林匹克联赛（省级），开办于 $1995$ 年，截止 $2018$ 已举办 $24$ 届，$2019$ 年暂停，$2020$ 年恢复。</p></li><li><p>复赛使用 C、C++、Pascal，$2022$ 年后只能使用 C++。</p></li><li><p>复赛使用 NOI Linux 评测。</p></li><li><p>NOI（National Olympiad in Informatics）：全国青少年计算机程序设计竞赛，开办于 $1984$ 年，现更名全国青少年信息学奥林匹克竞赛。</p></li><li><p>APIO（Asia-Pacific Informatics Olympiad）：亚洲与太平洋地区信息学奥林匹克竞赛。</p></li><li><p>IOI（International Olympiad in Informatics）：国际信息学奥林匹克竞赛，<strong>等级最高的信息学竞赛</strong>。</p></li></ul></li><li><p>图片存储与屏幕分辨率 $\bigstar$</p><ul><li><p>分辨率：分辨率就是屏幕上显示的像素个数，分辨率 $160\times 128$ 的意思是水平方向含有像素数为 $160$ 个，垂直方向像素数 $128$ 个。<strong>屏幕尺寸相同，分辨率越高，显示效果就越精细和细腻。</strong></p></li><li><p>图片存储：给出一张图片的分辨率和色彩的位率（位率越高色彩越多），要算出这张图片所占的空间（一般是 MB）。</p><p>计算公式：</p><p>$\text{水平方向像素数}\times \text{垂直方向像素数}\times \text{色彩位率}=\text{图片所占空间（Bit）}$</p><p>计算完毕后<strong>记得转化单位</strong>。</p><p>例如：某张图片的分辨率为 $1024\times 1024$，是 $24$ 位真彩色，求这张图片占了多少 MB。</p><p>$\dfrac{1024\times 1024 \times 24}{1024\times 1024\times 8}=3\text{(MB)}$</p></li></ul></li></ul><hr /><p>$$\large\texttt{参考文献及鸣谢}$$</p><ul><li><p>参考了部分网络资源以及原有的文章，还有CSP/NOIP的试题。</p></li><li><p>二叉树、栈、队列图片来自<a href="https://oi-wiki.org/">OI wiki</a>。</p></li><li><p>感谢@<a href="https://www.luogu.com.cn/user/212283">Aw顿顿</a>和@<a href="https://www.luogu.com.cn/user/68344">离散小波变换°</a> 提供 $\LaTeX$ 指导。</p><p>$$\tiny \text{（以上排名不分先后）}$$</p></li></ul><p>以上就是 $\text{CSP}\mathbb{\text{初赛通过指南-基础篇}}$ 的全部内容了]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文适合普及组到提高组的同学学习，并且尽量做到优秀的排版和通俗易懂，少用缩写。&lt;/p&gt;
&lt;p&gt;标有 $\checkmark$ 的为常考/出现过，标有“补”为拓展内容，标有 $\bigstar$ 为&lt;strong&gt;每年几乎必考&lt;/strong&gt;，加粗的内容为提炼过后的重点。&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>C++中如何使用struct和STL创建链表结构</title>
    <link href="https://billma.top/2021/08/21/stl_use/"/>
    <id>https://billma.top/2021/08/21/stl_use/</id>
    <published>2021-08-21T07:39:00.000Z</published>
    <updated>2021-08-23T06:06:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-链表结构的使用"><a href="#一-链表结构的使用" class="headerlink" title="一.链表结构的使用"></a>一.链表结构的使用</h2><h3 id="1-创建"><a href="#1-创建" class="headerlink" title="1.创建"></a>1.创建</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;<span class="comment">//该链数据</span></span><br><span class="line">    node *next;<span class="comment">//指向链表下一个数据</span></span><br><span class="line">&#125;</span><br><span class="line">node *p;<span class="comment">//链表所在的地址</span></span><br></pre></td></tr></table></figure><h3 id="2-新增存储单元"><a href="#2-新增存储单元" class="headerlink" title="2.新增存储单元"></a>2.新增存储单元</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = <span class="keyword">new</span> node;</span><br></pre></td></tr></table></figure><h3 id="3-其他所需的操作符"><a href="#3-其他所需的操作符" class="headerlink" title="3.其他所需的操作符"></a>3.其他所需的操作符</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node *head;<span class="comment">//指向头节点</span></span><br><span class="line">node *p;<span class="comment">//用来申请新的数据单元</span></span><br><span class="line">node *r;<span class="comment">//用来指向末节点(最后一个数据)</span></span><br></pre></td></tr></table></figure><h3 id="4-输入一个链表"><a href="#4-输入一个链表" class="headerlink" title="4.输入一个链表"></a>4.输入一个链表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x;<span class="comment">//每次输入的数据</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line"><span class="keyword">while</span> (<span class="comment">/*输入链条的终止条件*/</span>)&#123;</span><br><span class="line">    p=<span class="keyword">new</span> node;<span class="comment">//申请一个新节点</span></span><br><span class="line">    p-&gt;data=x;<span class="comment">//录入数据</span></span><br><span class="line">    p-&gt;next=<span class="literal">NULL</span>;<span class="comment">//初始化下一个节点避免闪退</span></span><br><span class="line">    r-&gt;next=p;<span class="comment">//将新节点接到前面链表中</span></span><br><span class="line">    r=p;<span class="comment">//末节点后移</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);<span class="comment">//输入下一个数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-输出链表"><a href="#5-输出链表" class="headerlink" title="5.输出链表"></a>5.输出链表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p=head-&gt;next;<span class="comment">//p指针回到链表开头</span></span><br><span class="line"><span class="keyword">while</span>(p-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,p-&gt;data);</span><br><span class="line">    p=p-&gt;next;<span class="comment">//到下一个节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,p-&gt;data);<span class="comment">//把最后一个数据也输出</span></span><br></pre></td></tr></table></figure><h3 id="6-查找某个条件的数据"><a href="#6-查找某个条件的数据" class="headerlink" title="6.查找某个条件的数据"></a>6.查找某个条件的数据</h3><h4 id="a-查找满足一定条件的节点"><a href="#a-查找满足一定条件的节点" class="headerlink" title="a.查找满足一定条件的节点"></a>a.查找满足一定条件的节点</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p=head-&gt;next;</span><br><span class="line"><span class="keyword">while</span>((p-&gt;data !=(满足的条件))&amp;&amp;(p-&gt;next !=<span class="literal">NULL</span>))p=p-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(p-&gt;data ==(满足的条件))处理该数据;</span><br><span class="line"><span class="keyword">else</span> 输出不存在;</span><br></pre></td></tr></table></figure><h4 id="b-查找所有满足条件的点"><a href="#b-查找所有满足条件的点" class="headerlink" title="b.查找所有满足条件的点"></a>b.查找所有满足条件的点</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p=head-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(p-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;data==(满足的条件))&#123;</span><br><span class="line">        <span class="comment">/*处理该数据*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    p=p-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二-使用STL容器进行"><a href="#二-使用STL容器进行" class="headerlink" title="二.使用STL容器进行"></a>二.使用STL容器进行</h2><h3 id="a-set"><a href="#a-set" class="headerlink" title="a.set"></a>a.set</h3><h4 id="1-特点"><a href="#1-特点" class="headerlink" title="1.特点"></a>1.特点</h4><p>无序，随机，类似于指针（但其实不是指针，STL容器过于强大）</p><h4 id="2-头文件"><a href="#2-头文件" class="headerlink" title="2.头文件"></a>2.头文件</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure><h4 id="3-定义容器"><a href="#3-定义容器" class="headerlink" title="3.定义容器"></a>3.定义容器</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set&lt;kind&gt;name</span><br><span class="line"><span class="comment">/*例：*/</span>set&lt;string&gt;class_set;<span class="comment">//类中的一个学生列表</span></span><br></pre></td></tr></table></figure><h4 id="4-添加元素"><a href="#4-添加元素" class="headerlink" title="4.添加元素"></a>4.添加元素</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="comment">/*满足条件*/</span>)&#123;</span><br><span class="line">    string str;</span><br><span class="line">    cin&gt;&gt;str;</span><br><span class="line">    class_set.<span class="built_in">insert</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-输出学生集合（无序的）"><a href="#5-输出学生集合（无序的）" class="headerlink" title="5.输出学生集合（无序的）"></a>5.输出学生集合（无序的）</h4><h5 id="1-创建迭代器"><a href="#1-创建迭代器" class="headerlink" title="[1]创建迭代器"></a>[1]创建迭代器</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set&lt;kind&gt;::const_iterator cur_name;<span class="comment">//cur_name为迭代器</span></span><br><span class="line"><span class="comment">/*example*/</span>set&lt;string&gt;::const_iterator cur_student;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="2-遍历输出"><a href="#2-遍历输出" class="headerlink" title="[2]遍历输出"></a>[2]遍历输出</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(cur_student = class_set.<span class="built_in">begin</span>();</span><br><span class="line">    cur_student !=class_set.<span class="built_in">end</span>();</span><br><span class="line">    cur_student++)cout&lt;&lt;*cur_student&lt;&lt;endl;</span><br></pre></td></tr></table></figure><blockquote><p>cur_student被定义成string类型的迭代器，类似于指针地址</p></blockquote><blockquote><p>初始条件：cur_student指针指向class_set.begin()的地址</p></blockquote><blockquote><p>终止条件：cur_student指针指向class_set.end()的地址</p></blockquote><p><em><strong>注意：不能将for循环里面的！=改成&lt;或者其他符号，因为列表是无序的。++指的是地址后移一位，而不是数字+1</strong></em></p><h5 id="3-使用foreach函数进行遍历输出"><a href="#3-使用foreach函数进行遍历输出" class="headerlink" title="[3]使用foreach函数进行遍历输出"></a>[3]使用foreach函数进行遍历输出</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*1.头文件*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="comment">/*2.创建输出指令*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(set&lt;string&gt;::const_iterator cur_student)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;*cur_student&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*3.使用foreach进行遍历*/</span></span><br><span class="line">foreach(class_set.<span class="built_in">begin</span>(),class_set.<span class="built_in">end</span>(),write);</span><br></pre></td></tr></table></figure><h4 id="6-其它"><a href="#6-其它" class="headerlink" title="6.其它"></a>6.其它</h4><p>set容器当中不能有重复的元素，否则程序会意外终止。如果你想要存放重复元素，你可以将上述set换成multiset即可。</p><h3 id="b-map"><a href="#b-map" class="headerlink" title="b.map"></a>b.map</h3><h4 id="1-特点-1"><a href="#1-特点-1" class="headerlink" title="1.特点"></a>1.特点</h4><p>不同于set，map有两个值，第一个可以称为关键字(key)，每个关键字只能在map中出现一次；第二个可能称为该关键字的值(value)；</p><p>key在一个map只能出现一次，但是value可以出现多次。</p><p>key和value是一对一(one-to-one)的，而不同于set，map是有序对。</p><h4 id="2-头文件-1"><a href="#2-头文件-1" class="headerlink" title="2.头文件"></a>2.头文件</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure><h4 id="3-声明map"><a href="#3-声明map" class="headerlink" title="3.声明map"></a>3.声明map</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std:map&lt;type1,type2&gt; variable;</span><br><span class="line"><span class="comment">/*example*/</span>std:map&lt;<span class="keyword">int</span>,string&gt; person;</span><br></pre></td></tr></table></figure><p>当然，如果你觉得每次都定义一个map太烦了，你可以使用<code>typedef</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> map&lt;<span class="keyword">int</span>,string&gt; mapp;</span><br><span class="line">mapp variable1;</span><br><span class="line">mapp variable2;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="4-加入元素"><a href="#4-加入元素" class="headerlink" title="4.加入元素"></a>4.加入元素</h4><p>现在，我们已经声明了一个叫做<code>variable</code>的map容器(你自己随便声明一个也无所谓)。插入有几种方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//First Kind:INSERT function</span></span><br><span class="line"><span class="comment">//1.insert+pair</span></span><br><span class="line">varibale.<span class="built_in">insert</span>(pair&lt;type1,type2&gt;(key,value));</span><br><span class="line"><span class="comment">/*example*/</span>variable.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>,string&gt;(<span class="number">1</span>,<span class="string">&quot;Bill Gates&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.insert+value_type</span></span><br><span class="line">variable.<span class="built_in">insert</span>(map&lt;type1,type2&gt;::<span class="built_in">value_type</span>(key,value));</span><br><span class="line"><span class="comment">/*example*/</span>variable.<span class="built_in">insert</span>(map&lt;<span class="keyword">int</span>,string&gt;::<span class="built_in">value_type</span>(<span class="number">2</span>,<span class="string">&quot;Jeff Bezos&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//Second Kind:Array[]</span></span><br><span class="line">variable[key]=value;</span><br><span class="line"><span class="comment">/*example*/</span>variable[<span class="number">3</span>]=<span class="string">&quot;Michael Dell&quot;</span>;</span><br></pre></td></tr></table></figure><p>为什么我要分为两种呢？因为使用insert+pair和insert+value_type组合效果是相同的。他俩都是通过insert函数插入数据。但是，如果某key已经有了一个value，insert函数是会自动跳过不执行指令的。如果使用array数组进行插入，新输入的数据就会把原有的数据覆盖住。</p><h4 id="5-查找元素"><a href="#5-查找元素" class="headerlink" title="5.查找元素"></a>5.查找元素</h4><p>这个时候又要用到迭代器了。先声明一个迭代器iterate，随后循环查找：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iterate = variable.<span class="built_in">find</span>(key);</span><br><span class="line"><span class="keyword">while</span>(iterate != variable.<span class="built_in">end</span>())&#123;</span><br><span class="line">    <span class="comment">/*处理该数据*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-删除元素"><a href="#6-删除元素" class="headerlink" title="6.删除元素"></a>6.删除元素</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.iterate</span></span><br><span class="line">iterate =variable.<span class="built_in">find</span>(key);</span><br><span class="line"><span class="keyword">int</span> del =variable.<span class="built_in">erase</span>(iterate);</span><br><span class="line"><span class="comment">//erase函数删除成功返回1，否则返回0，下同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.key</span></span><br><span class="line"><span class="keyword">int</span> del =variable.<span class="built_in">erase</span>(key);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.delete key1~key2</span></span><br><span class="line"><span class="keyword">int</span> del =variable.<span class="built_in">erase</span>(key1,key2);</span><br><span class="line"><span class="comment">//把key1到key2之间所有的数据全部删除</span></span><br><span class="line"><span class="comment">//如果想删除某map所有数据，有以下两种办法：</span></span><br><span class="line"><span class="comment">/*1*/</span><span class="keyword">int</span> del =variable.<span class="built_in">erase</span>(variable.<span class="built_in">begin</span>(),variable.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">/*2*/</span><span class="keyword">int</span> del =variable.<span class="built_in">clear</span>();</span><br></pre></td></tr></table></figure><h4 id="7-map大小"><a href="#7-map大小" class="headerlink" title="7.map大小"></a>7.map大小</h4><p>我怎么知道map里面目前有多少数据呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num =variable.<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure><p>未完待续。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一-链表结构的使用&quot;&gt;&lt;a href=&quot;#一-链表结构的使用&quot; class=&quot;headerlink&quot; title=&quot;一.链表结构的使用&quot;&gt;&lt;/a&gt;一.链表结构的使用&lt;/h2&gt;&lt;h3 id=&quot;1-创建&quot;&gt;&lt;a href=&quot;#1-创建&quot; class=&quot;headerli</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>世界最大同性交友网站七夕再搞事————remote  ：Support for password authentication was removed on August 13, 2021.</title>
    <link href="https://billma.top/2021/08/21/github-tokenerror/"/>
    <id>https://billma.top/2021/08/21/github-tokenerror/</id>
    <published>2021-08-21T07:39:00.000Z</published>
    <updated>2021-08-22T08:47:34.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>原创文章，转载注明出处！</strong></p><h3 id="1-问题背景-background"><a href="#1-问题背景-background" class="headerlink" title="1.问题背景-background"></a>1.问题背景-background</h3><p>如果你在七夕（没错就是2021年8月14日）<strong>的这一天去访问了全球最大的同性交友网站</strong>，<strong>又刚好去更新提交代码</strong>，<strong>或者你创建了一个新的仓库送给自己</strong>，<strong>又刚好想把这个仓库送给github</strong>，你就刚好会遇到这个问题：remote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead.<br>大概意思就是你原先的密码凭证从2021年8月13日开始就不能用了，必须使用个人访问令牌（personal access token），就是把你的密码替换成token！</p><p><strong>滚！我tm懒得弄！</strong></p><p><img src="https://i.postimg.cc/zG2L02b1/Q-R9-VOLZG-DIN2-V0-HF-S8.png"> </p><p> <strong>Github <a href="https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/">官方解释</a></strong></p><blockquote><p>We described our motivation as we announced similar changes to authenticating with the API as follows:</p></blockquote><blockquote><p>In recent years, GitHub customers have benefited from a number of security enhancements to GitHub.com, such as two-factor authentication, sign-in alerts, verified devices, preventing the use of compromised passwords, and WebAuthn support. These features make it more difficult for an attacker to take a password that’s been reused across multiple websites and use it to try to gain access to your GitHub account. Despite these improvements, for historical reasons customers without two-factor authentication enabled have been able to continue to authenticate Git and API operations using only their GitHub username and password.</p></blockquote><blockquote><p>Beginning August 13, 2021, we will no longer accept account passwords when authenticating Git operations and will require the use of token-based authentication, such as a personal access token (for developers) or an OAuth or GitHub App installation token (for integrators) for all authenticated Git operations on GitHub.com. You may also continue using SSH keys where you prefer.</p></blockquote><blockquote><p>Tokens offer a number of security benefits over password-based authentication:</p></blockquote><blockquote><p>1.Unique – tokens are specific to GitHub and can be generated per use or per device</p></blockquote><blockquote><p>2.Revocable – tokens can can be individually revoked at any time without needing to update unaffected credentials</p></blockquote><blockquote><p>3.Limited – tokens can be narrowly scoped to allow only the access necessary for the use case</p></blockquote><blockquote><p>4.Random – tokens are not subject to the types of dictionary or brute force attempts that simpler passwords that you need to remember or enter regularly might be</p></blockquote><p>大概意思就是：<strong>为了保证各位程序员的账户安全，我们已于2021年7月14日禁止大家在git及第三方应用上通过密码授权GitHub。以后将使用token令牌代替密码。</strong><br>（话说能活跃在全球最大同性交友网站的程序猿能有什么秘密值得如此加密。。。）</p><h3 id="2-什么是token令牌？"><a href="#2-什么是token令牌？" class="headerlink" title="2.什么是token令牌？"></a>2.什么是token令牌？</h3><p>token令牌相当于在第三方接口代替你密码的一个玩意，有点像强密码。但是，token令牌并不是只能有唯一一个的。你可以拥有多个令牌，给不同的第三方接口不同的令牌，而每个令牌都被赋予了不同的权限和使用期限。也就是说，在令牌没赋予的权利将不会给第三方接口和git。当然，token令牌在你设定的期限之后，对应的第三方接口和git就需要你重新给一个令牌，否则也无法使用。令牌也可以随时更改权限和删除。</p><h3 id="3-如何申请token令牌？"><a href="#3-如何申请token令牌？" class="headerlink" title="3.如何申请token令牌？"></a>3.如何申请token令牌？</h3><p>登陆你的GitHub（<strong>注意，在github.com登录你的账户时还是用你的密码，不是令牌</strong>) 点击头像。随后点击settings。</p><p><img src="https://i.postimg.cc/VLBLHGhV/2.png!/scale/50"></p><p>往下拉，你会在左侧看到一个Developer settings。点击它。</p><p><img src="https://i.postimg.cc/1tqy0J6M/31.png"></p><p>左侧有Personal access tokens。点击它。</p><p><img src="https://i.postimg.cc/RZgCv341/4.png"></p><p>点击右侧generate new token。</p><p><img src="https://i.postimg.cc/sD20t1HC/5.png"></p><p>Note是你令牌的名称（不是令牌密码），随便填一个。</p><p>expiration是令牌有效期限。No expiration代表永久令牌。</p><p>下面是选择相应的权限。一般就选择repo 和delete_repo，其他按需勾选。</p><p>拉到最下面，点击generate token，随后跳出来一个界面，有一串绿底字符串即为你的token令牌。</p><p><img src="https://i.postimg.cc/NQk5NFqj/6.png"></p><p><strong>警告！！在这里你一定要将其复制并保存好！建议新建一个txt文件将令牌放入其中！因为这个令牌只会出现一次，你关闭了这个网页，以后GitHub就再也不会告诉你这个令牌了！妥善保管！</strong>（妥善保管！两情若是久长时，又岂在朝朝暮暮？）</p><p>返回刚才的界面，你可以查看已经创建的token和给予的权限与有效期。你可以随时更改，管理，删除它们（<strong>但是不会显示该令牌</strong>）。</p><p><img src="https://i.postimg.cc/XvhVyTZp/7.png"></p><p>随后回到你的git或第三方接口，账号还是输入你的username(用户名)，password就输入你复制的令牌。随后登陆就成功了。</p><h3 id="果然，全球最大的同性交流网站不是吹的，大七夕节非得找个伴侣，它要过七夕谁也拦不住呀！"><a href="#果然，全球最大的同性交流网站不是吹的，大七夕节非得找个伴侣，它要过七夕谁也拦不住呀！" class="headerlink" title="果然，全球最大的同性交流网站不是吹的，大七夕节非得找个伴侣，它要过七夕谁也拦不住呀！"></a>果然，全球最大的同性交流网站不是吹的，大七夕节非得找个伴侣，它要过七夕谁也拦不住呀！</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;原创文章，转载注明出处！&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;1-问题背景-background&quot;&gt;&lt;a href=&quot;#1-问题背景-background&quot; class=&quot;headerlink&quot; title=&quot;1.问题背景-background&quot;&gt;&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>我的第一篇博客</title>
    <link href="https://billma.top/2021/08/10/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <id>https://billma.top/2021/08/10/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</id>
    <published>2021-08-09T20:23:52.000Z</published>
    <updated>2021-08-09T20:37:24.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="首先-欢迎各位到访我的空间"><a href="#首先-欢迎各位到访我的空间" class="headerlink" title="首先,欢迎各位到访我的空间."></a>首先,欢迎各位到访我的空间.</h3><p>一直没时间打理这个博客,时至今日,终于在凌晨从百忙中完成了我的第一篇博客.<br>这就算我的第一篇博客吧.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;首先-欢迎各位到访我的空间&quot;&gt;&lt;a href=&quot;#首先-欢迎各位到访我的空间&quot; class=&quot;headerlink&quot; title=&quot;首先,欢迎各位到访我的空间.&quot;&gt;&lt;/a&gt;首先,欢迎各位到访我的空间.&lt;/h3&gt;&lt;p&gt;一直没时间打理这个博客,时至今日,终于在凌晨从百</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Calall产品发布页</title>
    <link href="https://billma.top/2021/08/07/calall2/"/>
    <id>https://billma.top/2021/08/07/calall2/</id>
    <published>2021-08-07T08:33:29.000Z</published>
    <updated>2021-08-09T21:13:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>Calall是我独自设计的一款多功能计算器，可以精确计算指数函数，对数函数，7种三角函数，阶乘，以及发送邮件，定时关机/重启电脑，多种经典单机游戏等多功能。<br><a href="https://billma007.law.blog/calall-3-0-1developer-beta2%e7%8e%b0%e5%b7%b2%e4%b8%8a%e7%ba%bf%ef%bc%81/">点此前往Calall Developer Beta2发布页</a><br><a href="">点此前往Calall Developer Beta3发布页</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Calall是我独自设计的一款多功能计算器，可以精确计算指数函数，对数函数，7种三角函数，阶乘，以及发送邮件，定时关机/重启电脑，多种经典单机游戏等多功能。&lt;br&gt;&lt;a href=&quot;https://billma007.law.blog/calall-3-0-1develop</summary>
      
    
    
    
    
  </entry>
  
</feed>
